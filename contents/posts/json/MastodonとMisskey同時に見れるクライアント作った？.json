{
  "title": "MastodonとMisskey同時に見れるクライアント作った？",
  "created_at": "2020-05-16T20:46:04.000Z",
  "tags": [
    "Android",
    "Kotlin",
    "Mastodon",
    "Misskey"
  ],
  "bodyContent": "どうもこんばんわ。  \n少し前だけどニコ生で世話やきキツネの仙狐さん一挙放送見ました。かわいいいいいいいいいい  \n\n\n# 本題\nPlayStoreに出すかは考え中。  \n{%asset_img ss.png ss %}\n\nダークモードがちょっとかっこいい  \n{%asset_img ss_dark.png ss_dark %}\n\n2列になってるけど設定で減らせたり増やせたりできます。  \n時系列順になってるけど2列に出してるせいでなんか見ずらい気がする。(でも一列のクライアントいっぱいあるし・・・)\n\n# なんで作ったの？\nViewModel+LiveData（画面回転しても値を保持し続けてくれるやつ）でなんか一個作ろうとした。使わなかったけど。\n\n## なんで使わないの？\nArrayListがViewModelで使えない？`add()`しても増えない（そもそもArrayListをViewModelで使うのが間違い説がある）  \nあとLiveDataの通知は`add()`じゃこない。  \nしゃーないので（すでにデータクラスとか作っちゃった）ViewModel+LiveData抜きで作った。  \n**代わりに`onSaveInstanceState`で値を引き継ぐようにしたので倒しても大丈夫（再度APIを叩くことが無い）**\n\n# ダウンロード\nhttps://github.com/takusan23/KaisendonMk2/releases/tag/1.0  \nPlayストアは考え中。\n\n# ソースコード\nhttps://github.com/takusan23/KaisendonMk2\n\n# できること\n逆に言うとここに書いてなければできません。\n- MastodonとMisskeyを同時に見れる\n    - Mastodon\n        - ホーム/通知(ストリーミングのみ)/ローカル\n    - Misskey\n        - ホーム/通知(ストリーミングのみ)/ローカル\n    - 複数アカウント\n        - 私はMastodonとMisskeyそれぞれ一個ずつしか持ってないけどね。\n- ストリーミングAPI\n- 投稿\n    - 公開範囲\n    - カスタム絵文字一覧\n    - 端末の情報（キャリア名とか）\n- モバイルデータ通信のときは画像非表示\n    - 4GBしか使えないんや。このクライアントの目玉（のつもり）\n        - 今はずっとWi-Fi環境下だけど\n- ダークモード\n- カスタム絵文字、GIFカスタム絵文字\n- 投稿操作\n    - ふぁぼ、ブースト\n    - Misskeyはリアクション\n- タイムラインの背景変える機能\n- タイムラインのフォント変える機能\n- 突然のクラッシュ\n    - 複数のTLをまとめて時系列順に並べる処理で出てる。\n\n# できないこと\n- 画像投稿\n- 添付メディア表示もない\n- 時間指定投稿\n- アンケ\n- アカウント情報見る\n    - フォローも\n    - プロフィール編集もない\n- 通知はストリーミングのみ\n- できることに書いてない事はできない\n\n# やりたいこと\n- 添付メディア表示\n- プロフィール表示\n\n\n- あとは・・・他クライアントに任せた。\n    - モバイルデータ回線のとき画像を非表示にする機能が欲しかっただけなので\n\n# 使い方\n初回起動時は強制的にログイン画面が出ます。  \nログインできたら左下のレンチマーク押して**読み込むタイムラインの設定**を選ぶと\n- ホーム\n- 通知\n- ローカル\n\nから選べるので見たいタイムラインにチェックしてください。  \n\n複数ログインのときはレンチマーク押して**ログイン**を押して、ログインを済ませて、**読み込むタイムラインの設定**を選ぶと追加されてるので後は楽しんで。\n\n# 作るのに大変だったところとか\n## Twitterと違う点\n色んな所[(こことかわかりやすい)](https://blog.yukiya.me/2020/05/15/joinmastodon2020/)でまとめられてるのであんまり書かないけど\n\n| できること       | Twitter                                                   | Mastodon                                                                                                                               |\n|------------------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|\n| ブックマーク     | あるけどAPIがない                                         | 使ったこと無い(インスタンスが対応してない)                                                                                             |\n| アンケート       | あるけどAPIない（アンケ機能ついてから数年経ってる）       | APIもあるしAPI限定の複数投票許可がある                                                                                                 |\n| 本人認証         | 公式って一般で取れんの？                                  | 自分のホームページに指定したHTML貼り付けて、プロフィールの補足情報にリンク貼れば認証済みになる                                         |\n| リアルタイム更新 | FilterStream（いつまで使えるか不明）かTweetDeck           | WebSocketで利用可能                                                                                                                    |\n| APIの利用        | 審査を通る必要がある（垢がいつ消えるか怖い&電話番号必須） | Via芸できるよ（クライアントから作れる`/api/v1/apps`。鯖がいっぱいあるのでその都度アプリ(クライアント)を作る）                          |\n| お気に入り       | 他の人のお気に入り見れる                                  | 自分しか見れないのでブックマーク代わりにでも（**ただしふぁぼ通知は相手に行くのと投稿のお気に入り登録したユーザー一覧には表示される**） |\n\n## MastodonとMisskeyはAPIぜんぜん違う\n\nまあそれはそうだろって話（PleromaはMastodonと互換性が有るらしい？要検証）なんだけどMastodonにあってMisskeyに無いとかって結構有るからMastodonのがそのまま使えるわけじゃない。世の中のクライアント作ってる人すごいね\n\nついでにMisskeyのAPIは(多分)全てPOSTリクエストです。タイムラインの取得もPOSTです。投稿もPOSTです。何故かは知りませんが。\n\nOkHttp+Coroutineを使ったサンプル\n```kotlin\n// ユーザーエージェント\nprivate val USER_AGENT = \"KaisendonMk2;@takusan_23\"\n\n// application/json\nprivate val APPLICATON_JSON = \"application/json\".toMediaType()\n\nprivate fun baseTimeLineAPI(url: String, limit: Int = 100): Deferred<Response> =\n    GlobalScope.async {\n        val postData = JSONObject().apply {\n            put(\"limit\", limit)\n            put(\"i\", instanceToken.token)\n        }.toString().toRequestBody(APPLICATON_JSON)\n        val request = Request.Builder().apply {\n            url(\"https://misskey.m544.net/api/$url\")\n            header(\"User-Agent\", USER_AGENT)\n            post(postData)\n        }.build()\n        val okHttpClient = OkHttpClient()\n        val response = okHttpClient.newCall(request).execute()\n        return@async response\n    }\n```\nMisskeyのTL取得APIは💯件まで取れます。  \n\n## MisskeyAPIのドキュメントが\n`Misskey API`って調べて一番上に出てくるサイトを開いてAPIリファレンスを見ると、**アクセストークンの取得になんかアプリを登録しろ**って書いてあるんですが、この方法で大丈夫でした→ https://misskey.m544.net/docs/ja-JP/api  \nそもそもアプリを登録しろってやり方なんですが、自由に鯖が作れる（私は作ったこと無いけど）Mastodon/Misskeyの仕組みではまず無理ですね。\n\n## カスタム絵文字\n最近は~~ニコ動~~（**例のアレ**）でもPartyParrotブームが来たわけですが、MastodonやMisskeyにも動く絵文字（カスタム絵文字）があります。   \n文字の中に画像を入れるのってHTMLとかだと簡単そうでGIFにも対応できるんですが、今回はAndroidです。TextViewじゃ無理やろ。    \n世の中のクライアントがどの様にカスタム絵文字を描画してるのかわかりませんが、私はMarkdown表示ライブラリに画像を表示する機能があったのでそれを使っています。  \nMarkdown表示ライブラリ→ https://github.com/noties/Markwon\n\n```kotlin\n/**\n * カスタム絵文字にTextViewを対応させる\n * @param content 文字列\n * @param textView setText代わり\n * */\nfun setCustomEmoji(textView: TextView, content: String) {\n    // Markdownのライブラリ入れた\n    val markwon = Markwon.builder(textView.context)\n        .usePlugin(HtmlPlugin.create())\n        .usePlugin(ImagesPlugin.create(textView.context))\n        .usePlugin(GifPlugin.create())\n        .usePlugin(object : AbstractMarkwonPlugin() {\n            // 読み込み中は別のDrawableを表示する\n            override fun configureImages(builder: AsyncDrawableLoader.Builder) {\n                builder.placeholderDrawableProvider {\n                    // your custom placeholder drawable\n                    textView.context.getDrawable(R.drawable.ic_refresh_black_24dp)\n                }\n            }\n        }).build()\n    markwon.setMarkdown(textView, customEmojiReplaceText)\n}\n```\n\n## 自由にファイルアクセスできないこんな世の中でTypeface#createFromFile()\n~~ポイズン~~  \nフォント変更機能はほしいです。TextViewにもフォントファイルを適用する（ユーザーが自由に適用できる）機能あります。`Typeface#createFromFile()`って言うんですけどね。  \nこれ引数にUriは指定できません（多分）。`file://`から始まるパスである必要があります。  \nこのアプリではまずSAFでttfファイルを選んでもらって\n\n```kotlin\nval intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {\n    type = \"font/*\"\n}\nstartActivityForResult(intent, FONT_REQUEST_CODE)\n```\n\nアプリ固有ディレクトリにコピーして使います\n\n```kotlin\n// アプリ固有ディレクトリにコピー\nval uri = data?.data ?: return\nval file = File(\"${context?.getExternalFilesDir(null)}/font.ttf\")\nfile.createNewFile()\n// こぴー\nval byteArray = context?.contentResolver?.openInputStream(uri)?.readBytes()\nif (byteArray != null) {\n    file.writeBytes(byteArray)\n}\n```\n\nこれで`Typeface.createFromFile()`が使えます。\n\n## RecyclerViewで表示\nMastodonとMisskeyは別のデータクラスなのでRecyclerViewのAdapterにわたすときに考えないといけないんですよね。  \n今回はAdapterに渡すためのデータクラスを別に用意しました。\n\n```kotlin\n/**\n * RecyclerViewに渡すデータクラス\n * @param allTimeLineData 色つけたりするから；；\n * どっちか一個だけ入れろ↓。\n * @param statusData\n * @param notificationData\n * */\ndata class TimeLineItemData(\n    val allTimeLineData: AllTimeLineData,\n    val statusData: StatusData? = null, // null以外ならTL表示\n    val notificationData: NotificationData? = null,// null以外なら通知表示\n    val misskeyNoteData: MisskeyNoteData? = null, // null以外ならNote表示\n    val misskeyNotificationData: MisskeyNotificationData? = null // null以外なら通知表示\n) : Serializable\n```\nMastodonの投稿か通知かMisskeyの投稿か通知のどれかが入ることになってます。`AllTimeLineDataはCardViewの色情報が入ってます。`\n\nそれからRecyclerViewでレイアウトを複数用意する方法ですが`getItemViewType()`を使います。\n\nちょっと長いけど\n\n```kotlin\n// レイアウトの定数（onCreateViewHolder()で使う）\ncompanion object {\n    /** Mastodon トゥート */\n    val TOOT_LAYOUT = 0\n    /** Mastodon 通知 */\n    val NOTIFICATION_LAYOUT = 1\n    /** Mastodon ブースト */\n    val TOOT_BOOST_LAYOUT = 2\n    /** Misskey 投稿 */\n    val MISSKEY_NOTE_LAYOUT = 3\n    /** Misskey 通知 */\n    val MISSKEY_NOTIFICATION_LAYOUT = 4\n    /** Misskey Renote */\n    val MISSKEY_RENOTE_LAYOUT = 5\n}\noverride fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\n    // レイアウト分岐\n    val view = when (viewType) {\n        TOOT_BOOST_LAYOUT -> BoostViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_boost, parent, false))\n        TOOT_LAYOUT -> TootViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_timeline, parent, false))\n        NOTIFICATION_LAYOUT -> NotificationViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_notification, parent, false))\n        MISSKEY_NOTE_LAYOUT -> MisskeyNoteViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_note, parent, false))\n        MISSKEY_NOTIFICATION_LAYOUT -> MisskeyNotificationViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_notification, parent, false))\n        MISSKEY_RENOTE_LAYOUT -> MisskeyRenoteViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_renote, parent, false))\n        else -> TootViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_timeline, parent, false))\n    }\n    return view\n}\n// 通知と投稿で分岐させる\noverride fun getItemViewType(position: Int): Int {\n    return when {\n        // Mastodon\n        timeLineItemDataList[position].statusData != null && timeLineItemDataList[position].statusData!!.reblogStatusData != null -> TOOT_BOOST_LAYOUT\n        timeLineItemDataList[position].statusData != null -> TOOT_LAYOUT\n        timeLineItemDataList[position].notificationData != null -> NOTIFICATION_LAYOUT\n        // Misskey\n        timeLineItemDataList[position].misskeyNoteData != null && timeLineItemDataList[position].misskeyNoteData!!.renote != null -> MISSKEY_RENOTE_LAYOUT\n        timeLineItemDataList[position].misskeyNoteData != null -> MISSKEY_NOTE_LAYOUT\n        timeLineItemDataList[position].misskeyNotificationData != null -> MISSKEY_NOTIFICATION_LAYOUT\n        else -> TOOT_LAYOUT\n    }\n}\n```\n\n## データクラスで画面回転耐久\n~~これは別の記事で書きたい。~~書きました→ https://takusan23.github.io/Bibouroku/2020/05/17/画面回転しても尊厳損傷しないようにonSaveInstanceState使う/\n\n# 終わりに\nコルーチンいっぱいつかった。  \n`withContext(Dispatchers.IO)`って便利だね。括弧が減りそう。\n```kotlin\n// コルーチン\nGlobalScope.launch(Dispatchers.Main) {\n    // UIスレッドのコルーチン -> UIスレッドではないスレッドへ切り替え\n    val response = withContext(Dispatchers.IO) {\n        // インターネットから持ってくるなど\n    }\n    // 帰ってきたらUIスレッドに戻る\n}\n```",
  "bodyHtml": "<p>どうもこんばんわ。<br>\n少し前だけどニコ生で世話やきキツネの仙狐さん一挙放送見ました。かわいいいいいいいいいい</p>\n<h1>本題</h1>\n<p>PlayStoreに出すかは考え中。<br>\n{%asset_img ss.png ss %}</p>\n<p>ダークモードがちょっとかっこいい<br>\n{%asset_img ss_dark.png ss_dark %}</p>\n<p>2列になってるけど設定で減らせたり増やせたりできます。<br>\n時系列順になってるけど2列に出してるせいでなんか見ずらい気がする。(でも一列のクライアントいっぱいあるし・・・)</p>\n<h1>なんで作ったの？</h1>\n<p>ViewModel+LiveData（画面回転しても値を保持し続けてくれるやつ）でなんか一個作ろうとした。使わなかったけど。</p>\n<h2>なんで使わないの？</h2>\n<p>ArrayListがViewModelで使えない？<code>add()</code>しても増えない（そもそもArrayListをViewModelで使うのが間違い説がある）<br>\nあとLiveDataの通知は<code>add()</code>じゃこない。<br>\nしゃーないので（すでにデータクラスとか作っちゃった）ViewModel+LiveData抜きで作った。<br>\n<strong>代わりに<code>onSaveInstanceState</code>で値を引き継ぐようにしたので倒しても大丈夫（再度APIを叩くことが無い）</strong></p>\n<h1>ダウンロード</h1>\n<p>https://github.com/takusan23/KaisendonMk2/releases/tag/1.0<br>\nPlayストアは考え中。</p>\n<h1>ソースコード</h1>\n<p>https://github.com/takusan23/KaisendonMk2</p>\n<h1>できること</h1>\n<p>逆に言うとここに書いてなければできません。</p>\n<ul>\n<li>MastodonとMisskeyを同時に見れる\n<ul>\n<li>Mastodon\n<ul>\n<li>ホーム/通知(ストリーミングのみ)/ローカル</li>\n</ul>\n</li>\n<li>Misskey\n<ul>\n<li>ホーム/通知(ストリーミングのみ)/ローカル</li>\n</ul>\n</li>\n<li>複数アカウント\n<ul>\n<li>私はMastodonとMisskeyそれぞれ一個ずつしか持ってないけどね。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ストリーミングAPI</li>\n<li>投稿\n<ul>\n<li>公開範囲</li>\n<li>カスタム絵文字一覧</li>\n<li>端末の情報（キャリア名とか）</li>\n</ul>\n</li>\n<li>モバイルデータ通信のときは画像非表示\n<ul>\n<li>4GBしか使えないんや。このクライアントの目玉（のつもり）\n<ul>\n<li>今はずっとWi-Fi環境下だけど</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ダークモード</li>\n<li>カスタム絵文字、GIFカスタム絵文字</li>\n<li>投稿操作\n<ul>\n<li>ふぁぼ、ブースト</li>\n<li>Misskeyはリアクション</li>\n</ul>\n</li>\n<li>タイムラインの背景変える機能</li>\n<li>タイムラインのフォント変える機能</li>\n<li>突然のクラッシュ\n<ul>\n<li>複数のTLをまとめて時系列順に並べる処理で出てる。</li>\n</ul>\n</li>\n</ul>\n<h1>できないこと</h1>\n<ul>\n<li>画像投稿</li>\n<li>添付メディア表示もない</li>\n<li>時間指定投稿</li>\n<li>アンケ</li>\n<li>アカウント情報見る\n<ul>\n<li>フォローも</li>\n<li>プロフィール編集もない</li>\n</ul>\n</li>\n<li>通知はストリーミングのみ</li>\n<li>できることに書いてない事はできない</li>\n</ul>\n<h1>やりたいこと</h1>\n<ul>\n<li>\n<p>添付メディア表示</p>\n</li>\n<li>\n<p>プロフィール表示</p>\n</li>\n<li>\n<p>あとは・・・他クライアントに任せた。</p>\n<ul>\n<li>モバイルデータ回線のとき画像を非表示にする機能が欲しかっただけなので</li>\n</ul>\n</li>\n</ul>\n<h1>使い方</h1>\n<p>初回起動時は強制的にログイン画面が出ます。<br>\nログインできたら左下のレンチマーク押して<strong>読み込むタイムラインの設定</strong>を選ぶと</p>\n<ul>\n<li>ホーム</li>\n<li>通知</li>\n<li>ローカル</li>\n</ul>\n<p>から選べるので見たいタイムラインにチェックしてください。</p>\n<p>複数ログインのときはレンチマーク押して<strong>ログイン</strong>を押して、ログインを済ませて、<strong>読み込むタイムラインの設定</strong>を選ぶと追加されてるので後は楽しんで。</p>\n<h1>作るのに大変だったところとか</h1>\n<h2>Twitterと違う点</h2>\n<p>色んな所<a href=\"https://blog.yukiya.me/2020/05/15/joinmastodon2020/\">(こことかわかりやすい)</a>でまとめられてるのであんまり書かないけど</p>\n<table>\n<thead>\n<tr>\n<th>できること</th>\n<th>Twitter</th>\n<th>Mastodon</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ブックマーク</td>\n<td>あるけどAPIがない</td>\n<td>使ったこと無い(インスタンスが対応してない)</td>\n</tr>\n<tr>\n<td>アンケート</td>\n<td>あるけどAPIない（アンケ機能ついてから数年経ってる）</td>\n<td>APIもあるしAPI限定の複数投票許可がある</td>\n</tr>\n<tr>\n<td>本人認証</td>\n<td>公式って一般で取れんの？</td>\n<td>自分のホームページに指定したHTML貼り付けて、プロフィールの補足情報にリンク貼れば認証済みになる</td>\n</tr>\n<tr>\n<td>リアルタイム更新</td>\n<td>FilterStream（いつまで使えるか不明）かTweetDeck</td>\n<td>WebSocketで利用可能</td>\n</tr>\n<tr>\n<td>APIの利用</td>\n<td>審査を通る必要がある（垢がいつ消えるか怖い&amp;電話番号必須）</td>\n<td>Via芸できるよ（クライアントから作れる<code>/api/v1/apps</code>。鯖がいっぱいあるのでその都度アプリ(クライアント)を作る）</td>\n</tr>\n<tr>\n<td>お気に入り</td>\n<td>他の人のお気に入り見れる</td>\n<td>自分しか見れないのでブックマーク代わりにでも（<strong>ただしふぁぼ通知は相手に行くのと投稿のお気に入り登録したユーザー一覧には表示される</strong>）</td>\n</tr>\n</tbody>\n</table>\n<h2>MastodonとMisskeyはAPIぜんぜん違う</h2>\n<p>まあそれはそうだろって話（PleromaはMastodonと互換性が有るらしい？要検証）なんだけどMastodonにあってMisskeyに無いとかって結構有るからMastodonのがそのまま使えるわけじゃない。世の中のクライアント作ってる人すごいね</p>\n<p>ついでにMisskeyのAPIは(多分)全てPOSTリクエストです。タイムラインの取得もPOSTです。投稿もPOSTです。何故かは知りませんが。</p>\n<p>OkHttp+Coroutineを使ったサンプル</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// ユーザーエージェント</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> USER_AGENT = <span class=\"hljs-string\">\"KaisendonMk2;@takusan_23\"</span>\n\n<span class=\"hljs-comment\">// application/json</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> APPLICATON_JSON = <span class=\"hljs-string\">\"application/json\"</span>.toMediaType()\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">baseTimeLineAPI</span><span class=\"hljs-params\">(url: <span class=\"hljs-type\">String</span>, limit: <span class=\"hljs-type\">Int</span> = <span class=\"hljs-number\">100</span>)</span></span>: Deferred&lt;Response&gt; =\n    GlobalScope.async {\n        <span class=\"hljs-keyword\">val</span> postData = JSONObject().apply {\n            put(<span class=\"hljs-string\">\"limit\"</span>, limit)\n            put(<span class=\"hljs-string\">\"i\"</span>, instanceToken.token)\n        }.toString().toRequestBody(APPLICATON_JSON)\n        <span class=\"hljs-keyword\">val</span> request = Request.Builder().apply {\n            url(<span class=\"hljs-string\">\"https://misskey.m544.net/api/<span class=\"hljs-variable\">$url</span>\"</span>)\n            header(<span class=\"hljs-string\">\"User-Agent\"</span>, USER_AGENT)\n            post(postData)\n        }.build()\n        <span class=\"hljs-keyword\">val</span> okHttpClient = OkHttpClient()\n        <span class=\"hljs-keyword\">val</span> response = okHttpClient.newCall(request).execute()\n        <span class=\"hljs-keyword\">return</span><span class=\"hljs-symbol\">@async</span> response\n    }</code></pre><p>MisskeyのTL取得APIは💯件まで取れます。</p>\n<h2>MisskeyAPIのドキュメントが</h2>\n<p><code>Misskey API</code>って調べて一番上に出てくるサイトを開いてAPIリファレンスを見ると、<strong>アクセストークンの取得になんかアプリを登録しろ</strong>って書いてあるんですが、この方法で大丈夫でした→ https://misskey.m544.net/docs/ja-JP/api<br>\nそもそもアプリを登録しろってやり方なんですが、自由に鯖が作れる（私は作ったこと無いけど）Mastodon/Misskeyの仕組みではまず無理ですね。</p>\n<h2>カスタム絵文字</h2>\n<p>最近は<s>ニコ動</s>（<strong>例のアレ</strong>）でもPartyParrotブームが来たわけですが、MastodonやMisskeyにも動く絵文字（カスタム絵文字）があります。<br>\n文字の中に画像を入れるのってHTMLとかだと簡単そうでGIFにも対応できるんですが、今回はAndroidです。TextViewじゃ無理やろ。<br>\n世の中のクライアントがどの様にカスタム絵文字を描画してるのかわかりませんが、私はMarkdown表示ライブラリに画像を表示する機能があったのでそれを使っています。<br>\nMarkdown表示ライブラリ→ https://github.com/noties/Markwon</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">/**\n * カスタム絵文字にTextViewを対応させる\n * <span class=\"hljs-doctag\">@param</span> content 文字列\n * <span class=\"hljs-doctag\">@param</span> textView setText代わり\n * */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setCustomEmoji</span><span class=\"hljs-params\">(textView: <span class=\"hljs-type\">TextView</span>, content: <span class=\"hljs-type\">String</span>)</span></span> {\n    <span class=\"hljs-comment\">// Markdownのライブラリ入れた</span>\n    <span class=\"hljs-keyword\">val</span> markwon = Markwon.builder(textView.context)\n        .usePlugin(HtmlPlugin.create())\n        .usePlugin(ImagesPlugin.create(textView.context))\n        .usePlugin(GifPlugin.create())\n        .usePlugin(<span class=\"hljs-keyword\">object</span> : AbstractMarkwonPlugin() {\n            <span class=\"hljs-comment\">// 読み込み中は別のDrawableを表示する</span>\n            <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">configureImages</span><span class=\"hljs-params\">(builder: <span class=\"hljs-type\">AsyncDrawableLoader</span>.<span class=\"hljs-type\">Builder</span>)</span></span> {\n                builder.placeholderDrawableProvider {\n                    <span class=\"hljs-comment\">// your custom placeholder drawable</span>\n                    textView.context.getDrawable(R.drawable.ic_refresh_black_24dp)\n                }\n            }\n        }).build()\n    markwon.setMarkdown(textView, customEmojiReplaceText)\n}</code></pre><h2>自由にファイルアクセスできないこんな世の中でTypeface#createFromFile()</h2>\n<p><s>ポイズン</s><br>\nフォント変更機能はほしいです。TextViewにもフォントファイルを適用する（ユーザーが自由に適用できる）機能あります。<code>Typeface#createFromFile()</code>って言うんですけどね。<br>\nこれ引数にUriは指定できません（多分）。<code>file://</code>から始まるパスである必要があります。<br>\nこのアプリではまずSAFでttfファイルを選んでもらって</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {\n    type = <span class=\"hljs-string\">\"font/*\"</span>\n}\nstartActivityForResult(intent, FONT_REQUEST_CODE)</code></pre><p>アプリ固有ディレクトリにコピーして使います</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// アプリ固有ディレクトリにコピー</span>\n<span class=\"hljs-keyword\">val</span> uri = <span class=\"hljs-keyword\">data</span>?.<span class=\"hljs-keyword\">data</span> ?: <span class=\"hljs-keyword\">return</span>\n<span class=\"hljs-keyword\">val</span> file = File(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">${context?.getExternalFilesDir(null)}</span>/font.ttf\"</span>)\nfile.createNewFile()\n<span class=\"hljs-comment\">// こぴー</span>\n<span class=\"hljs-keyword\">val</span> byteArray = context?.contentResolver?.openInputStream(uri)?.readBytes()\n<span class=\"hljs-keyword\">if</span> (byteArray != <span class=\"hljs-literal\">null</span>) {\n    file.writeBytes(byteArray)\n}</code></pre><p>これで<code>Typeface.createFromFile()</code>が使えます。</p>\n<h2>RecyclerViewで表示</h2>\n<p>MastodonとMisskeyは別のデータクラスなのでRecyclerViewのAdapterにわたすときに考えないといけないんですよね。<br>\n今回はAdapterに渡すためのデータクラスを別に用意しました。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">/**\n * RecyclerViewに渡すデータクラス\n * <span class=\"hljs-doctag\">@param</span> allTimeLineData 色つけたりするから；；\n * どっちか一個だけ入れろ↓。\n * <span class=\"hljs-doctag\">@param</span> statusData\n * <span class=\"hljs-doctag\">@param</span> notificationData\n * */</span>\n<span class=\"hljs-keyword\">data</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TimeLineItemData</span></span>(\n    <span class=\"hljs-keyword\">val</span> allTimeLineData: AllTimeLineData,\n    <span class=\"hljs-keyword\">val</span> statusData: StatusData? = <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// null以外ならTL表示</span>\n    <span class=\"hljs-keyword\">val</span> notificationData: NotificationData? = <span class=\"hljs-literal\">null</span>,<span class=\"hljs-comment\">// null以外なら通知表示</span>\n    <span class=\"hljs-keyword\">val</span> misskeyNoteData: MisskeyNoteData? = <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// null以外ならNote表示</span>\n    <span class=\"hljs-keyword\">val</span> misskeyNotificationData: MisskeyNotificationData? = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// null以外なら通知表示</span>\n) : Serializable</code></pre><p>Mastodonの投稿か通知かMisskeyの投稿か通知のどれかが入ることになってます。<code>AllTimeLineDataはCardViewの色情報が入ってます。</code></p>\n<p>それからRecyclerViewでレイアウトを複数用意する方法ですが<code>getItemViewType()</code>を使います。</p>\n<p>ちょっと長いけど</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// レイアウトの定数（onCreateViewHolder()で使う）</span>\n<span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> {\n    <span class=\"hljs-comment\">/** Mastodon トゥート */</span>\n    <span class=\"hljs-keyword\">val</span> TOOT_LAYOUT = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-comment\">/** Mastodon 通知 */</span>\n    <span class=\"hljs-keyword\">val</span> NOTIFICATION_LAYOUT = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-comment\">/** Mastodon ブースト */</span>\n    <span class=\"hljs-keyword\">val</span> TOOT_BOOST_LAYOUT = <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-comment\">/** Misskey 投稿 */</span>\n    <span class=\"hljs-keyword\">val</span> MISSKEY_NOTE_LAYOUT = <span class=\"hljs-number\">3</span>\n    <span class=\"hljs-comment\">/** Misskey 通知 */</span>\n    <span class=\"hljs-keyword\">val</span> MISSKEY_NOTIFICATION_LAYOUT = <span class=\"hljs-number\">4</span>\n    <span class=\"hljs-comment\">/** Misskey Renote */</span>\n    <span class=\"hljs-keyword\">val</span> MISSKEY_RENOTE_LAYOUT = <span class=\"hljs-number\">5</span>\n}\n<span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreateViewHolder</span><span class=\"hljs-params\">(parent: <span class=\"hljs-type\">ViewGroup</span>, viewType: <span class=\"hljs-type\">Int</span>)</span></span>: RecyclerView.ViewHolder {\n    <span class=\"hljs-comment\">// レイアウト分岐</span>\n    <span class=\"hljs-keyword\">val</span> view = <span class=\"hljs-keyword\">when</span> (viewType) {\n        TOOT_BOOST_LAYOUT -&gt; BoostViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_boost, parent, <span class=\"hljs-literal\">false</span>))\n        TOOT_LAYOUT -&gt; TootViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_timeline, parent, <span class=\"hljs-literal\">false</span>))\n        NOTIFICATION_LAYOUT -&gt; NotificationViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_notification, parent, <span class=\"hljs-literal\">false</span>))\n        MISSKEY_NOTE_LAYOUT -&gt; MisskeyNoteViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_note, parent, <span class=\"hljs-literal\">false</span>))\n        MISSKEY_NOTIFICATION_LAYOUT -&gt; MisskeyNotificationViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_notification, parent, <span class=\"hljs-literal\">false</span>))\n        MISSKEY_RENOTE_LAYOUT -&gt; MisskeyRenoteViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_misskey_renote, parent, <span class=\"hljs-literal\">false</span>))\n        <span class=\"hljs-keyword\">else</span> -&gt; TootViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.adapter_timeline, parent, <span class=\"hljs-literal\">false</span>))\n    }\n    <span class=\"hljs-keyword\">return</span> view\n}\n<span class=\"hljs-comment\">// 通知と投稿で分岐させる</span>\n<span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getItemViewType</span><span class=\"hljs-params\">(position: <span class=\"hljs-type\">Int</span>)</span></span>: <span class=\"hljs-built_in\">Int</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">when</span> {\n        <span class=\"hljs-comment\">// Mastodon</span>\n        timeLineItemDataList[position].statusData != <span class=\"hljs-literal\">null</span> &amp;&amp; timeLineItemDataList[position].statusData!!.reblogStatusData != <span class=\"hljs-literal\">null</span> -&gt; TOOT_BOOST_LAYOUT\n        timeLineItemDataList[position].statusData != <span class=\"hljs-literal\">null</span> -&gt; TOOT_LAYOUT\n        timeLineItemDataList[position].notificationData != <span class=\"hljs-literal\">null</span> -&gt; NOTIFICATION_LAYOUT\n        <span class=\"hljs-comment\">// Misskey</span>\n        timeLineItemDataList[position].misskeyNoteData != <span class=\"hljs-literal\">null</span> &amp;&amp; timeLineItemDataList[position].misskeyNoteData!!.renote != <span class=\"hljs-literal\">null</span> -&gt; MISSKEY_RENOTE_LAYOUT\n        timeLineItemDataList[position].misskeyNoteData != <span class=\"hljs-literal\">null</span> -&gt; MISSKEY_NOTE_LAYOUT\n        timeLineItemDataList[position].misskeyNotificationData != <span class=\"hljs-literal\">null</span> -&gt; MISSKEY_NOTIFICATION_LAYOUT\n        <span class=\"hljs-keyword\">else</span> -&gt; TOOT_LAYOUT\n    }\n}</code></pre><h2>データクラスで画面回転耐久</h2>\n<p>~~これは別の記事で書きたい。~~書きました→ https://takusan23.github.io/Bibouroku/2020/05/17/画面回転しても尊厳損傷しないようにonSaveInstanceState使う/</p>\n<h1>終わりに</h1>\n<p>コルーチンいっぱいつかった。<br>\n<code>withContext(Dispatchers.IO)</code>って便利だね。括弧が減りそう。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// コルーチン</span>\nGlobalScope.launch(Dispatchers.Main) {\n    <span class=\"hljs-comment\">// UIスレッドのコルーチン -&gt; UIスレッドではないスレッドへ切り替え</span>\n    <span class=\"hljs-keyword\">val</span> response = withContext(Dispatchers.IO) {\n        <span class=\"hljs-comment\">// インターネットから持ってくるなど</span>\n    }\n    <span class=\"hljs-comment\">// 帰ってきたらUIスレッドに戻る</span>\n}</code></pre>",
  "dir": "contents/posts/json",
  "base": "MastodonとMisskey同時に見れるクライアント作った？.json",
  "ext": ".json",
  "sourceBase": "MastodonとMisskey同時に見れるクライアント作った？.md",
  "sourceExt": ".md"
}