{
  "title": "Android11からAsyncTask非推奨だしCoroutine使おう",
  "created_at": "2020-06-19T00:00:00.000Z",
  "tags": [
    "Android",
    "Android11",
    "Kotlin",
    "Coroutine"
  ],
  "bodyContent": "どうもこんばんわ。  \r\nOkHttpの非同期もコルーチンに対応できたので記事書く。\r\n\r\nあとあってるかは知りません。一応動くとは思いますが\r\n\r\n# ~~AsyncTask~~\r\n非推奨になりました。  \r\nOkHttpの非同期処理ばっか使ったせいでAsyncTaskあんま使わなかったですね。\r\n\r\n![Imgur](https://imgur.com/8YPfGeW.png)\r\n\r\n# 環境\r\n\r\n|なまえ|あたい|\r\n|---|---|\r\n|Android|11 Beta 1|\r\n|targetSdkVersion|30（Android 11）|\r\n|言語|Kotlin|\r\n\r\n# OkHttp+CoroutineでWebAPI使う\r\n\r\n今回はWebAPIに[ニコニコ動画のランキングRSS](https://dwango.github.io/niconico/genre_ranking/ranking_rss/)を使おうと思います。\r\n\r\n# ライブラリ入れる\r\n`app/build.gradle`を開いて、\r\n\r\n```gradle\r\ndependencies {\r\n    // okhttp\r\n    implementation(\"com.squareup.okhttp3:okhttp:4.7.2\")\r\n    // Coroutines\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4\"\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4\"\r\n}\r\n```\r\n\r\nOkHttpとCoroutineを入れます。\r\n\r\n# レイアウト\r\nTextView見切れた場合でもScrollView置いてるのでスクロールできます。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    tools:context=\".MainActivity\">\r\n\r\n    <ScrollView\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"match_parent\">\r\n\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"vertical\" >\r\n\r\n            <TextView\r\n                android:id=\"@+id/textview\"\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"match_parent\"\r\n                android:text=\"Hello World!\" />\r\n        </LinearLayout>\r\n    </ScrollView>\r\n\r\n</LinearLayout>\r\n```\r\n\r\n# まずOkHttpだけだとどうなの？\r\nAndroidはUIスレッドで通信できないのでOkHttpの非同期通信で\r\n\r\n```kotlin\r\nval request = Request.Builder().apply {\r\n    url(RANKING_RSS_URL)\r\n    addHeader(\"User-Agent\", \"@takusan_23\")\r\n    get()\r\n}.build()\r\nval okHttpClient = OkHttpClient()\r\nokHttpClient.newCall(request).enqueue(object : Callback {\r\n    override fun onFailure(call: Call, e: IOException) {\r\n        // 失敗時\r\n    }\r\n    override fun onResponse(call: Call, response: Response) {\r\n        if (response.isSuccessful) {\r\n            // 成功時\r\n            textview.text = response.body?.string()\r\n        } else {\r\n            // 失敗時\r\n        }\r\n    }\r\n})\r\n```\r\n\r\n括弧が多いね。  \r\n\r\n\r\n# GlobalScope#launch{ }\r\n\r\n`thread {  }`みたいに現在のスレッドに関係なく動くやつ（だと思います）。\r\n\r\n```kotlin\r\n// こるーちん\r\nGlobalScope.launch(Dispatchers.Main) {\r\n    // 取得前\r\n    Toast.makeText(this@MainActivity, \"取得するね\", Toast.LENGTH_SHORT).show()\r\n    // 取得\r\n    val rankingString = withContext(Dispatchers.IO) {\r\n        getRanking().await()\r\n    }\r\n    textview.text = rankingString\r\n}\r\n```\r\n\r\n`getRanking()`関数はこう\r\n\r\n```kotlin\r\n// ニコ動の例のアレランキングRSS\r\nval RANKING_RSS_URL = \"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&rss=2.0&lang=ja-jp\"\r\nprivate fun getRanking() = GlobalScope.async {\r\n    val request = Request.Builder().apply {\r\n        url(RANKING_RSS_URL)\r\n        addHeader(\"User-Agent\", \"@takusan_23\")\r\n        get()\r\n    }.build()\r\n    val okHttpClient = OkHttpClient()\r\n    try {\r\n        okHttpClient.newCall(request).execute().body?.string()\r\n    } catch (e: IOException) {\r\n        null\r\n    }\r\n}\r\n```\r\n\r\ntry/catch置いてる理由はタイムアウトすると落ちると思うからです。\r\n\r\n## （分かる範囲で）解説\r\n`Dispatchers.Main`はUI操作可能なコルーチンを作成しますよってことです。  \r\nでもUI操作できるスレッドでは通信ができないので、`withContext(Dispatchers.IO)`を利用して通信します。この中ではUI操作はできません。  \r\n通信が終わると`withContext`の後の処理が始まります。  \r\nまってこれ動いてるけどあってんの？\r\n\r\n# AsyncTaskを書き換えるならこんな感じ？\r\n\r\n```kotlin\r\nGlobalScope.launch {\r\n    // AsyncTaskのonPreExecute()でやる処理（読み込み中出すなど）はここに書く\r\n    withContext(Dispatchers.IO){\r\n        // AsyncTaskのdoInBackground()でやる処理（WebAPI叩くなど）はここに書く\r\n    }\r\n    // AsyncTaskのonPostExecute()でやる処理（WebAPIのレスポンス結果）はここに書く。\r\n}\r\n```\r\n\r\n# runBlocking { }\r\nこいつは`GlobalScope.launch { }`とは違い、現在のスレッドを止めます。**UIスレッドだろうと止めます。** ぶっちゃけどこで使えば良いのかよくわからん。\r\n\r\n```kotlin\r\n// 取得前\r\nToast.makeText(this@MainActivity, \"取得するね\", Toast.LENGTH_SHORT).show()\r\nval rankingString = runBlocking(Dispatchers.IO) {\r\n    getRanking().await()\r\n}\r\ntextview.text = rankingString\r\n```\r\n\r\n`getRanking()`関数はこう\r\n\r\n```kotlin\r\n// ニコ動の例のアレランキングRSS\r\nval RANKING_RSS_URL = \"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&rss=2.0&lang=ja-jp\"\r\nprivate fun getRanking() = GlobalScope.async {\r\n    val request = Request.Builder().apply {\r\n        url(RANKING_RSS_URL)\r\n        addHeader(\"User-Agent\", \"@takusan_23\")\r\n        get()\r\n    }.build()\r\n    val okHttpClient = OkHttpClient()\r\n    try {\r\n        okHttpClient.newCall(request).execute().body?.string()\r\n    } catch (e: IOException) {\r\n        null\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 本当にUIスレッド止めてるの？\r\n多分。Activity起動が遅くなってる気がする。  \r\n`GlobalScope.launch { }`の方は  \r\n**Activity表示→WebAPI叩く** みたいな感じだけど、\r\n\r\n`runBlocking { }`の方は  \r\n**WebAPI叩く→Activity表示** みたいな感じ。データ取得終わってからActivityを表示してますね。\r\n\r\n# おまけ OkHttpの非同期通信をコルーチンに対応させる\r\n`OkHttpのコルーチン`以外にも高階関数などでも使い回せると思います。頑張って作った高階関数もコルーチンに対応できます。\r\n\r\n参考にしました：https://medium.com/@star_zero/callback%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%82%82%E3%81%AE%E3%82%92coroutines%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B-9384dfa6ad77\r\n\r\n```kotlin\r\n/** ランキングRSS取得関数 */\r\nprivate suspend fun getRanking() = suspendCoroutine<String?> { suspendCoroutine ->\r\n    val request = Request.Builder().apply {\r\n        url(RANKING_RSS_URL)\r\n        addHeader(\"User-Agent\", \"@takusan_23\")\r\n        get()\r\n    }.build()\r\n    val okHttpClient = OkHttpClient()\r\n    okHttpClient.newCall(request).enqueue(object : Callback {\r\n        override fun onFailure(call: Call, e: IOException) {\r\n            suspendCoroutine.resumeWithException(e)\r\n        }\r\n        override fun onResponse(call: Call, response: Response) {\r\n            if (response.isSuccessful) {\r\n                suspendCoroutine.resume(response.body?.string())\r\n            } else {\r\n                suspendCoroutine.resume(null)\r\n            }\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n`suspendCoroutine`を使えばコールバックなコードでもコルーチンに対応できます。  \r\n\r\n使い方はこう\r\n\r\n```kotlin\r\n// こるーちん\r\nGlobalScope.launch(Dispatchers.Main) {\r\n    // 取得前\r\n    Toast.makeText(this@MainActivity, \"取得するね\", Toast.LENGTH_SHORT).show()\r\n    // 取得\r\n    val rankingString = withContext(Dispatchers.IO) {\r\n        getRanking()\r\n    }\r\n    textview.text = rankingString\r\n}\r\n```\r\n\r\n`suspend`ってのは中断って意味らしいですよ。\r\n\r\n# おわりに\r\nなんとなくでCoroutine触ってるけどやっぱりよくわからない。  \r\n\r\nあとOkHttp作ってるSquareってあのクレカ決済とかキャッシュレスの決済やってる会社？すごくね？",
  "bodyHtml": "<p>どうもこんばんわ。<br>\nOkHttpの非同期もコルーチンに対応できたので記事書く。</p>\n<p>あとあってるかは知りません。一応動くとは思いますが</p>\n<h1><s>AsyncTask</s></h1>\n<p>非推奨になりました。<br>\nOkHttpの非同期処理ばっか使ったせいでAsyncTaskあんま使わなかったですね。</p>\n<p><img src=\"https://imgur.com/8YPfGeW.png\" alt=\"Imgur\"></p>\n<h1>環境</h1>\n<table>\n<thead>\n<tr>\n<th>なまえ</th>\n<th>あたい</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Android</td>\n<td>11 Beta 1</td>\n</tr>\n<tr>\n<td>targetSdkVersion</td>\n<td>30（Android 11）</td>\n</tr>\n<tr>\n<td>言語</td>\n<td>Kotlin</td>\n</tr>\n</tbody>\n</table>\n<h1>OkHttp+CoroutineでWebAPI使う</h1>\n<p>今回はWebAPIに<a href=\"https://dwango.github.io/niconico/genre_ranking/ranking_rss/\">ニコニコ動画のランキングRSS</a>を使おうと思います。</p>\n<h1>ライブラリ入れる</h1>\n<p><code>app/build.gradle</code>を開いて、</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">dependencies</span> {\n    <span class=\"hljs-comment\">// okhttp</span>\n    implementation(<span class=\"hljs-string\">\"com.squareup.okhttp3:okhttp:4.7.2\"</span>)\n    <span class=\"hljs-comment\">// Coroutines</span>\n    implementation <span class=\"hljs-string\">\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4\"</span>\n    implementation <span class=\"hljs-string\">\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4\"</span>\n}</code></pre><p>OkHttpとCoroutineを入れます。</p>\n<h1>レイアウト</h1>\n<p>TextView見切れた場合でもScrollView置いてるのでスクロールできます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res/android\"</span>\n    <span class=\"hljs-attr\">xmlns:app</span>=<span class=\"hljs-string\">\"http://schemas.android.com/apk/res-auto\"</span>\n    <span class=\"hljs-attr\">xmlns:tools</span>=<span class=\"hljs-string\">\"http://schemas.android.com/tools\"</span>\n    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n    <span class=\"hljs-attr\">tools:context</span>=<span class=\"hljs-string\">\".MainActivity\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScrollView</span>\n        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"match_parent\"</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span>\n            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"wrap_content\"</span>\n            <span class=\"hljs-attr\">android:orientation</span>=<span class=\"hljs-string\">\"vertical\"</span> &gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span>\n                <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">\"@+id/textview\"</span>\n                <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n                <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">\"match_parent\"</span>\n                <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">\"Hello World!\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScrollView</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span></code></pre><h1>まずOkHttpだけだとどうなの？</h1>\n<p>AndroidはUIスレッドで通信できないのでOkHttpの非同期通信で</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">val</span> request = Request.Builder().apply {\n    url(RANKING_RSS_URL)\n    addHeader(<span class=\"hljs-string\">\"User-Agent\"</span>, <span class=\"hljs-string\">\"@takusan_23\"</span>)\n    <span class=\"hljs-keyword\">get</span>()\n}.build()\n<span class=\"hljs-keyword\">val</span> okHttpClient = OkHttpClient()\nokHttpClient.newCall(request).enqueue(<span class=\"hljs-keyword\">object</span> : Callback {\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onFailure</span><span class=\"hljs-params\">(call: <span class=\"hljs-type\">Call</span>, e: <span class=\"hljs-type\">IOException</span>)</span></span> {\n        <span class=\"hljs-comment\">// 失敗時</span>\n    }\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onResponse</span><span class=\"hljs-params\">(call: <span class=\"hljs-type\">Call</span>, response: <span class=\"hljs-type\">Response</span>)</span></span> {\n        <span class=\"hljs-keyword\">if</span> (response.isSuccessful) {\n            <span class=\"hljs-comment\">// 成功時</span>\n            textview.text = response.body?.string()\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 失敗時</span>\n        }\n    }\n})</code></pre><p>括弧が多いね。</p>\n<h1>GlobalScope#launch{ }</h1>\n<p><code>thread {  }</code>みたいに現在のスレッドに関係なく動くやつ（だと思います）。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// こるーちん</span>\nGlobalScope.launch(Dispatchers.Main) {\n    <span class=\"hljs-comment\">// 取得前</span>\n    Toast.makeText(<span class=\"hljs-keyword\">this</span><span class=\"hljs-symbol\">@MainActivity</span>, <span class=\"hljs-string\">\"取得するね\"</span>, Toast.LENGTH_SHORT).show()\n    <span class=\"hljs-comment\">// 取得</span>\n    <span class=\"hljs-keyword\">val</span> rankingString = withContext(Dispatchers.IO) {\n        getRanking().await()\n    }\n    textview.text = rankingString\n}</code></pre><p><code>getRanking()</code>関数はこう</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// ニコ動の例のアレランキングRSS</span>\n<span class=\"hljs-keyword\">val</span> RANKING_RSS_URL = <span class=\"hljs-string\">\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&amp;rss=2.0&amp;lang=ja-jp\"</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getRanking</span><span class=\"hljs-params\">()</span></span> = GlobalScope.async {\n    <span class=\"hljs-keyword\">val</span> request = Request.Builder().apply {\n        url(RANKING_RSS_URL)\n        addHeader(<span class=\"hljs-string\">\"User-Agent\"</span>, <span class=\"hljs-string\">\"@takusan_23\"</span>)\n        <span class=\"hljs-keyword\">get</span>()\n    }.build()\n    <span class=\"hljs-keyword\">val</span> okHttpClient = OkHttpClient()\n    <span class=\"hljs-keyword\">try</span> {\n        okHttpClient.newCall(request).execute().body?.string()\n    } <span class=\"hljs-keyword\">catch</span> (e: IOException) {\n        <span class=\"hljs-literal\">null</span>\n    }\n}</code></pre><p>try/catch置いてる理由はタイムアウトすると落ちると思うからです。</p>\n<h2>（分かる範囲で）解説</h2>\n<p><code>Dispatchers.Main</code>はUI操作可能なコルーチンを作成しますよってことです。<br>\nでもUI操作できるスレッドでは通信ができないので、<code>withContext(Dispatchers.IO)</code>を利用して通信します。この中ではUI操作はできません。<br>\n通信が終わると<code>withContext</code>の後の処理が始まります。<br>\nまってこれ動いてるけどあってんの？</p>\n<h1>AsyncTaskを書き換えるならこんな感じ？</h1>\n<pre><code class=\"hljs\">GlobalScope.launch {\n    <span class=\"hljs-comment\">// AsyncTaskのonPreExecute()でやる処理（読み込み中出すなど）はここに書く</span>\n    withContext(Dispatchers.IO){\n        <span class=\"hljs-comment\">// AsyncTaskのdoInBackground()でやる処理（WebAPI叩くなど）はここに書く</span>\n    }\n    <span class=\"hljs-comment\">// AsyncTaskのonPostExecute()でやる処理（WebAPIのレスポンス結果）はここに書く。</span>\n}</code></pre><h1>runBlocking { }</h1>\n<p>こいつは<code>GlobalScope.launch { }</code>とは違い、現在のスレッドを止めます。<strong>UIスレッドだろうと止めます。</strong> ぶっちゃけどこで使えば良いのかよくわからん。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// 取得前</span>\nToast.makeText(<span class=\"hljs-keyword\">this</span><span class=\"hljs-symbol\">@MainActivity</span>, <span class=\"hljs-string\">\"取得するね\"</span>, Toast.LENGTH_SHORT).show()\n<span class=\"hljs-keyword\">val</span> rankingString = runBlocking(Dispatchers.IO) {\n    getRanking().await()\n}\ntextview.text = rankingString</code></pre><p><code>getRanking()</code>関数はこう</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// ニコ動の例のアレランキングRSS</span>\n<span class=\"hljs-keyword\">val</span> RANKING_RSS_URL = <span class=\"hljs-string\">\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&amp;rss=2.0&amp;lang=ja-jp\"</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getRanking</span><span class=\"hljs-params\">()</span></span> = GlobalScope.async {\n    <span class=\"hljs-keyword\">val</span> request = Request.Builder().apply {\n        url(RANKING_RSS_URL)\n        addHeader(<span class=\"hljs-string\">\"User-Agent\"</span>, <span class=\"hljs-string\">\"@takusan_23\"</span>)\n        <span class=\"hljs-keyword\">get</span>()\n    }.build()\n    <span class=\"hljs-keyword\">val</span> okHttpClient = OkHttpClient()\n    <span class=\"hljs-keyword\">try</span> {\n        okHttpClient.newCall(request).execute().body?.string()\n    } <span class=\"hljs-keyword\">catch</span> (e: IOException) {\n        <span class=\"hljs-literal\">null</span>\n    }\n}</code></pre><h2>本当にUIスレッド止めてるの？</h2>\n<p>多分。Activity起動が遅くなってる気がする。<br>\n<code>GlobalScope.launch { }</code>の方は<br>\n<strong>Activity表示→WebAPI叩く</strong> みたいな感じだけど、</p>\n<p><code>runBlocking { }</code>の方は<br>\n<strong>WebAPI叩く→Activity表示</strong> みたいな感じ。データ取得終わってからActivityを表示してますね。</p>\n<h1>おまけ OkHttpの非同期通信をコルーチンに対応させる</h1>\n<p><code>OkHttpのコルーチン</code>以外にも高階関数などでも使い回せると思います。頑張って作った高階関数もコルーチンに対応できます。</p>\n<p>参考にしました：<a href=\"https://medium.com/@star_zero/callback%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%82%82%E3%81%AE%E3%82%92coroutines%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B-9384dfa6ad77\">https://medium.com/@star_zero/callback形式のものをcoroutinesに対応する-9384dfa6ad77</a></p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">/** ランキングRSS取得関数 */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getRanking</span><span class=\"hljs-params\">()</span></span> = suspendCoroutine&lt;String?&gt; { suspendCoroutine -&gt;\n    <span class=\"hljs-keyword\">val</span> request = Request.Builder().apply {\n        url(RANKING_RSS_URL)\n        addHeader(<span class=\"hljs-string\">\"User-Agent\"</span>, <span class=\"hljs-string\">\"@takusan_23\"</span>)\n        <span class=\"hljs-keyword\">get</span>()\n    }.build()\n    <span class=\"hljs-keyword\">val</span> okHttpClient = OkHttpClient()\n    okHttpClient.newCall(request).enqueue(<span class=\"hljs-keyword\">object</span> : Callback {\n        <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onFailure</span><span class=\"hljs-params\">(call: <span class=\"hljs-type\">Call</span>, e: <span class=\"hljs-type\">IOException</span>)</span></span> {\n            suspendCoroutine.resumeWithException(e)\n        }\n        <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onResponse</span><span class=\"hljs-params\">(call: <span class=\"hljs-type\">Call</span>, response: <span class=\"hljs-type\">Response</span>)</span></span> {\n            <span class=\"hljs-keyword\">if</span> (response.isSuccessful) {\n                suspendCoroutine.resume(response.body?.string())\n            } <span class=\"hljs-keyword\">else</span> {\n                suspendCoroutine.resume(<span class=\"hljs-literal\">null</span>)\n            }\n        }\n    })\n}</code></pre><p><code>suspendCoroutine</code>を使えばコールバックなコードでもコルーチンに対応できます。</p>\n<p>使い方はこう</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// こるーちん</span>\nGlobalScope.launch(Dispatchers.Main) {\n    <span class=\"hljs-comment\">// 取得前</span>\n    Toast.makeText(<span class=\"hljs-keyword\">this</span><span class=\"hljs-symbol\">@MainActivity</span>, <span class=\"hljs-string\">\"取得するね\"</span>, Toast.LENGTH_SHORT).show()\n    <span class=\"hljs-comment\">// 取得</span>\n    <span class=\"hljs-keyword\">val</span> rankingString = withContext(Dispatchers.IO) {\n        getRanking()\n    }\n    textview.text = rankingString\n}</code></pre><p><code>suspend</code>ってのは中断って意味らしいですよ。</p>\n<h1>おわりに</h1>\n<p>なんとなくでCoroutine触ってるけどやっぱりよくわからない。</p>\n<p>あとOkHttp作ってるSquareってあのクレカ決済とかキャッシュレスの決済やってる会社？すごくね？</p>\n",
  "dir": "contents/posts/json",
  "base": "android11_coroutine.json",
  "ext": ".json",
  "sourceBase": "android11_coroutine.md",
  "sourceExt": ".md"
}