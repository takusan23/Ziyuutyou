(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{582:function(n){n.exports=JSON.parse('{"fileMap":{"contents/posts/json/akashic_engine_pwa_cache.json":{"title":"データプラン弱者集合。PWAでオフラインに対応させる","created_at":"2020-06-27T00:00:00.000Z","tags":["JavaScript","PWA"],"dir":"contents/posts/json","base":"akashic_engine_pwa_cache.json","ext":".json","sourceBase":"akashic_engine_pwa_cache.md","sourceExt":".md"},"contents/posts/json/android11_coroutine.json":{"title":"Android11からAsyncTask非推奨だしCoroutine使おう","created_at":"2020-06-19T00:00:00.000Z","tags":["Android","Android11","Kotlin","Coroutine"],"dir":"contents/posts/json","base":"android11_coroutine.json","ext":".json","sourceBase":"android11_coroutine.md","sourceExt":".md"},"contents/posts/json/android11_devicecontrol.json":{"title":"Android 11 のデバイスコントロールAPIを試す","created_at":"2020-06-11T00:00:00.000Z","tags":["Android","Android11","Kotlin","Android R"],"dir":"contents/posts/json","base":"android11_devicecontrol.json","ext":".json","sourceBase":"android11_devicecontrol.md","sourceExt":".md"},"contents/posts/json/domain_katta.json":{"title":"Google Domainsでドメイン買ったからNetlifyで使う","created_at":"2020-06-15T00:00:00.000Z","tags":["Netlify","自作ブログ"],"dir":"contents/posts/json","base":"domain_katta.json","ext":".json","sourceBase":"domain_katta.md","sourceExt":".md"},"contents/posts/json/first.json":{"title":"Nuxt.jsとprocessmdでブログ作りたい。","created_at":"2020-05-30 21:10:00","tags":["NuxtJS","Markdown","JavaScript"],"dir":"contents/posts/json","base":"first.json","ext":".json","sourceBase":"first.md","sourceExt":".md"},"contents/posts/json/android11_statusbar_hide.json":{"title":"Hello Android 11。systemUiVisibility編","created_at":"2020-06-22T00:00:00.000Z","tags":["Android","Android11","Kotlin"],"dir":"contents/posts/json","base":"android11_statusbar_hide.json","ext":".json","sourceBase":"android11_statusbar_hide.md","sourceExt":".md"},"contents/posts/json/dotnet_wpf.json":{"title":".NET CoreでWPFアプリ作るぞ","created_at":"2020/06/09","tags":["CS","WPF",".NETCore"],"dir":"contents/posts/json","base":"dotnet_wpf.json","ext":".json","sourceBase":"dotnet_wpf.md","sourceExt":".md"},"contents/posts/json/nuxt_2_13_sugoi.json":{"title":"Nuxt.jsのFull Staticがすごい","created_at":"2020-06-27T00:00:00.000Z","tags":["NuxtJS","JavaScript","Vuetify"],"dir":"contents/posts/json","base":"nuxt_2_13_sugoi.json","ext":".json","sourceBase":"nuxt_2_13_sugoi.md","sourceExt":".md"},"contents/posts/json/taglist.json":{"title":"タグのページ作った","created_at":"2020-06-03T00:00:00.000Z","tags":["その他","NuxtJS","自作ブログ","JavaScript"],"dir":"contents/posts/json","base":"taglist.json","ext":".json","sourceBase":"taglist.md","sourceExt":".md"},"contents/posts/json/taihendattakoto.json":{"title":"これ作るのに大変だったこと","created_at":"2020-06-02T00:00:00.000Z","tags":["その他","自作ブログ"],"dir":"contents/posts/json","base":"taihendattakoto.json","ext":".json","sourceBase":"taihendattakoto.md","sourceExt":".md"},"contents/posts/json/mousecursor_wpf.json":{"title":"マウスカーソルの速度変えるアプリ作った","created_at":"2020/06/08","tags":["CS","WPF",".NETCore"],"dir":"contents/posts/json","base":"mousecursor_wpf.json","ext":".json","sourceBase":"mousecursor_wpf.md","sourceExt":".md"},"contents/posts/json/nuxt_link_hayai.json":{"title":"Nuxt.jsのプリフェッチがはやい","created_at":"2020-06-28T00:00:00.000Z","tags":["NuxtJS","JavaScript","Vuetify"],"dir":"contents/posts/json","base":"nuxt_link_hayai.json","ext":".json","sourceBase":"nuxt_link_hayai.md","sourceExt":".md"},"contents/posts/json/nuxt_universal.json":{"title":"Nuxtの静的サイトジェネレートはモードをuniversalにしよう","created_at":"2020-06-16T00:00:00.000Z","tags":["NuxtJS","JavaScript","自作ブログ"],"dir":"contents/posts/json","base":"nuxt_universal.json","ext":".json","sourceBase":"nuxt_universal.md","sourceExt":".md"},"contents/posts/json/usersmanual.json":{"title":"自作ブログ(Nuxt.js+processmd)の使い方","created_at":"2020-05-31 21:10:00","tags":["とりせつ","その他","Markdown","NuxtJS","自作ブログ","JavaScript"],"dir":"contents/posts/json","base":"usersmanual.json","ext":".json","sourceBase":"usersmanual.md","sourceExt":".md"}},"sourceFileArray":["contents/posts/markdown/akashic_engine_pwa_cache.md","contents/posts/markdown/android11_coroutine.md","contents/posts/markdown/android11_devicecontrol.md","contents/posts/markdown/android11_statusbar_hide.md","contents/posts/markdown/domain_katta.md","contents/posts/markdown/dotnet_wpf.md","contents/posts/markdown/first.md","contents/posts/markdown/mousecursor_wpf.md","contents/posts/markdown/nuxt_2_13_sugoi.md","contents/posts/markdown/nuxt_link_hayai.md","contents/posts/markdown/nuxt_universal.md","contents/posts/markdown/taglist.md","contents/posts/markdown/taihendattakoto.md","contents/posts/markdown/usersmanual.md"]}')},583:function(n,t,r){"use strict";var e={props:["tags"],data:function(){return{}},methods:{}},o=r(65),l=r(88),c=r.n(l),d=r(131),h=r(624),m=r(127),component=Object(o.a)(e,(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("client-only",n._l(n.tags,(function(t){return r("v-chip",{key:t,staticClass:"ma-1 pa-4",attrs:{color:"indigo","text-color":"white",to:"/posts/tag/"+t,nuxt:""}},[r("v-avatar",{attrs:{left:""}},[r("v-icon",[n._v("mdi-tag-text-outline")])],1),n._v("\n      "+n._s(t)+"\n    ")],1)})),1)],1)}),[],!1,null,null,null);t.a=component.exports;c()(component,{VAvatar:d.a,VChip:h.a,VIcon:m.a})},604:function(n,t,r){var map={"./akashic_engine_pwa_cache.json":605,"./android11_coroutine.json":606,"./android11_devicecontrol.json":607,"./android11_statusbar_hide.json":608,"./domain_katta.json":609,"./dotnet_wpf.json":610,"./first.json":611,"./mousecursor_wpf.json":612,"./nuxt_2_13_sugoi.json":613,"./nuxt_link_hayai.json":614,"./nuxt_universal.json":615,"./taglist.json":616,"./taihendattakoto.json":617,"./usersmanual.json":618};function e(n){var t=o(n);return r(t)}function o(n){if(!r.o(map,n)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return map[n]}e.keys=function(){return Object.keys(map)},e.resolve=o,n.exports=e,e.id=604},605:function(n){n.exports=JSON.parse('{"title":"データプラン弱者集合。PWAでオフラインに対応させる","created_at":"2020-06-27T00:00:00.000Z","tags":["JavaScript","PWA"],"bodyContent":"今月はあんまりモバイルデータ使ってないですね。\\r\\n\\r\\n# 本題\\r\\nPWAのキャッシュ機能でオフラインでも見れるサイトができたので書きたいと思います。  \\r\\n\\r\\n今回は**Akashic Engine**で作ったゲームをPWAに対応させてオフラインでも遊べるようにしたいと思います。  \\r\\n別にAkashic Engineじゃなくても良いですが\\r\\n\\r\\nちなみにこのサイトはnuxt.jsにPWA関係を任せているので特に何もせずに動いてます。\\r\\n\\r\\n\\r\\n*PWA+Cacheでモバイルデータを節約するぞ*\\r\\n\\r\\nPWAが何をするのかは各自で調べてください（え\\r\\n\\r\\n# 今回使うサイトは\\r\\n- ソースコード\\r\\n    - https://github.com/takusan23/AkashicEngine-FlappyBird\\r\\n- Netlifyに公開した完成品はこちら\\r\\n    - https://game-akashic-bird.negitoro.dev/\\r\\n    - PWAのインストールボタンが出てくるはず。\\r\\n\\r\\nこれ。前のブログのおまけで使ってたやつ[^1]\\r\\n\\r\\n# 用意するもの\\r\\n- PWA化したいサイトのソース\\r\\n    - htmlとか画像とかjsとかな\\r\\n- PWA化したときのアイコン\\r\\n    - 192x192の大きさと512x512の大きさが必要らしいです。\\r\\n- Webサーバー建てる拡張機能。別にこれ以外でも良い\\r\\n    - https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=ja\\r\\n- やる気。諦めないぞというお気持ち\\r\\n    - PWA厳しい\\r\\n- 今回はNetlifyで公開する\\r\\n    - GitHub Pagesだと話が変わってくると思う。\\r\\n\\r\\n# HTMLを用意する\\r\\nもうすでにhtmlを持ってる方は良いです。  \\r\\n今回私はAkashic EngineをHTML形式に書き出さないといけないので以下を実行\\r\\n\\r\\n```console\\r\\nakashic export html --bundle --magnify --minify --output export\\r\\n```\\r\\n\\r\\n`--minify`を指定して必要なファイルを極限まで減らします。\\r\\n\\r\\nこれでHTMLを用意できました。  \\r\\n![Imgur](https://imgur.com/f4QhGBO.png)\\r\\n\\r\\n**あとは生成されたHTMLファイルの`<title>`を書き換えて名前を変えましょう**\\r\\n\\r\\n# ServiceWorker\\r\\n~~Hello, Worker~~  \\r\\n\\r\\n## sw.jsを置く\\r\\nindex.htmlのあるところに`sw.js`を作成します。  \\r\\n中身はとりあえず空のままでいいです。\\r\\n\\r\\n## iconsフォルダを置く\\r\\n`sw.js`と同じ感じで同じ場所に`icons`フォルダを作成します。  \\r\\n中には、`192x192`の大きさのアイコン画像と`512x512`の大きさのアイコン画像を入れます。  \\r\\n名前はそれぞれ以下のようにします。\\r\\n- `icon_192.png`\\r\\n- `icon_512.png`\\r\\n\\r\\n## manifest.jsonを置く\\r\\n`sw.js`と同じ感じで同じ場所に`manifest.json`を作成します。  \\r\\nそして以下の内容を入れます\\r\\n\\r\\n```json\\r\\n{\\r\\n    \\"name\\": \\"Akashic Engine Flappy Bird\\",\\r\\n    \\"short_name\\": \\"Akashic Bird\\",\\r\\n    \\"icons\\": [\\r\\n        {\\r\\n            \\"src\\": \\"/icons/icon_192.png\\",\\r\\n            \\"sizes\\": \\"192x192\\",\\r\\n            \\"type\\": \\"image/png\\"\\r\\n        },\\r\\n        {\\r\\n            \\"src\\": \\"/icons/icon_512.png\\",\\r\\n            \\"sizes\\": \\"512x512\\",\\r\\n            \\"type\\": \\"image/png\\"\\r\\n        }\\r\\n    ],\\r\\n    \\"start_url\\": \\"/index.html\\",\\r\\n    \\"display\\": \\"standalone\\",\\r\\n    \\"background_color\\": \\"#FFFFFF\\",\\r\\n    \\"theme_color\\": \\"#FFFFFF\\"\\r\\n}\\r\\n```\\r\\n\\r\\n最低限、\\r\\n- `name`\\r\\n    - なまえ\\r\\n- `short_name`\\r\\n    - アプリ一覧で表示される名前\\r\\n\\r\\nを書き換えればいいと思います。\\r\\n\\r\\n## ServiceWorker登録\\r\\n`index.html`を開きます。  \\r\\n開いたら、head内に以下のように書きます。  \\r\\nよくわからない場合は`<title>`の下辺りに書いておけばいいと思います。\\r\\n\\r\\n```html\\r\\n\x3c!-- ウェブアプリマニフェストの読み込み --\x3e\\r\\n<link rel=\\"manifest\\" href=\\"manifest.json\\">\\r\\n\x3c!-- さーびすわーかー --\x3e\\r\\n<script>\\r\\n    if (\\"serviceWorker\\" in navigator) {\\r\\n        navigator.serviceWorker\\r\\n            .register(\\"sw.js\\")\\r\\n            .then(() => console.log(\\"registered service worker!\\"));\\r\\n    }\\r\\n<\/script>\\r\\n```\\r\\n\\r\\n# ここまででできたファイル\\r\\n`image`フォルダ以外はみんなあるよね？  \\r\\n![Imgur](https://imgur.com/ffmuHM6.png)\\r\\n\\r\\n# sw.jsを書く\\r\\nsw.js白紙だとインストールのためのバナー（ホーム画面に {アプリ名} を追加）すら出ない模様。  \\r\\n\\r\\n## キャッシュしなければいけないファイルを並べる\\r\\nここでファイル名を間違えるとキャッシュ取得諦めるのでちゃんと書きましょう。先生が生徒の名前間違えないようにするみたいな感じで\\r\\n\\r\\n```js\\r\\n// キャッシュしないといけないファイルを列挙する。間違えないように\\r\\nconst CACHE_LIST = [\\r\\n    \\"/icons/icon_192.png\\",\\r\\n    \\"/icons/icon_512.png\\",\\r\\n    \\"/image/play.png\\",\\r\\n    \\"/image/result.png\\",\\r\\n    \\"/image/title.png\\",\\r\\n    \\"/image/tori.png\\",\\r\\n    \\"index.html\\",\\r\\n    \\"manifest.json\\",\\r\\n    \\"/\\"\\r\\n]\\r\\n```\\r\\n\\r\\n## キャッシュに付ける名前\\r\\n多分識別に使うと思います。同じ名前だったら取得しない、名前が変わっていたら再度取り直すみたいな感じだと思います。  \\r\\n\\r\\nキャッシュ取得し直したい場合はここの値を変えることで再度取り直してくれます。\\r\\n\\r\\n```js\\r\\n// バージョンの名前。識別に使う\\r\\nconst VERSION_NAME = \'bird_20200627\' // ここの値が変わるとキャッシュを再登録するっぽい？\\r\\n```\\r\\n\\r\\n## `install` イベント\\r\\nコピペで行けると思います。\\r\\n```js\\r\\n// インストール時に\\r\\nself.addEventListener(\'install\', event => {\\r\\n    console.log(\'インストールするぞ\')\\r\\n    event.waitUntil(\\r\\n        caches.open(VERSION_NAME).then(cache => {\\r\\n            return cache.addAll(CACHE_LIST) // キャッシュ登録\\r\\n        }).catch(err => { console.log(err) }) // えらー\\r\\n    )\\r\\n})\\r\\n```\\r\\n\\r\\n## リクエスト横取り\\r\\nインターネットに画像リクエストしよー  \\r\\n↓  \\r\\nServiceWorkerが検知  \\r\\n↓  \\r\\nキャッシュがあればキャッシュを返す\\r\\n\\r\\nこれを書きます。\\r\\n\\r\\n```js\\r\\n// リクエストを横取りする\\r\\nself.addEventListener(\'fetch\', event => {\\r\\n    // キャッシュの内容に置き換える\\r\\n    event.respondWith(\\r\\n        caches.match(event.request).then(function (response) {\\r\\n            return response || fetch(event.request);\\r\\n        })\\r\\n    );\\r\\n})\\r\\n```\\r\\n\\r\\n## 古いキャッシュを消す\\r\\n**キャッシュに付ける名前**の項目で、キャッシュを再度取り直してくれますなど言いましたが、これ勝手には消してくれないので消してくれるコードです。\\r\\n\\r\\n```js\\r\\n// 古いキャッシュを消す。\\r\\nself.addEventListener(\'activate\', function (event) {\\r\\n    event.waitUntil(\\r\\n        caches.keys().then(function (cacheNames) {\\r\\n            return Promise.all(\\r\\n                cacheNames.filter(function (cacheName) {\\r\\n                    return cacheName !== VERSION_NAME;\\r\\n                }).map(function (cacheName) {\\r\\n                    return caches.delete(cacheName);\\r\\n                })\\r\\n            );\\r\\n        })\\r\\n    );\\r\\n});\\r\\n```\\r\\n\\r\\n# ここまでのsw.js\\r\\n\\r\\n```js\\r\\n// キャッシュしないといけないファイルを列挙する。間違えないように\\r\\nconst CACHE_LIST = [\\r\\n    \\"/icons/icon_192.png\\",\\r\\n    \\"/icons/icon_512.png\\",\\r\\n    \\"/image/play.png\\",\\r\\n    \\"/image/result.png\\",\\r\\n    \\"/image/title.png\\",\\r\\n    \\"/image/tori.png\\",\\r\\n    \\"index.html\\",\\r\\n    \\"manifest.json\\",\\r\\n    \\"/\\"\\r\\n]\\r\\n\\r\\n// バージョンの名前。識別に使う\\r\\nconst VERSION_NAME = \'bird_20200627\' // ここの値が変わるとキャッシュを再登録するっぽい？\\r\\n\\r\\n// インストール時に\\r\\nself.addEventListener(\'install\', event => {\\r\\n    console.log(\'インストールするぞ\')\\r\\n    event.waitUntil(\\r\\n        caches.open(VERSION_NAME).then(cache => {\\r\\n            return cache.addAll(CACHE_LIST) // キャッシュ登録\\r\\n        }).catch(err => { console.log(err) }) // えらー\\r\\n    )\\r\\n})\\r\\n\\r\\n// リクエストを横取りする\\r\\nself.addEventListener(\'fetch\', event => {\\r\\n    // キャッシュの内容に置き換える\\r\\n    event.respondWith(\\r\\n        caches.match(event.request).then(function (response) {\\r\\n            return response || fetch(event.request);\\r\\n        })\\r\\n    );\\r\\n})\\r\\n\\r\\n// 古いキャッシュを消す。\\r\\nself.addEventListener(\'activate\', function (event) {\\r\\n    event.waitUntil(\\r\\n        caches.keys().then(function (cacheNames) {\\r\\n            return Promise.all(\\r\\n                cacheNames.filter(function (cacheName) {\\r\\n                    return cacheName !== VERSION_NAME;\\r\\n                }).map(function (cacheName) {\\r\\n                    return caches.delete(cacheName);\\r\\n                })\\r\\n            );\\r\\n        })\\r\\n    );\\r\\n});\\r\\n```\\r\\n\\r\\n# Web Server for Chrome を開いて\\r\\n`CHOOSE FOLDER`を押して、`index.html`のあるフォルダを指定します。  \\r\\nそしたら`Web Server`のスイッチを押して起動させます。 \\r\\n\\r\\n起動できたら、`http://127.0.0.1`から始まるURLが`Web Server URL(s)`の下に表示されるので押します。するとWebページが表示されるようになるんですね～\\r\\n\\r\\nそしたらWebページを開いた状態で`F12`おして`Application`タブを押します。\\r\\n\\r\\nその中から`Cache Storage`を探して、キャッシュが取得できてるか確認しましょう。\\r\\n\\r\\n![Imgur](https://i.imgur.com/PWEuyxl.png)\\r\\n\\r\\nこのように登録されていれば完成です。おめ！\\r\\n\\r\\nちなみに：本当なら`index.html`をブラウザで開くだけで見れるわけですが、Service Workerを動かすためにはURLが `https`で始まるか`localhost（127.0.0.1）`で始まる必要があるようです。  \\r\\nだから**Web Server for Chrome**を利用する必要があったのですね。\\r\\n\\r\\n# 本当にオフラインで動くの？\\r\\n\\r\\n`Service Worker`を押して、`Offline`にチャックを入れます。  \\r\\n入れた後に再読み込みしても表示されている場合は動いてます。\\r\\n\\r\\n![Imgur](https://i.imgur.com/Bjjxnvm.png)\\r\\n\\r\\n# Netlifyで公開\\r\\nもう一回タイトル見てください。データプラン弱者がなんとかとか書いてあります。そうスマホで見れないと意味がないんですよ。\\r\\n\\r\\nというわけでNetlifyで公開します。  \\r\\nアカウントは各自作成してください。この記事に辿り着くってことはそれなりの知識があるはずです。  \\r\\n\\r\\n## Netlify Drop\\r\\nなんか`index.html`なんかが入ったフォルダをブラウザに投げるだけで公開できるらしい。\\r\\n\\r\\nというわけで`index.html sw.js manifest.json`もろもろ入ってるフォルダをNetlifyのサイトに投げましょう。この方法ならGitHubを経由すること無く公開できます。\\r\\n\\r\\n![Imgur](https://i.imgur.com/wCFDJiW.png)\\r\\n\\r\\n## Site Settings > Change site name からURLを変更\\r\\n`https:// {自由に決められる} .netlify.app`の自由に決められるの部分なら、自由に変更可能です。\\r\\n\\r\\n![Imgur](https://i.imgur.com/911F4E7.png)\\r\\n\\r\\n自分の持ってるドメインを設定する場合は前に書きました→ [Google Domainsでドメイン買った](/posts/domain_katta)\\r\\n\\r\\n以上です。  \\r\\n今回できたサイトはこちら。→ https://game-akashic-bird.negitoro.dev/\\r\\n# おわりに\\r\\nところで今の所通信制限かかったことは無いと思われ\\r\\n\\r\\n![Imgur](https://i.imgur.com/q8X1FOT.png)\\r\\n\\r\\n# 参考にしました\\r\\nhttps://qiita.com/masanarih0ri/items/0845f312cff5c8d0ec60  \\r\\nhttps://www.simicart.com/blog/pwa-offline/  \\r\\n\\r\\n[^1]:Nuxt.jsでHTML貼るのってどうすりゃいいんだ？","bodyHtml":"<p>今月はあんまりモバイルデータ使ってないですね。</p>\\n<h1>本題</h1>\\n<p>PWAのキャッシュ機能でオフラインでも見れるサイトができたので書きたいと思います。</p>\\n<p>今回は<strong>Akashic Engine</strong>で作ったゲームをPWAに対応させてオフラインでも遊べるようにしたいと思います。<br>\\n別にAkashic Engineじゃなくても良いですが</p>\\n<p>ちなみにこのサイトはnuxt.jsにPWA関係を任せているので特に何もせずに動いてます。</p>\\n<p><em>PWA+Cacheでモバイルデータを節約するぞ</em></p>\\n<p>PWAが何をするのかは各自で調べてください（え</p>\\n<h1>今回使うサイトは</h1>\\n<ul>\\n<li>ソースコード\\n<ul>\\n<li><a href=\\"https://github.com/takusan23/AkashicEngine-FlappyBird\\">https://github.com/takusan23/AkashicEngine-FlappyBird</a></li>\\n</ul>\\n</li>\\n<li>Netlifyに公開した完成品はこちら\\n<ul>\\n<li><a href=\\"https://game-akashic-bird.negitoro.dev/\\">https://game-akashic-bird.negitoro.dev/</a></li>\\n<li>PWAのインストールボタンが出てくるはず。</li>\\n</ul>\\n</li>\\n</ul>\\n<p>これ。前のブログのおまけで使ってたやつ<a href=\\"Nuxt.js%E3%81%A7HTML%E8%B2%BC%E3%82%8B%E3%81%AE%E3%81%A3%E3%81%A6%E3%81%A9%E3%81%86%E3%81%99%E3%82%8A%E3%82%83%E3%81%84%E3%81%84%E3%82%93%E3%81%A0%EF%BC%9F\\">^1</a></p>\\n<h1>用意するもの</h1>\\n<ul>\\n<li>PWA化したいサイトのソース\\n<ul>\\n<li>htmlとか画像とかjsとかな</li>\\n</ul>\\n</li>\\n<li>PWA化したときのアイコン\\n<ul>\\n<li>192x192の大きさと512x512の大きさが必要らしいです。</li>\\n</ul>\\n</li>\\n<li>Webサーバー建てる拡張機能。別にこれ以外でも良い\\n<ul>\\n<li><a href=\\"https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=ja\\">https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=ja</a></li>\\n</ul>\\n</li>\\n<li>やる気。諦めないぞというお気持ち\\n<ul>\\n<li>PWA厳しい</li>\\n</ul>\\n</li>\\n<li>今回はNetlifyで公開する\\n<ul>\\n<li>GitHub Pagesだと話が変わってくると思う。</li>\\n</ul>\\n</li>\\n</ul>\\n<h1>HTMLを用意する</h1>\\n<p>もうすでにhtmlを持ってる方は良いです。<br>\\n今回私はAkashic EngineをHTML形式に書き出さないといけないので以下を実行</p>\\n<pre><code class=\\"hljs\\">akashic export html --bundle --magnify --minify --output export</code></pre><p><code>--minify</code>を指定して必要なファイルを極限まで減らします。</p>\\n<p>これでHTMLを用意できました。<br>\\n<img src=\\"https://imgur.com/f4QhGBO.png\\" alt=\\"Imgur\\"></p>\\n<p><strong>あとは生成されたHTMLファイルの<code>&lt;title&gt;</code>を書き換えて名前を変えましょう</strong></p>\\n<h1>ServiceWorker</h1>\\n<p><s>Hello, Worker</s></p>\\n<h2>sw.jsを置く</h2>\\n<p>index.htmlのあるところに<code>sw.js</code>を作成します。<br>\\n中身はとりあえず空のままでいいです。</p>\\n<h2>iconsフォルダを置く</h2>\\n<p><code>sw.js</code>と同じ感じで同じ場所に<code>icons</code>フォルダを作成します。<br>\\n中には、<code>192x192</code>の大きさのアイコン画像と<code>512x512</code>の大きさのアイコン画像を入れます。<br>\\n名前はそれぞれ以下のようにします。</p>\\n<ul>\\n<li><code>icon_192.png</code></li>\\n<li><code>icon_512.png</code></li>\\n</ul>\\n<h2>manifest.jsonを置く</h2>\\n<p><code>sw.js</code>と同じ感じで同じ場所に<code>manifest.json</code>を作成します。<br>\\nそして以下の内容を入れます</p>\\n<pre><code class=\\"hljs\\">{\\n    <span class=\\"hljs-attr\\">\\"name\\"</span>: <span class=\\"hljs-string\\">\\"Akashic Engine Flappy Bird\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"short_name\\"</span>: <span class=\\"hljs-string\\">\\"Akashic Bird\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"icons\\"</span>: [\\n        {\\n            <span class=\\"hljs-attr\\">\\"src\\"</span>: <span class=\\"hljs-string\\">\\"/icons/icon_192.png\\"</span>,\\n            <span class=\\"hljs-attr\\">\\"sizes\\"</span>: <span class=\\"hljs-string\\">\\"192x192\\"</span>,\\n            <span class=\\"hljs-attr\\">\\"type\\"</span>: <span class=\\"hljs-string\\">\\"image/png\\"</span>\\n        },\\n        {\\n            <span class=\\"hljs-attr\\">\\"src\\"</span>: <span class=\\"hljs-string\\">\\"/icons/icon_512.png\\"</span>,\\n            <span class=\\"hljs-attr\\">\\"sizes\\"</span>: <span class=\\"hljs-string\\">\\"512x512\\"</span>,\\n            <span class=\\"hljs-attr\\">\\"type\\"</span>: <span class=\\"hljs-string\\">\\"image/png\\"</span>\\n        }\\n    ],\\n    <span class=\\"hljs-attr\\">\\"start_url\\"</span>: <span class=\\"hljs-string\\">\\"/index.html\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"display\\"</span>: <span class=\\"hljs-string\\">\\"standalone\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"background_color\\"</span>: <span class=\\"hljs-string\\">\\"#FFFFFF\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"theme_color\\"</span>: <span class=\\"hljs-string\\">\\"#FFFFFF\\"</span>\\n}</code></pre><p>最低限、</p>\\n<ul>\\n<li><code>name</code>\\n<ul>\\n<li>なまえ</li>\\n</ul>\\n</li>\\n<li><code>short_name</code>\\n<ul>\\n<li>アプリ一覧で表示される名前</li>\\n</ul>\\n</li>\\n</ul>\\n<p>を書き換えればいいと思います。</p>\\n<h2>ServiceWorker登録</h2>\\n<p><code>index.html</code>を開きます。<br>\\n開いたら、head内に以下のように書きます。<br>\\nよくわからない場合は<code>&lt;title&gt;</code>の下辺りに書いておけばいいと思います。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">&lt;!-- ウェブアプリマニフェストの読み込み --&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">link</span> <span class=\\"hljs-attr\\">rel</span>=<span class=\\"hljs-string\\">\\"manifest\\"</span> <span class=\\"hljs-attr\\">href</span>=<span class=\\"hljs-string\\">\\"manifest.json\\"</span>&gt;</span>\\n<span class=\\"hljs-comment\\">&lt;!-- さーびすわーかー --&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">script</span>&gt;</span><span class=\\"javascript\\">\\n    <span class=\\"hljs-keyword\\">if</span> (<span class=\\"hljs-string\\">\\"serviceWorker\\"</span> <span class=\\"hljs-keyword\\">in</span> navigator) {\\n        navigator.serviceWorker\\n            .register(<span class=\\"hljs-string\\">\\"sw.js\\"</span>)\\n            .then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\\"registered service worker!\\"</span>));\\n    }\\n</span><span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">script</span>&gt;</span></code></pre><h1>ここまででできたファイル</h1>\\n<p><code>image</code>フォルダ以外はみんなあるよね？<br>\\n<img src=\\"https://imgur.com/ffmuHM6.png\\" alt=\\"Imgur\\"></p>\\n<h1>sw.jsを書く</h1>\\n<p>sw.js白紙だとインストールのためのバナー（ホーム画面に {アプリ名} を追加）すら出ない模様。</p>\\n<h2>キャッシュしなければいけないファイルを並べる</h2>\\n<p>ここでファイル名を間違えるとキャッシュ取得諦めるのでちゃんと書きましょう。先生が生徒の名前間違えないようにするみたいな感じで</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// キャッシュしないといけないファイルを列挙する。間違えないように</span>\\n<span class=\\"hljs-keyword\\">const</span> CACHE_LIST = [\\n    <span class=\\"hljs-string\\">\\"/icons/icon_192.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/icons/icon_512.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/play.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/result.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/title.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/tori.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"index.html\\"</span>,\\n    <span class=\\"hljs-string\\">\\"manifest.json\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/\\"</span>\\n]</code></pre><h2>キャッシュに付ける名前</h2>\\n<p>多分識別に使うと思います。同じ名前だったら取得しない、名前が変わっていたら再度取り直すみたいな感じだと思います。</p>\\n<p>キャッシュ取得し直したい場合はここの値を変えることで再度取り直してくれます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// バージョンの名前。識別に使う</span>\\n<span class=\\"hljs-keyword\\">const</span> VERSION_NAME = <span class=\\"hljs-string\\">\'bird_20200627\'</span> <span class=\\"hljs-comment\\">// ここの値が変わるとキャッシュを再登録するっぽい？</span></code></pre><h2><code>install</code> イベント</h2>\\n<p>コピペで行けると思います。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// インストール時に</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'install\'</span>, event =&gt; {\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'インストールするぞ\'</span>)\\n    event.waitUntil(\\n        caches.open(VERSION_NAME).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">cache</span> =&gt;</span> {\\n            <span class=\\"hljs-keyword\\">return</span> cache.addAll(CACHE_LIST) <span class=\\"hljs-comment\\">// キャッシュ登録</span>\\n        }).catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> { <span class=\\"hljs-built_in\\">console</span>.log(err) }) <span class=\\"hljs-comment\\">// えらー</span>\\n    )\\n})</code></pre><h2>リクエスト横取り</h2>\\n<p>インターネットに画像リクエストしよー<br>\\n↓<br>\\nServiceWorkerが検知<br>\\n↓<br>\\nキャッシュがあればキャッシュを返す</p>\\n<p>これを書きます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// リクエストを横取りする</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'fetch\'</span>, event =&gt; {\\n    <span class=\\"hljs-comment\\">// キャッシュの内容に置き換える</span>\\n    event.respondWith(\\n        caches.match(event.request).then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">response</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> response || fetch(event.request);\\n        })\\n    );\\n})</code></pre><h2>古いキャッシュを消す</h2>\\n<p><strong>キャッシュに付ける名前</strong>の項目で、キャッシュを再度取り直してくれますなど言いましたが、これ勝手には消してくれないので消してくれるコードです。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// 古いキャッシュを消す。</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'activate\'</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">event</span>) </span>{\\n    event.waitUntil(\\n        caches.keys().then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheNames</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.all(\\n                cacheNames.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheName</span>) </span>{\\n                    <span class=\\"hljs-keyword\\">return</span> cacheName !== VERSION_NAME;\\n                }).map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheName</span>) </span>{\\n                    <span class=\\"hljs-keyword\\">return</span> caches.delete(cacheName);\\n                })\\n            );\\n        })\\n    );\\n});</code></pre><h1>ここまでのsw.js</h1>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// キャッシュしないといけないファイルを列挙する。間違えないように</span>\\n<span class=\\"hljs-keyword\\">const</span> CACHE_LIST = [\\n    <span class=\\"hljs-string\\">\\"/icons/icon_192.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/icons/icon_512.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/play.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/result.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/title.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/image/tori.png\\"</span>,\\n    <span class=\\"hljs-string\\">\\"index.html\\"</span>,\\n    <span class=\\"hljs-string\\">\\"manifest.json\\"</span>,\\n    <span class=\\"hljs-string\\">\\"/\\"</span>\\n]\\n\\n<span class=\\"hljs-comment\\">// バージョンの名前。識別に使う</span>\\n<span class=\\"hljs-keyword\\">const</span> VERSION_NAME = <span class=\\"hljs-string\\">\'bird_20200627\'</span> <span class=\\"hljs-comment\\">// ここの値が変わるとキャッシュを再登録するっぽい？</span>\\n\\n<span class=\\"hljs-comment\\">// インストール時に</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'install\'</span>, event =&gt; {\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">\'インストールするぞ\'</span>)\\n    event.waitUntil(\\n        caches.open(VERSION_NAME).then(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">cache</span> =&gt;</span> {\\n            <span class=\\"hljs-keyword\\">return</span> cache.addAll(CACHE_LIST) <span class=\\"hljs-comment\\">// キャッシュ登録</span>\\n        }).catch(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">err</span> =&gt;</span> { <span class=\\"hljs-built_in\\">console</span>.log(err) }) <span class=\\"hljs-comment\\">// えらー</span>\\n    )\\n})\\n\\n<span class=\\"hljs-comment\\">// リクエストを横取りする</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'fetch\'</span>, event =&gt; {\\n    <span class=\\"hljs-comment\\">// キャッシュの内容に置き換える</span>\\n    event.respondWith(\\n        caches.match(event.request).then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">response</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> response || fetch(event.request);\\n        })\\n    );\\n})\\n\\n<span class=\\"hljs-comment\\">// 古いキャッシュを消す。</span>\\nself.addEventListener(<span class=\\"hljs-string\\">\'activate\'</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">event</span>) </span>{\\n    event.waitUntil(\\n        caches.keys().then(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheNames</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Promise</span>.all(\\n                cacheNames.filter(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheName</span>) </span>{\\n                    <span class=\\"hljs-keyword\\">return</span> cacheName !== VERSION_NAME;\\n                }).map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cacheName</span>) </span>{\\n                    <span class=\\"hljs-keyword\\">return</span> caches.delete(cacheName);\\n                })\\n            );\\n        })\\n    );\\n});</code></pre><h1>Web Server for Chrome を開いて</h1>\\n<p><code>CHOOSE FOLDER</code>を押して、<code>index.html</code>のあるフォルダを指定します。<br>\\nそしたら<code>Web Server</code>のスイッチを押して起動させます。</p>\\n<p>起動できたら、<code>http://127.0.0.1</code>から始まるURLが<code>Web Server URL(s)</code>の下に表示されるので押します。するとWebページが表示されるようになるんですね～</p>\\n<p>そしたらWebページを開いた状態で<code>F12</code>おして<code>Application</code>タブを押します。</p>\\n<p>その中から<code>Cache Storage</code>を探して、キャッシュが取得できてるか確認しましょう。</p>\\n<p><img src=\\"https://i.imgur.com/PWEuyxl.png\\" alt=\\"Imgur\\"></p>\\n<p>このように登録されていれば完成です。おめ！</p>\\n<p>ちなみに：本当なら<code>index.html</code>をブラウザで開くだけで見れるわけですが、Service Workerを動かすためにはURLが <code>https</code>で始まるか<code>localhost（127.0.0.1）</code>で始まる必要があるようです。<br>\\nだから<strong>Web Server for Chrome</strong>を利用する必要があったのですね。</p>\\n<h1>本当にオフラインで動くの？</h1>\\n<p><code>Service Worker</code>を押して、<code>Offline</code>にチャックを入れます。<br>\\n入れた後に再読み込みしても表示されている場合は動いてます。</p>\\n<p><img src=\\"https://i.imgur.com/Bjjxnvm.png\\" alt=\\"Imgur\\"></p>\\n<h1>Netlifyで公開</h1>\\n<p>もう一回タイトル見てください。データプラン弱者がなんとかとか書いてあります。そうスマホで見れないと意味がないんですよ。</p>\\n<p>というわけでNetlifyで公開します。<br>\\nアカウントは各自作成してください。この記事に辿り着くってことはそれなりの知識があるはずです。</p>\\n<h2>Netlify Drop</h2>\\n<p>なんか<code>index.html</code>なんかが入ったフォルダをブラウザに投げるだけで公開できるらしい。</p>\\n<p>というわけで<code>index.html sw.js manifest.json</code>もろもろ入ってるフォルダをNetlifyのサイトに投げましょう。この方法ならGitHubを経由すること無く公開できます。</p>\\n<p><img src=\\"https://i.imgur.com/wCFDJiW.png\\" alt=\\"Imgur\\"></p>\\n<h2>Site Settings &gt; Change site name からURLを変更</h2>\\n<p><code>https:// {自由に決められる} .netlify.app</code>の自由に決められるの部分なら、自由に変更可能です。</p>\\n<p><img src=\\"https://i.imgur.com/911F4E7.png\\" alt=\\"Imgur\\"></p>\\n<p>自分の持ってるドメインを設定する場合は前に書きました→ <a href=\\"/posts/domain_katta\\">Google Domainsでドメイン買った</a></p>\\n<p>以上です。<br>\\n今回できたサイトはこちら。→ <a href=\\"https://game-akashic-bird.negitoro.dev/\\">https://game-akashic-bird.negitoro.dev/</a></p>\\n<h1>おわりに</h1>\\n<p>ところで今の所通信制限かかったことは無いと思われ</p>\\n<p><img src=\\"https://i.imgur.com/q8X1FOT.png\\" alt=\\"Imgur\\"></p>\\n<h1>参考にしました</h1>\\n<p><a href=\\"https://qiita.com/masanarih0ri/items/0845f312cff5c8d0ec60\\">https://qiita.com/masanarih0ri/items/0845f312cff5c8d0ec60</a><br>\\n<a href=\\"https://www.simicart.com/blog/pwa-offline/\\">https://www.simicart.com/blog/pwa-offline/</a></p>\\n","dir":"contents/posts/json","base":"akashic_engine_pwa_cache.json","ext":".json","sourceBase":"akashic_engine_pwa_cache.md","sourceExt":".md"}')},606:function(n){n.exports=JSON.parse('{"title":"Android11からAsyncTask非推奨だしCoroutine使おう","created_at":"2020-06-19T00:00:00.000Z","tags":["Android","Android11","Kotlin","Coroutine"],"bodyContent":"どうもこんばんわ。  \\r\\nOkHttpの非同期もコルーチンに対応できたので記事書く。\\r\\n\\r\\nあとあってるかは知りません。一応動くとは思いますが\\r\\n\\r\\n# ~~AsyncTask~~\\r\\n非推奨になりました。  \\r\\nOkHttpの非同期処理ばっか使ったせいでAsyncTaskあんま使わなかったですね。\\r\\n\\r\\n![Imgur](https://imgur.com/8YPfGeW.png)\\r\\n\\r\\n# 環境\\r\\n\\r\\n|なまえ|あたい|\\r\\n|---|---|\\r\\n|Android|11 Beta 1|\\r\\n|targetSdkVersion|30（Android 11）|\\r\\n|言語|Kotlin|\\r\\n\\r\\n# OkHttp+CoroutineでWebAPI使う\\r\\n\\r\\n今回はWebAPIに[ニコニコ動画のランキングRSS](https://dwango.github.io/niconico/genre_ranking/ranking_rss/)を使おうと思います。\\r\\n\\r\\n# ライブラリ入れる\\r\\n`app/build.gradle`を開いて、\\r\\n\\r\\n```gradle\\r\\ndependencies {\\r\\n    // okhttp\\r\\n    implementation(\\"com.squareup.okhttp3:okhttp:4.7.2\\")\\r\\n    // Coroutines\\r\\n    implementation \\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4\\"\\r\\n    implementation \\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4\\"\\r\\n}\\r\\n```\\r\\n\\r\\nOkHttpとCoroutineを入れます。\\r\\n\\r\\n# レイアウト\\r\\nTextView見切れた場合でもScrollView置いてるのでスクロールできます。\\r\\n\\r\\n```xml\\r\\n<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\r\\n<LinearLayout xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\r\\n    xmlns:app=\\"http://schemas.android.com/apk/res-auto\\"\\r\\n    xmlns:tools=\\"http://schemas.android.com/tools\\"\\r\\n    android:layout_width=\\"match_parent\\"\\r\\n    android:layout_height=\\"match_parent\\"\\r\\n    tools:context=\\".MainActivity\\">\\r\\n\\r\\n    <ScrollView\\r\\n        android:layout_width=\\"match_parent\\"\\r\\n        android:layout_height=\\"match_parent\\">\\r\\n\\r\\n        <LinearLayout\\r\\n            android:layout_width=\\"match_parent\\"\\r\\n            android:layout_height=\\"wrap_content\\"\\r\\n            android:orientation=\\"vertical\\" >\\r\\n\\r\\n            <TextView\\r\\n                android:id=\\"@+id/textview\\"\\r\\n                android:layout_width=\\"match_parent\\"\\r\\n                android:layout_height=\\"match_parent\\"\\r\\n                android:text=\\"Hello World!\\" />\\r\\n        </LinearLayout>\\r\\n    </ScrollView>\\r\\n\\r\\n</LinearLayout>\\r\\n```\\r\\n\\r\\n# まずOkHttpだけだとどうなの？\\r\\nAndroidはUIスレッドで通信できないのでOkHttpの非同期通信で\\r\\n\\r\\n```kotlin\\r\\nval request = Request.Builder().apply {\\r\\n    url(RANKING_RSS_URL)\\r\\n    addHeader(\\"User-Agent\\", \\"@takusan_23\\")\\r\\n    get()\\r\\n}.build()\\r\\nval okHttpClient = OkHttpClient()\\r\\nokHttpClient.newCall(request).enqueue(object : Callback {\\r\\n    override fun onFailure(call: Call, e: IOException) {\\r\\n        // 失敗時\\r\\n    }\\r\\n    override fun onResponse(call: Call, response: Response) {\\r\\n        if (response.isSuccessful) {\\r\\n            // 成功時\\r\\n            textview.text = response.body?.string()\\r\\n        } else {\\r\\n            // 失敗時\\r\\n        }\\r\\n    }\\r\\n})\\r\\n```\\r\\n\\r\\n括弧が多いね。  \\r\\n\\r\\n\\r\\n# GlobalScope#launch{ }\\r\\n\\r\\n`thread {  }`みたいに現在のスレッドに関係なく動くやつ（だと思います）。\\r\\n\\r\\n```kotlin\\r\\n// こるーちん\\r\\nGlobalScope.launch(Dispatchers.Main) {\\r\\n    // 取得前\\r\\n    Toast.makeText(this@MainActivity, \\"取得するね\\", Toast.LENGTH_SHORT).show()\\r\\n    // 取得\\r\\n    val rankingString = withContext(Dispatchers.IO) {\\r\\n        getRanking().await()\\r\\n    }\\r\\n    textview.text = rankingString\\r\\n}\\r\\n```\\r\\n\\r\\n`getRanking()`関数はこう\\r\\n\\r\\n```kotlin\\r\\n// ニコ動の例のアレランキングRSS\\r\\nval RANKING_RSS_URL = \\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&rss=2.0&lang=ja-jp\\"\\r\\nprivate fun getRanking() = GlobalScope.async {\\r\\n    val request = Request.Builder().apply {\\r\\n        url(RANKING_RSS_URL)\\r\\n        addHeader(\\"User-Agent\\", \\"@takusan_23\\")\\r\\n        get()\\r\\n    }.build()\\r\\n    val okHttpClient = OkHttpClient()\\r\\n    try {\\r\\n        okHttpClient.newCall(request).execute().body?.string()\\r\\n    } catch (e: IOException) {\\r\\n        null\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\ntry/catch置いてる理由はタイムアウトすると落ちると思うからです。\\r\\n\\r\\n## （分かる範囲で）解説\\r\\n`Dispatchers.Main`はUI操作可能なコルーチンを作成しますよってことです。  \\r\\nでもUI操作できるスレッドでは通信ができないので、`withContext(Dispatchers.IO)`を利用して通信します。この中ではUI操作はできません。  \\r\\n通信が終わると`withContext`の後の処理が始まります。  \\r\\nまってこれ動いてるけどあってんの？\\r\\n\\r\\n# AsyncTaskを書き換えるならこんな感じ？\\r\\n\\r\\n```kotlin\\r\\nGlobalScope.launch {\\r\\n    // AsyncTaskのonPreExecute()でやる処理（読み込み中出すなど）はここに書く\\r\\n    withContext(Dispatchers.IO){\\r\\n        // AsyncTaskのdoInBackground()でやる処理（WebAPI叩くなど）はここに書く\\r\\n    }\\r\\n    // AsyncTaskのonPostExecute()でやる処理（WebAPIのレスポンス結果）はここに書く。\\r\\n}\\r\\n```\\r\\n\\r\\n# runBlocking { }\\r\\nこいつは`GlobalScope.launch { }`とは違い、現在のスレッドを止めます。**UIスレッドだろうと止めます。** ぶっちゃけどこで使えば良いのかよくわからん。\\r\\n\\r\\n```kotlin\\r\\n// 取得前\\r\\nToast.makeText(this@MainActivity, \\"取得するね\\", Toast.LENGTH_SHORT).show()\\r\\nval rankingString = runBlocking(Dispatchers.IO) {\\r\\n    getRanking().await()\\r\\n}\\r\\ntextview.text = rankingString\\r\\n```\\r\\n\\r\\n`getRanking()`関数はこう\\r\\n\\r\\n```kotlin\\r\\n// ニコ動の例のアレランキングRSS\\r\\nval RANKING_RSS_URL = \\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&rss=2.0&lang=ja-jp\\"\\r\\nprivate fun getRanking() = GlobalScope.async {\\r\\n    val request = Request.Builder().apply {\\r\\n        url(RANKING_RSS_URL)\\r\\n        addHeader(\\"User-Agent\\", \\"@takusan_23\\")\\r\\n        get()\\r\\n    }.build()\\r\\n    val okHttpClient = OkHttpClient()\\r\\n    try {\\r\\n        okHttpClient.newCall(request).execute().body?.string()\\r\\n    } catch (e: IOException) {\\r\\n        null\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n## 本当にUIスレッド止めてるの？\\r\\n多分。Activity起動が遅くなってる気がする。  \\r\\n`GlobalScope.launch { }`の方は  \\r\\n**Activity表示→WebAPI叩く** みたいな感じだけど、\\r\\n\\r\\n`runBlocking { }`の方は  \\r\\n**WebAPI叩く→Activity表示** みたいな感じ。データ取得終わってからActivityを表示してますね。\\r\\n\\r\\n# おまけ OkHttpの非同期通信をコルーチンに対応させる\\r\\n`OkHttpのコルーチン`以外にも高階関数などでも使い回せると思います。頑張って作った高階関数もコルーチンに対応できます。\\r\\n\\r\\n参考にしました：https://medium.com/@star_zero/callback%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%82%82%E3%81%AE%E3%82%92coroutines%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B-9384dfa6ad77\\r\\n\\r\\n```kotlin\\r\\n/** ランキングRSS取得関数 */\\r\\nprivate suspend fun getRanking() = suspendCoroutine<String?> { suspendCoroutine ->\\r\\n    val request = Request.Builder().apply {\\r\\n        url(RANKING_RSS_URL)\\r\\n        addHeader(\\"User-Agent\\", \\"@takusan_23\\")\\r\\n        get()\\r\\n    }.build()\\r\\n    val okHttpClient = OkHttpClient()\\r\\n    okHttpClient.newCall(request).enqueue(object : Callback {\\r\\n        override fun onFailure(call: Call, e: IOException) {\\r\\n            suspendCoroutine.resumeWithException(e)\\r\\n        }\\r\\n        override fun onResponse(call: Call, response: Response) {\\r\\n            if (response.isSuccessful) {\\r\\n                suspendCoroutine.resume(response.body?.string())\\r\\n            } else {\\r\\n                suspendCoroutine.resume(null)\\r\\n            }\\r\\n        }\\r\\n    })\\r\\n}\\r\\n```\\r\\n\\r\\n`suspendCoroutine`を使えばコールバックなコードでもコルーチンに対応できます。  \\r\\n\\r\\n使い方はこう\\r\\n\\r\\n```kotlin\\r\\n// こるーちん\\r\\nGlobalScope.launch(Dispatchers.Main) {\\r\\n    // 取得前\\r\\n    Toast.makeText(this@MainActivity, \\"取得するね\\", Toast.LENGTH_SHORT).show()\\r\\n    // 取得\\r\\n    val rankingString = withContext(Dispatchers.IO) {\\r\\n        getRanking()\\r\\n    }\\r\\n    textview.text = rankingString\\r\\n}\\r\\n```\\r\\n\\r\\n`suspend`ってのは中断って意味らしいですよ。\\r\\n\\r\\n# おわりに\\r\\nなんとなくでCoroutine触ってるけどやっぱりよくわからない。  \\r\\n\\r\\nあとOkHttp作ってるSquareってあのクレカ決済とかキャッシュレスの決済やってる会社？すごくね？","bodyHtml":"<p>どうもこんばんわ。<br>\\nOkHttpの非同期もコルーチンに対応できたので記事書く。</p>\\n<p>あとあってるかは知りません。一応動くとは思いますが</p>\\n<h1><s>AsyncTask</s></h1>\\n<p>非推奨になりました。<br>\\nOkHttpの非同期処理ばっか使ったせいでAsyncTaskあんま使わなかったですね。</p>\\n<p><img src=\\"https://imgur.com/8YPfGeW.png\\" alt=\\"Imgur\\"></p>\\n<h1>環境</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>なまえ</th>\\n<th>あたい</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Android</td>\\n<td>11 Beta 1</td>\\n</tr>\\n<tr>\\n<td>targetSdkVersion</td>\\n<td>30（Android 11）</td>\\n</tr>\\n<tr>\\n<td>言語</td>\\n<td>Kotlin</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>OkHttp+CoroutineでWebAPI使う</h1>\\n<p>今回はWebAPIに<a href=\\"https://dwango.github.io/niconico/genre_ranking/ranking_rss/\\">ニコニコ動画のランキングRSS</a>を使おうと思います。</p>\\n<h1>ライブラリ入れる</h1>\\n<p><code>app/build.gradle</code>を開いて、</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">dependencies</span> {\\n    <span class=\\"hljs-comment\\">// okhttp</span>\\n    implementation(<span class=\\"hljs-string\\">\\"com.squareup.okhttp3:okhttp:4.7.2\\"</span>)\\n    <span class=\\"hljs-comment\\">// Coroutines</span>\\n    implementation <span class=\\"hljs-string\\">\\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.4\\"</span>\\n    implementation <span class=\\"hljs-string\\">\\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.4\\"</span>\\n}</code></pre><p>OkHttpとCoroutineを入れます。</p>\\n<h1>レイアウト</h1>\\n<p>TextView見切れた場合でもScrollView置いてるのでスクロールできます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-meta\\">&lt;?xml version=\\"1.0\\" encoding=\\"utf-8\\"?&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">LinearLayout</span> <span class=\\"hljs-attr\\">xmlns:android</span>=<span class=\\"hljs-string\\">\\"http://schemas.android.com/apk/res/android\\"</span>\\n    <span class=\\"hljs-attr\\">xmlns:app</span>=<span class=\\"hljs-string\\">\\"http://schemas.android.com/apk/res-auto\\"</span>\\n    <span class=\\"hljs-attr\\">xmlns:tools</span>=<span class=\\"hljs-string\\">\\"http://schemas.android.com/tools\\"</span>\\n    <span class=\\"hljs-attr\\">android:layout_width</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n    <span class=\\"hljs-attr\\">android:layout_height</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n    <span class=\\"hljs-attr\\">tools:context</span>=<span class=\\"hljs-string\\">\\".MainActivity\\"</span>&gt;</span>\\n\\n    <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">ScrollView</span>\\n        <span class=\\"hljs-attr\\">android:layout_width</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n        <span class=\\"hljs-attr\\">android:layout_height</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>&gt;</span>\\n\\n        <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">LinearLayout</span>\\n            <span class=\\"hljs-attr\\">android:layout_width</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n            <span class=\\"hljs-attr\\">android:layout_height</span>=<span class=\\"hljs-string\\">\\"wrap_content\\"</span>\\n            <span class=\\"hljs-attr\\">android:orientation</span>=<span class=\\"hljs-string\\">\\"vertical\\"</span> &gt;</span>\\n\\n            <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">TextView</span>\\n                <span class=\\"hljs-attr\\">android:id</span>=<span class=\\"hljs-string\\">\\"@+id/textview\\"</span>\\n                <span class=\\"hljs-attr\\">android:layout_width</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n                <span class=\\"hljs-attr\\">android:layout_height</span>=<span class=\\"hljs-string\\">\\"match_parent\\"</span>\\n                <span class=\\"hljs-attr\\">android:text</span>=<span class=\\"hljs-string\\">\\"Hello World!\\"</span> /&gt;</span>\\n        <span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">LinearLayout</span>&gt;</span>\\n    <span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">ScrollView</span>&gt;</span>\\n\\n<span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">LinearLayout</span>&gt;</span></code></pre><h1>まずOkHttpだけだとどうなの？</h1>\\n<p>AndroidはUIスレッドで通信できないのでOkHttpの非同期通信で</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">val</span> request = Request.Builder().apply {\\n    url(RANKING_RSS_URL)\\n    addHeader(<span class=\\"hljs-string\\">\\"User-Agent\\"</span>, <span class=\\"hljs-string\\">\\"@takusan_23\\"</span>)\\n    <span class=\\"hljs-keyword\\">get</span>()\\n}.build()\\n<span class=\\"hljs-keyword\\">val</span> okHttpClient = OkHttpClient()\\nokHttpClient.newCall(request).enqueue(<span class=\\"hljs-keyword\\">object</span> : Callback {\\n    <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">onFailure</span><span class=\\"hljs-params\\">(call: <span class=\\"hljs-type\\">Call</span>, e: <span class=\\"hljs-type\\">IOException</span>)</span></span> {\\n        <span class=\\"hljs-comment\\">// 失敗時</span>\\n    }\\n    <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">onResponse</span><span class=\\"hljs-params\\">(call: <span class=\\"hljs-type\\">Call</span>, response: <span class=\\"hljs-type\\">Response</span>)</span></span> {\\n        <span class=\\"hljs-keyword\\">if</span> (response.isSuccessful) {\\n            <span class=\\"hljs-comment\\">// 成功時</span>\\n            textview.text = response.body?.string()\\n        } <span class=\\"hljs-keyword\\">else</span> {\\n            <span class=\\"hljs-comment\\">// 失敗時</span>\\n        }\\n    }\\n})</code></pre><p>括弧が多いね。</p>\\n<h1>GlobalScope#launch{ }</h1>\\n<p><code>thread {  }</code>みたいに現在のスレッドに関係なく動くやつ（だと思います）。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// こるーちん</span>\\nGlobalScope.launch(Dispatchers.Main) {\\n    <span class=\\"hljs-comment\\">// 取得前</span>\\n    Toast.makeText(<span class=\\"hljs-keyword\\">this</span><span class=\\"hljs-symbol\\">@MainActivity</span>, <span class=\\"hljs-string\\">\\"取得するね\\"</span>, Toast.LENGTH_SHORT).show()\\n    <span class=\\"hljs-comment\\">// 取得</span>\\n    <span class=\\"hljs-keyword\\">val</span> rankingString = withContext(Dispatchers.IO) {\\n        getRanking().await()\\n    }\\n    textview.text = rankingString\\n}</code></pre><p><code>getRanking()</code>関数はこう</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// ニコ動の例のアレランキングRSS</span>\\n<span class=\\"hljs-keyword\\">val</span> RANKING_RSS_URL = <span class=\\"hljs-string\\">\\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&amp;rss=2.0&amp;lang=ja-jp\\"</span>\\n<span class=\\"hljs-keyword\\">private</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">getRanking</span><span class=\\"hljs-params\\">()</span></span> = GlobalScope.async {\\n    <span class=\\"hljs-keyword\\">val</span> request = Request.Builder().apply {\\n        url(RANKING_RSS_URL)\\n        addHeader(<span class=\\"hljs-string\\">\\"User-Agent\\"</span>, <span class=\\"hljs-string\\">\\"@takusan_23\\"</span>)\\n        <span class=\\"hljs-keyword\\">get</span>()\\n    }.build()\\n    <span class=\\"hljs-keyword\\">val</span> okHttpClient = OkHttpClient()\\n    <span class=\\"hljs-keyword\\">try</span> {\\n        okHttpClient.newCall(request).execute().body?.string()\\n    } <span class=\\"hljs-keyword\\">catch</span> (e: IOException) {\\n        <span class=\\"hljs-literal\\">null</span>\\n    }\\n}</code></pre><p>try/catch置いてる理由はタイムアウトすると落ちると思うからです。</p>\\n<h2>（分かる範囲で）解説</h2>\\n<p><code>Dispatchers.Main</code>はUI操作可能なコルーチンを作成しますよってことです。<br>\\nでもUI操作できるスレッドでは通信ができないので、<code>withContext(Dispatchers.IO)</code>を利用して通信します。この中ではUI操作はできません。<br>\\n通信が終わると<code>withContext</code>の後の処理が始まります。<br>\\nまってこれ動いてるけどあってんの？</p>\\n<h1>AsyncTaskを書き換えるならこんな感じ？</h1>\\n<pre><code class=\\"hljs\\">GlobalScope.launch {\\n    <span class=\\"hljs-comment\\">// AsyncTaskのonPreExecute()でやる処理（読み込み中出すなど）はここに書く</span>\\n    withContext(Dispatchers.IO){\\n        <span class=\\"hljs-comment\\">// AsyncTaskのdoInBackground()でやる処理（WebAPI叩くなど）はここに書く</span>\\n    }\\n    <span class=\\"hljs-comment\\">// AsyncTaskのonPostExecute()でやる処理（WebAPIのレスポンス結果）はここに書く。</span>\\n}</code></pre><h1>runBlocking { }</h1>\\n<p>こいつは<code>GlobalScope.launch { }</code>とは違い、現在のスレッドを止めます。<strong>UIスレッドだろうと止めます。</strong> ぶっちゃけどこで使えば良いのかよくわからん。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// 取得前</span>\\nToast.makeText(<span class=\\"hljs-keyword\\">this</span><span class=\\"hljs-symbol\\">@MainActivity</span>, <span class=\\"hljs-string\\">\\"取得するね\\"</span>, Toast.LENGTH_SHORT).show()\\n<span class=\\"hljs-keyword\\">val</span> rankingString = runBlocking(Dispatchers.IO) {\\n    getRanking().await()\\n}\\ntextview.text = rankingString</code></pre><p><code>getRanking()</code>関数はこう</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// ニコ動の例のアレランキングRSS</span>\\n<span class=\\"hljs-keyword\\">val</span> RANKING_RSS_URL = <span class=\\"hljs-string\\">\\"https://www.nicovideo.jp/ranking/genre/other?video_ranking_menu&amp;rss=2.0&amp;lang=ja-jp\\"</span>\\n<span class=\\"hljs-keyword\\">private</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">getRanking</span><span class=\\"hljs-params\\">()</span></span> = GlobalScope.async {\\n    <span class=\\"hljs-keyword\\">val</span> request = Request.Builder().apply {\\n        url(RANKING_RSS_URL)\\n        addHeader(<span class=\\"hljs-string\\">\\"User-Agent\\"</span>, <span class=\\"hljs-string\\">\\"@takusan_23\\"</span>)\\n        <span class=\\"hljs-keyword\\">get</span>()\\n    }.build()\\n    <span class=\\"hljs-keyword\\">val</span> okHttpClient = OkHttpClient()\\n    <span class=\\"hljs-keyword\\">try</span> {\\n        okHttpClient.newCall(request).execute().body?.string()\\n    } <span class=\\"hljs-keyword\\">catch</span> (e: IOException) {\\n        <span class=\\"hljs-literal\\">null</span>\\n    }\\n}</code></pre><h2>本当にUIスレッド止めてるの？</h2>\\n<p>多分。Activity起動が遅くなってる気がする。<br>\\n<code>GlobalScope.launch { }</code>の方は<br>\\n<strong>Activity表示→WebAPI叩く</strong> みたいな感じだけど、</p>\\n<p><code>runBlocking { }</code>の方は<br>\\n<strong>WebAPI叩く→Activity表示</strong> みたいな感じ。データ取得終わってからActivityを表示してますね。</p>\\n<h1>おまけ OkHttpの非同期通信をコルーチンに対応させる</h1>\\n<p><code>OkHttpのコルーチン</code>以外にも高階関数などでも使い回せると思います。頑張って作った高階関数もコルーチンに対応できます。</p>\\n<p>参考にしました：<a href=\\"https://medium.com/@star_zero/callback%E5%BD%A2%E5%BC%8F%E3%81%AE%E3%82%82%E3%81%AE%E3%82%92coroutines%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B-9384dfa6ad77\\">https://medium.com/@star_zero/callback形式のものをcoroutinesに対応する-9384dfa6ad77</a></p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/** ランキングRSS取得関数 */</span>\\n<span class=\\"hljs-keyword\\">private</span> <span class=\\"hljs-keyword\\">suspend</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">getRanking</span><span class=\\"hljs-params\\">()</span></span> = suspendCoroutine&lt;String?&gt; { suspendCoroutine -&gt;\\n    <span class=\\"hljs-keyword\\">val</span> request = Request.Builder().apply {\\n        url(RANKING_RSS_URL)\\n        addHeader(<span class=\\"hljs-string\\">\\"User-Agent\\"</span>, <span class=\\"hljs-string\\">\\"@takusan_23\\"</span>)\\n        <span class=\\"hljs-keyword\\">get</span>()\\n    }.build()\\n    <span class=\\"hljs-keyword\\">val</span> okHttpClient = OkHttpClient()\\n    okHttpClient.newCall(request).enqueue(<span class=\\"hljs-keyword\\">object</span> : Callback {\\n        <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">onFailure</span><span class=\\"hljs-params\\">(call: <span class=\\"hljs-type\\">Call</span>, e: <span class=\\"hljs-type\\">IOException</span>)</span></span> {\\n            suspendCoroutine.resumeWithException(e)\\n        }\\n        <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">onResponse</span><span class=\\"hljs-params\\">(call: <span class=\\"hljs-type\\">Call</span>, response: <span class=\\"hljs-type\\">Response</span>)</span></span> {\\n            <span class=\\"hljs-keyword\\">if</span> (response.isSuccessful) {\\n                suspendCoroutine.resume(response.body?.string())\\n            } <span class=\\"hljs-keyword\\">else</span> {\\n                suspendCoroutine.resume(<span class=\\"hljs-literal\\">null</span>)\\n            }\\n        }\\n    })\\n}</code></pre><p><code>suspendCoroutine</code>を使えばコールバックなコードでもコルーチンに対応できます。</p>\\n<p>使い方はこう</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// こるーちん</span>\\nGlobalScope.launch(Dispatchers.Main) {\\n    <span class=\\"hljs-comment\\">// 取得前</span>\\n    Toast.makeText(<span class=\\"hljs-keyword\\">this</span><span class=\\"hljs-symbol\\">@MainActivity</span>, <span class=\\"hljs-string\\">\\"取得するね\\"</span>, Toast.LENGTH_SHORT).show()\\n    <span class=\\"hljs-comment\\">// 取得</span>\\n    <span class=\\"hljs-keyword\\">val</span> rankingString = withContext(Dispatchers.IO) {\\n        getRanking()\\n    }\\n    textview.text = rankingString\\n}</code></pre><p><code>suspend</code>ってのは中断って意味らしいですよ。</p>\\n<h1>おわりに</h1>\\n<p>なんとなくでCoroutine触ってるけどやっぱりよくわからない。</p>\\n<p>あとOkHttp作ってるSquareってあのクレカ決済とかキャッシュレスの決済やってる会社？すごくね？</p>\\n","dir":"contents/posts/json","base":"android11_coroutine.json","ext":".json","sourceBase":"android11_coroutine.md","sourceExt":".md"}')},607:function(n){n.exports=JSON.parse('{"title":"Android 11 のデバイスコントロールAPIを試す","created_at":"2020-06-11T00:00:00.000Z","tags":["Android","Android11","Kotlin","Android R"],"bodyContent":"Android 11 Beta きたぞおおおおおおおおお   \\r\\n🥳←これすき\\r\\n\\r\\n# 追記：2020/06/13\\r\\nGoogle Payが使えないと言いました。が、Suicaで電車に乗れたので多分**おｻｲﾌｹｰﾀｲ**アプリでは対応していない**NFC Pay**あたりが使えないんだと思います。  \\r\\nFelica使う系は多分行けるんじゃないですかね？\\r\\n\\r\\nあとスライダー(RangeTemplate)動いたのでそれも\\r\\n\\r\\n# 本題\\r\\nAndroid 11 Beta 1 来ました。  \\r\\nわたし的に楽しみにしてる機能は\\r\\n- Device Control API (正式名称しらん)\\r\\n    - 証明のON/OFFとか明るさスライダーなど\\r\\n    - Quick Settings のスマートホーム版\\r\\n    - **スマートホームなんて金かかるからやらないと思う（よって使わない）**\\r\\n- Dynamic Intent Filter\\r\\n- Wi-Fi経由のADB\\r\\n    - カスROMには前からあるって？\\r\\n    - 公式で対応なんですよ！！！\\r\\n- Bubble\\r\\n    - **他のアプリに重ねて表示**が年々厳しくなってるので（最近、設定アプリの上に表示できなくなった）代替。\\r\\n    - ポップアップ再生の代替にはならなそう。あくまでメッセージアプリ向けなのかな。\\r\\n\\r\\n## Android 11 Beta入れようとしている各位\\r\\nGoogle Pay 使えなくなるらしいよ。DP4の段階では使えたんだけどまた使えなくなった。  \\r\\n![Imgur](https://imgur.com/r914HON.png)  \\r\\nSuica使えるんかな？  \\r\\n\\r\\n# Device Control API を試す\\r\\n**スマートホームなんてする予定なけど**せっかくBeta版の登場と一緒にAPIが文書化されてるので試しに追加してみる。\\r\\n\\r\\n[ドキュメント](https://developer.android.com/preview/features/device-control)\\r\\n\\r\\n# 環境\\r\\n|なまえ|あたい|\\r\\n|---|---|\\r\\n|言語|Kotlin|\\r\\n|Android|11 Beta 1|\\r\\n|端末|Pixel 3 XL|\\r\\n\\r\\n## Android R Betaの環境を揃えます。\\r\\nSDK Manager開いて、SDK Platformsタブを押して、**Android 10.0+(R)**にチェックを入れて**Apply**押してダウンロードしましょう。\\r\\n\\r\\n# build.gradle\\r\\n## バージョン\\r\\n```gradle\\r\\nandroid {\\r\\n    compileSdkVersion 30\\r\\n    buildToolsVersion \\"29.0.3\\"\\r\\n\\r\\n    defaultConfig {\\r\\n        applicationId \\"io.github.takusan23.devicecontrolstest\\"\\r\\n        minSdkVersion 30\\r\\n        targetSdkVersion 30\\r\\n        versionCode 1\\r\\n        versionName \\"1.0\\"\\r\\n        testInstrumentationRunner \\"androidx.test.runner.AndroidJUnitRunner\\"\\r\\n    }\\r\\n\\r\\n    buildTypes {\\r\\n        release {\\r\\n            minifyEnabled false\\r\\n            proguardFiles getDefaultProguardFile(\'proguard-android-optimize.txt\'), \'proguard-rules.pro\'\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n`compileSdkVersion 30`と`targetSdkVersion 30`になってればいいと思います。多分\\r\\n\\r\\n## ライブラリいれる\\r\\nドキュメントがRxJava入れてることを前提にしているので私も入れます。  \\r\\nRxJavaなんて使ったことないんだけどね。\\r\\n```gradle\\r\\ndependencies {\\r\\n    implementation \'org.reactivestreams:reactive-streams:1.0.3\'\\r\\n    implementation \'io.reactivex.rxjava2:rxjava:2.2.0\'\\r\\n}\\r\\n```\\r\\n\\r\\n# AndroidManifest書く\\r\\nおまじないです。\\r\\n```xml\\r\\n<service\\r\\n    android:name=\\".DeviceControlsService\\"\\r\\n    android:label=\\"@string/app_name\\"\\r\\n    android:permission=\\"android.permission.BIND_CONTROLS\\">\\r\\n    <intent-filter>\\r\\n        <action android:name=\\"android.service.controls.ControlsProviderService\\" />\\r\\n    </intent-filter>\\r\\n</service>\\r\\n```\\r\\n\\r\\n# DeviceControlsService っていうサービス作成\\r\\n`DeviceControlsService.kt`を作成します。  \\r\\n作成したら、`ControlsProviderService()`を継承します。\\r\\n```kotlin\\r\\nclass DeviceControlsService : ControlsProviderService() {\\r\\n    override fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\\r\\n\\r\\n    }\\r\\n\\r\\n    override fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\\r\\n\\r\\n    }\\r\\n\\r\\n    override fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\\r\\n\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\nでもこのままだと返り値なにもないのでIDEが赤いなみなみ出すので今から書いていきましょう。\\r\\n\\r\\n## 利用可能コントローラーの一覧を用意する\\r\\nこれから追加可能コントローラーを作っていきます。  \\r\\nここからユーザーが選ぶわけですね。  \\r\\n`createPublisherForAllAvailable()`に書いていきます。\\r\\n```kotlin\\r\\n// 追加するデバイスのID\\r\\nval TOGGLE_BUTTON_ID = \\"toggle_button_id\\"\\r\\n/**\\r\\n * 追加可能コントローラーを用意する。\\r\\n * */\\r\\noverride fun createPublisherForAllAvailable(): Flow.Publisher<Control> {\\r\\n    // コントローラーを長押しした時に表示するActivity\\r\\n    val intent = Intent(baseContext, MainActivity::class.java)\\r\\n    val pendingIntent =\\r\\n        PendingIntent.getActivity(baseContext, 10, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\r\\n    // まとめてコントローラーを追加するので配列に\\r\\n    val controlList = mutableListOf<Control>()\\r\\n    // ON/OFFサンプル。\\r\\n    val toggleControl = Control.StatelessBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\r\\n        .setTitle(\\"ON/OFFサンプル\\") // たいとる\\r\\n        .setSubtitle(\\"おすとON/OFFが切り替わります。\\") // サブタイトル\\r\\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) // あいこんといろの設定。\\r\\n        .build()\\r\\n    // 配列に追加\\r\\n    controlList.add(toggleControl)\\r\\n    // Reactive Streamsの知識が必要な模様。私にはないのでサンプルコピペする。\\r\\n    return FlowAdapters.toFlowPublisher(Flowable.fromIterable(controlList))\\r\\n}\\r\\n```\\r\\n\\r\\nコメント文は各自消してね。  \\r\\n### 注意\\r\\nここで使う`Control`は`Control.StatelessBuilder`の方です。  \\r\\nこれはまだ状態が（スイッチがONとかOFFとかって話）が分からない時に使うとか書いてあるけど多分この時に使います。\\r\\n\\r\\n## ユーザーが選んだコントローラーを用意する\\r\\n`利用可能コントローラーの一覧を用意する`で選んだコントローラーをユーザーが操作できるようにします。\\r\\n\\r\\n```kotlin\\r\\nlateinit var updatePublisher: ReplayProcessor<Control>\\r\\n/**\\r\\n * ユーザーが選んだコントローラーを用意する\\r\\n * 電源ボタン長押しでよばれる\\r\\n * */\\r\\noverride fun createPublisherFor(p0: MutableList<String>): Flow.Publisher<Control> {\\r\\n    // コントローラーを長押ししたときに表示するActivity\\r\\n    val intent = Intent(baseContext, MainActivity::class.java)\\r\\n    val pendingIntent =\\r\\n        PendingIntent.getActivity(baseContext, 12, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\r\\n    // 知識不足でわからん\\r\\n    updatePublisher = ReplayProcessor.create()\\r\\n    // コントローラー\\r\\n    if(p0.contains(TOGGLE_BUTTON_ID)) {\\r\\n        // ON/OFF\\r\\n        val toggle = ToggleTemplate(\\"toggle_template\\", ControlButton(false, \\"OFFですねえ！\\"))\\r\\n        // ここで作るControlは StatefulBuilder を使う。\\r\\n        val control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\r\\n            .setTitle(\\"ON/OFFサンプル\\") // たいとる\\r\\n            .setSubtitle(\\"おすとON/OFFが切り替わります。\\") // サブタイトル\\r\\n            .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\\r\\n            .setStatus(Control.STATUS_OK) // 現在の状態\\r\\n            .setControlTemplate(toggle) // 今回はON/OFFボタン\\r\\n            .build()\\r\\n        updatePublisher.onNext(control)\\r\\n    }\\r\\n    return FlowAdapters.toFlowPublisher(updatePublisher)\\r\\n}\\r\\n```\\r\\n\\r\\nこれでエラーは一応消えるので、早速実行してみましょう。\\r\\n\\r\\n# コントローラー追加\\r\\n電源ボタン長押しすると、**デバイス コントロール**が追加されているので、押してみましょう。  \\r\\n押すと、コントローラーが提供されているアプリ一覧画面が表示されるので、今作っているアプリを選びましょう。  \\r\\nすると、さっき作ったコントローラーが現れるのでチェックを入れて、右下の保存ボタンを押しましょう。  \\r\\n\\r\\n![Imgur](https://imgur.com/r2Wyog1.png)\\r\\n\\r\\nするとコントローラーが追加されているはずです。  \\r\\nですがこの段階では押してもなにも変わらないのでこれから押した時に`ON/OFF`を切り替える処理を書いていきたいと思います。\\r\\n\\r\\nちなみにエミュレータでAndroid 11動かすのにダウンロードが長かった。\\r\\n\\r\\n# コントローラーを押したときの処理\\r\\n押した時にON/OFFを切り替えられるようにします。\\r\\n```kotlin\\r\\n/**\\r\\n * コントローラーを押したとき\\r\\n * */\\r\\noverride fun performControlAction(p0: String, p1: ControlAction, p2: Consumer<Int>) {\\r\\n    // コントローラーを長押ししたときに表示するActivity\\r\\n    val intent = Intent(baseContext, MainActivity::class.java)\\r\\n    val pendingIntent =\\r\\n        PendingIntent.getActivity(baseContext, 11, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\r\\n    // システムに処理中とおしえる\\r\\n    p2.accept(ControlAction.RESPONSE_OK)\\r\\n    // コントローラー分岐\\r\\n    when (p0) {\\r\\n        TOGGLE_BUTTON_ID -> {\\r\\n            // ON/OFF切り替え\\r\\n            // ToggleTemplate は BooleanAction\\r\\n            if (p1 is BooleanAction) {\\r\\n                // ONかどうか\\r\\n                val isOn = p1.newState\\r\\n                val message = if (isOn) \\"ONです\\" else \\"OFFです\\"\\r\\n                val toggle = ToggleTemplate(\\"toggle_template\\", ControlButton(isOn, message))\\r\\n                // Control更新\\r\\n                val control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\r\\n                    .setTitle(\\"ON/OFFサンプル\\") // たいとる\\r\\n                    .setSubtitle(\\"おすとON/OFFが切り替わります。\\") // サブタイトル\\r\\n                    .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\\r\\n                    .setStatus(Control.STATUS_OK) // 現在の状態\\r\\n                    .setControlTemplate(toggle) // 今回はON/OFFボタン\\r\\n                    .setStatusText(message)\\r\\n                    .build()\\r\\n                updatePublisher.onNext(control)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\nこれで押した時にON/OFFが切り替わるようになりました。  \\r\\n`DeviceType#TYPE_LIGHT`見た目いい感じ。  \\r\\nスマートホームやってみたい（金ないけど）\\r\\n\\r\\n![Imgur](https://imgur.com/2TNFYZz.png)\\r\\n\\r\\n# おわりに\\r\\nソースコードです。https://github.com/takusan23/DeviceControlsTest\\r\\n\\r\\n~~それと**本当**はスライダー（値を調整できる`RangeTemplate`てやつ）コントローラーがあったんですけど、私の環境ではうまく動きませんでした。Beta版だからなのかそもそも私が間違ってるのか？~~\\r\\n\\r\\n**RangeTemplate**動きました。[参考にしました](https://gist.github.com/KieronQuinn/c9950f3ee09e11f305ce16e7f48f03b8)\\r\\n\\r\\n```kotlin\\r\\nval sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\\r\\n    .setTitle(\\"スライダーサンプル\\") // たいとる\\r\\n    .setSubtitle(\\"スライダーです。\\") // サブタイトル\\r\\n    .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\\r\\n    .setControlId(SLIDER_BUTTON_ID)\\r\\n    .setStatus(Control.STATUS_OK) // 現在の状態\\r\\nsliderControl.setControlTemplate(\\r\\n    ToggleRangeTemplate(\\r\\n        \\"slider_template\\",\\r\\n        ControlButton(true, \\"slider_button\\"),\\r\\n        RangeTemplate(\\"range\\", 0f, 10f, 1f, 1f, null)\\r\\n    )\\r\\n)\\r\\nupdatePublisher.onNext(sliderControl.build())\\r\\n```\\r\\n\\r\\nperformControlAction()はこうです。\\r\\n\\r\\n```kotlin\\r\\n// スライダー\\r\\n// RangeTemplate は FloatAction\\r\\nif (p1 is FloatAction) {\\r\\n    // 現在の値\\r\\n    val currentValue = p1.newValue\\r\\n    val sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\\r\\n        .setTitle(\\"スライダーサンプル\\") // たいとる\\r\\n        .setSubtitle(\\"スライダーです。\\") // サブタイトル\\r\\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) // 多分アイコンに使われてる？\\r\\n        .setControlId(SLIDER_BUTTON_ID)\\r\\n        .setStatus(Control.STATUS_OK) // 現在の状態\\r\\n    val controlButton = ControlButton(true, \\"slider_button\\")\\r\\n    sliderControl.setControlTemplate(\\r\\n        ToggleRangeTemplate(\\r\\n            \\"slider_template\\",\\r\\n            controlButton,\\r\\n            RangeTemplate(\\"range\\", 0f, 10f, currentValue, 1f, null)\\r\\n        )\\r\\n    )\\r\\n    updatePublisher.onNext(sliderControl.build())\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\nあと`DeviceType`がいっぱいあるので全種類アイコンと色を見てみたい。やってみるか。\\r\\n\\r\\nやりました→ https://github.com/takusan23/DeviceControlAllDeviceTypeSample\\r\\n\\r\\n\\r\\nDynamic Intent Filterもやりたい","bodyHtml":"<p>Android 11 Beta きたぞおおおおおおおおお<br>\\n🥳←これすき</p>\\n<h1>追記：2020/06/13</h1>\\n<p>Google Payが使えないと言いました。が、Suicaで電車に乗れたので多分<strong>おｻｲﾌｹｰﾀｲ</strong>アプリでは対応していない<strong>NFC Pay</strong>あたりが使えないんだと思います。<br>\\nFelica使う系は多分行けるんじゃないですかね？</p>\\n<p>あとスライダー(RangeTemplate)動いたのでそれも</p>\\n<h1>本題</h1>\\n<p>Android 11 Beta 1 来ました。<br>\\nわたし的に楽しみにしてる機能は</p>\\n<ul>\\n<li>Device Control API (正式名称しらん)\\n<ul>\\n<li>証明のON/OFFとか明るさスライダーなど</li>\\n<li>Quick Settings のスマートホーム版</li>\\n<li><strong>スマートホームなんて金かかるからやらないと思う（よって使わない）</strong></li>\\n</ul>\\n</li>\\n<li>Dynamic Intent Filter</li>\\n<li>Wi-Fi経由のADB\\n<ul>\\n<li>カスROMには前からあるって？</li>\\n<li>公式で対応なんですよ！！！</li>\\n</ul>\\n</li>\\n<li>Bubble\\n<ul>\\n<li><strong>他のアプリに重ねて表示</strong>が年々厳しくなってるので（最近、設定アプリの上に表示できなくなった）代替。</li>\\n<li>ポップアップ再生の代替にはならなそう。あくまでメッセージアプリ向けなのかな。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Android 11 Beta入れようとしている各位</h2>\\n<p>Google Pay 使えなくなるらしいよ。DP4の段階では使えたんだけどまた使えなくなった。<br>\\n<img src=\\"https://imgur.com/r914HON.png\\" alt=\\"Imgur\\"><br>\\nSuica使えるんかな？</p>\\n<h1>Device Control API を試す</h1>\\n<p><strong>スマートホームなんてする予定なけど</strong>せっかくBeta版の登場と一緒にAPIが文書化されてるので試しに追加してみる。</p>\\n<p><a href=\\"https://developer.android.com/preview/features/device-control\\">ドキュメント</a></p>\\n<h1>環境</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>なまえ</th>\\n<th>あたい</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>言語</td>\\n<td>Kotlin</td>\\n</tr>\\n<tr>\\n<td>Android</td>\\n<td>11 Beta 1</td>\\n</tr>\\n<tr>\\n<td>端末</td>\\n<td>Pixel 3 XL</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>Android R Betaの環境を揃えます。</h2>\\n<p>SDK Manager開いて、SDK Platformsタブを押して、<strong>Android 10.0+(R)<strong>にチェックを入れて</strong>Apply</strong>押してダウンロードしましょう。</p>\\n<h1>build.gradle</h1>\\n<h2>バージョン</h2>\\n<pre><code class=\\"hljs\\">android {\\n    compileSdkVersion <span class=\\"hljs-number\\">30</span>\\n    buildToolsVersion <span class=\\"hljs-string\\">\\"29.0.3\\"</span>\\n\\n    defaultConfig {\\n        applicationId <span class=\\"hljs-string\\">\\"io.github.takusan23.devicecontrolstest\\"</span>\\n        minSdkVersion <span class=\\"hljs-number\\">30</span>\\n        targetSdkVersion <span class=\\"hljs-number\\">30</span>\\n        versionCode <span class=\\"hljs-number\\">1</span>\\n        versionName <span class=\\"hljs-string\\">\\"1.0\\"</span>\\n        testInstrumentationRunner <span class=\\"hljs-string\\">\\"androidx.test.runner.AndroidJUnitRunner\\"</span>\\n    }\\n\\n    buildTypes {\\n        release {\\n            minifyEnabled <span class=\\"hljs-keyword\\">false</span>\\n            proguardFiles getDefaultProguardFile(<span class=\\"hljs-string\\">\'proguard-android-optimize.txt\'</span>), <span class=\\"hljs-string\\">\'proguard-rules.pro\'</span>\\n        }\\n    }\\n}</code></pre><p><code>compileSdkVersion 30</code>と<code>targetSdkVersion 30</code>になってればいいと思います。多分</p>\\n<h2>ライブラリいれる</h2>\\n<p>ドキュメントがRxJava入れてることを前提にしているので私も入れます。<br>\\nRxJavaなんて使ったことないんだけどね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">dependencies</span> {\\n    implementation <span class=\\"hljs-string\\">\'org.reactivestreams:reactive-streams:1.0.3\'</span>\\n    implementation <span class=\\"hljs-string\\">\'io.reactivex.rxjava2:rxjava:2.2.0\'</span>\\n}</code></pre><h1>AndroidManifest書く</h1>\\n<p>おまじないです。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">service</span>\\n    <span class=\\"hljs-attr\\">android:name</span>=<span class=\\"hljs-string\\">\\".DeviceControlsService\\"</span>\\n    <span class=\\"hljs-attr\\">android:label</span>=<span class=\\"hljs-string\\">\\"@string/app_name\\"</span>\\n    <span class=\\"hljs-attr\\">android:permission</span>=<span class=\\"hljs-string\\">\\"android.permission.BIND_CONTROLS\\"</span>&gt;</span>\\n    <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">intent-filter</span>&gt;</span>\\n        <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">action</span> <span class=\\"hljs-attr\\">android:name</span>=<span class=\\"hljs-string\\">\\"android.service.controls.ControlsProviderService\\"</span> /&gt;</span>\\n    <span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">intent-filter</span>&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">service</span>&gt;</span></code></pre><h1>DeviceControlsService っていうサービス作成</h1>\\n<p><code>DeviceControlsService.kt</code>を作成します。<br>\\n作成したら、<code>ControlsProviderService()</code>を継承します。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">DeviceControlsService</span> : <span class=\\"hljs-type\\">ControlsProviderService</span></span>() {\\n    <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">createPublisherForAllAvailable</span><span class=\\"hljs-params\\">()</span></span>: Flow.Publisher&lt;Control&gt; {\\n\\n    }\\n\\n    <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">performControlAction</span><span class=\\"hljs-params\\">(p0: <span class=\\"hljs-type\\">String</span>, p1: <span class=\\"hljs-type\\">ControlAction</span>, p2: <span class=\\"hljs-type\\">Consumer</span>&lt;<span class=\\"hljs-type\\">Int</span>&gt;)</span></span> {\\n\\n    }\\n\\n    <span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">createPublisherFor</span><span class=\\"hljs-params\\">(p0: <span class=\\"hljs-type\\">MutableList</span>&lt;<span class=\\"hljs-type\\">String</span>&gt;)</span></span>: Flow.Publisher&lt;Control&gt; {\\n\\n    }\\n}</code></pre><p>でもこのままだと返り値なにもないのでIDEが赤いなみなみ出すので今から書いていきましょう。</p>\\n<h2>利用可能コントローラーの一覧を用意する</h2>\\n<p>これから追加可能コントローラーを作っていきます。<br>\\nここからユーザーが選ぶわけですね。<br>\\n<code>createPublisherForAllAvailable()</code>に書いていきます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// 追加するデバイスのID</span>\\n<span class=\\"hljs-keyword\\">val</span> TOGGLE_BUTTON_ID = <span class=\\"hljs-string\\">\\"toggle_button_id\\"</span>\\n<span class=\\"hljs-comment\\">/**\\n * 追加可能コントローラーを用意する。\\n * */</span>\\n<span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">createPublisherForAllAvailable</span><span class=\\"hljs-params\\">()</span></span>: Flow.Publisher&lt;Control&gt; {\\n    <span class=\\"hljs-comment\\">// コントローラーを長押しした時に表示するActivity</span>\\n    <span class=\\"hljs-keyword\\">val</span> intent = Intent(baseContext, MainActivity::<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span>.<span class=\\"hljs-title\\">java</span>)</span>\\n    <span class=\\"hljs-keyword\\">val</span> pendingIntent =\\n        PendingIntent.getActivity(baseContext, <span class=\\"hljs-number\\">10</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\n    <span class=\\"hljs-comment\\">// まとめてコントローラーを追加するので配列に</span>\\n    <span class=\\"hljs-keyword\\">val</span> controlList = mutableListOf&lt;Control&gt;()\\n    <span class=\\"hljs-comment\\">// ON/OFFサンプル。</span>\\n    <span class=\\"hljs-keyword\\">val</span> toggleControl = Control.StatelessBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\n        .setTitle(<span class=\\"hljs-string\\">\\"ON/OFFサンプル\\"</span>) <span class=\\"hljs-comment\\">// たいとる</span>\\n        .setSubtitle(<span class=\\"hljs-string\\">\\"おすとON/OFFが切り替わります。\\"</span>) <span class=\\"hljs-comment\\">// サブタイトル</span>\\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) <span class=\\"hljs-comment\\">// あいこんといろの設定。</span>\\n        .build()\\n    <span class=\\"hljs-comment\\">// 配列に追加</span>\\n    controlList.add(toggleControl)\\n    <span class=\\"hljs-comment\\">// Reactive Streamsの知識が必要な模様。私にはないのでサンプルコピペする。</span>\\n    <span class=\\"hljs-keyword\\">return</span> FlowAdapters.toFlowPublisher(Flowable.fromIterable(controlList))\\n}</code></pre><p>コメント文は各自消してね。</p>\\n<h3>注意</h3>\\n<p>ここで使う<code>Control</code>は<code>Control.StatelessBuilder</code>の方です。<br>\\nこれはまだ状態が（スイッチがONとかOFFとかって話）が分からない時に使うとか書いてあるけど多分この時に使います。</p>\\n<h2>ユーザーが選んだコントローラーを用意する</h2>\\n<p><code>利用可能コントローラーの一覧を用意する</code>で選んだコントローラーをユーザーが操作できるようにします。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">lateinit</span> <span class=\\"hljs-keyword\\">var</span> updatePublisher: ReplayProcessor&lt;Control&gt;\\n<span class=\\"hljs-comment\\">/**\\n * ユーザーが選んだコントローラーを用意する\\n * 電源ボタン長押しでよばれる\\n * */</span>\\n<span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">createPublisherFor</span><span class=\\"hljs-params\\">(p0: <span class=\\"hljs-type\\">MutableList</span>&lt;<span class=\\"hljs-type\\">String</span>&gt;)</span></span>: Flow.Publisher&lt;Control&gt; {\\n    <span class=\\"hljs-comment\\">// コントローラーを長押ししたときに表示するActivity</span>\\n    <span class=\\"hljs-keyword\\">val</span> intent = Intent(baseContext, MainActivity::<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span>.<span class=\\"hljs-title\\">java</span>)</span>\\n    <span class=\\"hljs-keyword\\">val</span> pendingIntent =\\n        PendingIntent.getActivity(baseContext, <span class=\\"hljs-number\\">12</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\n    <span class=\\"hljs-comment\\">// 知識不足でわからん</span>\\n    updatePublisher = ReplayProcessor.create()\\n    <span class=\\"hljs-comment\\">// コントローラー</span>\\n    <span class=\\"hljs-keyword\\">if</span>(p0.contains(TOGGLE_BUTTON_ID)) {\\n        <span class=\\"hljs-comment\\">// ON/OFF</span>\\n        <span class=\\"hljs-keyword\\">val</span> toggle = ToggleTemplate(<span class=\\"hljs-string\\">\\"toggle_template\\"</span>, ControlButton(<span class=\\"hljs-literal\\">false</span>, <span class=\\"hljs-string\\">\\"OFFですねえ！\\"</span>))\\n        <span class=\\"hljs-comment\\">// ここで作るControlは StatefulBuilder を使う。</span>\\n        <span class=\\"hljs-keyword\\">val</span> control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\n            .setTitle(<span class=\\"hljs-string\\">\\"ON/OFFサンプル\\"</span>) <span class=\\"hljs-comment\\">// たいとる</span>\\n            .setSubtitle(<span class=\\"hljs-string\\">\\"おすとON/OFFが切り替わります。\\"</span>) <span class=\\"hljs-comment\\">// サブタイトル</span>\\n            .setDeviceType(DeviceTypes.TYPE_LIGHT) <span class=\\"hljs-comment\\">// 多分アイコンに使われてる？</span>\\n            .setStatus(Control.STATUS_OK) <span class=\\"hljs-comment\\">// 現在の状態</span>\\n            .setControlTemplate(toggle) <span class=\\"hljs-comment\\">// 今回はON/OFFボタン</span>\\n            .build()\\n        updatePublisher.onNext(control)\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> FlowAdapters.toFlowPublisher(updatePublisher)\\n}</code></pre><p>これでエラーは一応消えるので、早速実行してみましょう。</p>\\n<h1>コントローラー追加</h1>\\n<p>電源ボタン長押しすると、<strong>デバイス コントロール</strong>が追加されているので、押してみましょう。<br>\\n押すと、コントローラーが提供されているアプリ一覧画面が表示されるので、今作っているアプリを選びましょう。<br>\\nすると、さっき作ったコントローラーが現れるのでチェックを入れて、右下の保存ボタンを押しましょう。</p>\\n<p><img src=\\"https://imgur.com/r2Wyog1.png\\" alt=\\"Imgur\\"></p>\\n<p>するとコントローラーが追加されているはずです。<br>\\nですがこの段階では押してもなにも変わらないのでこれから押した時に<code>ON/OFF</code>を切り替える処理を書いていきたいと思います。</p>\\n<p>ちなみにエミュレータでAndroid 11動かすのにダウンロードが長かった。</p>\\n<h1>コントローラーを押したときの処理</h1>\\n<p>押した時にON/OFFを切り替えられるようにします。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/**\\n * コントローラーを押したとき\\n * */</span>\\n<span class=\\"hljs-keyword\\">override</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fun</span> <span class=\\"hljs-title\\">performControlAction</span><span class=\\"hljs-params\\">(p0: <span class=\\"hljs-type\\">String</span>, p1: <span class=\\"hljs-type\\">ControlAction</span>, p2: <span class=\\"hljs-type\\">Consumer</span>&lt;<span class=\\"hljs-type\\">Int</span>&gt;)</span></span> {\\n    <span class=\\"hljs-comment\\">// コントローラーを長押ししたときに表示するActivity</span>\\n    <span class=\\"hljs-keyword\\">val</span> intent = Intent(baseContext, MainActivity::<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span>.<span class=\\"hljs-title\\">java</span>)</span>\\n    <span class=\\"hljs-keyword\\">val</span> pendingIntent =\\n        PendingIntent.getActivity(baseContext, <span class=\\"hljs-number\\">11</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT)\\n    <span class=\\"hljs-comment\\">// システムに処理中とおしえる</span>\\n    p2.accept(ControlAction.RESPONSE_OK)\\n    <span class=\\"hljs-comment\\">// コントローラー分岐</span>\\n    <span class=\\"hljs-keyword\\">when</span> (p0) {\\n        TOGGLE_BUTTON_ID -&gt; {\\n            <span class=\\"hljs-comment\\">// ON/OFF切り替え</span>\\n            <span class=\\"hljs-comment\\">// ToggleTemplate は BooleanAction</span>\\n            <span class=\\"hljs-keyword\\">if</span> (p1 <span class=\\"hljs-keyword\\">is</span> BooleanAction) {\\n                <span class=\\"hljs-comment\\">// ONかどうか</span>\\n                <span class=\\"hljs-keyword\\">val</span> isOn = p1.newState\\n                <span class=\\"hljs-keyword\\">val</span> message = <span class=\\"hljs-keyword\\">if</span> (isOn) <span class=\\"hljs-string\\">\\"ONです\\"</span> <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-string\\">\\"OFFです\\"</span>\\n                <span class=\\"hljs-keyword\\">val</span> toggle = ToggleTemplate(<span class=\\"hljs-string\\">\\"toggle_template\\"</span>, ControlButton(isOn, message))\\n                <span class=\\"hljs-comment\\">// Control更新</span>\\n                <span class=\\"hljs-keyword\\">val</span> control = Control.StatefulBuilder(TOGGLE_BUTTON_ID, pendingIntent)\\n                    .setTitle(<span class=\\"hljs-string\\">\\"ON/OFFサンプル\\"</span>) <span class=\\"hljs-comment\\">// たいとる</span>\\n                    .setSubtitle(<span class=\\"hljs-string\\">\\"おすとON/OFFが切り替わります。\\"</span>) <span class=\\"hljs-comment\\">// サブタイトル</span>\\n                    .setDeviceType(DeviceTypes.TYPE_LIGHT) <span class=\\"hljs-comment\\">// 多分アイコンに使われてる？</span>\\n                    .setStatus(Control.STATUS_OK) <span class=\\"hljs-comment\\">// 現在の状態</span>\\n                    .setControlTemplate(toggle) <span class=\\"hljs-comment\\">// 今回はON/OFFボタン</span>\\n                    .setStatusText(message)\\n                    .build()\\n                updatePublisher.onNext(control)\\n            }\\n        }\\n    }\\n}</code></pre><p>これで押した時にON/OFFが切り替わるようになりました。<br>\\n<code>DeviceType#TYPE_LIGHT</code>見た目いい感じ。<br>\\nスマートホームやってみたい（金ないけど）</p>\\n<p><img src=\\"https://imgur.com/2TNFYZz.png\\" alt=\\"Imgur\\"></p>\\n<h1>おわりに</h1>\\n<p>ソースコードです。<a href=\\"https://github.com/takusan23/DeviceControlsTest\\">https://github.com/takusan23/DeviceControlsTest</a></p>\\n<p><s>それと<strong>本当</strong>はスライダー（値を調整できる<code>RangeTemplate</code>てやつ）コントローラーがあったんですけど、私の環境ではうまく動きませんでした。Beta版だからなのかそもそも私が間違ってるのか？</s></p>\\n<p><strong>RangeTemplate</strong>動きました。<a href=\\"https://gist.github.com/KieronQuinn/c9950f3ee09e11f305ce16e7f48f03b8\\">参考にしました</a></p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">val</span> sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\\n    .setTitle(<span class=\\"hljs-string\\">\\"スライダーサンプル\\"</span>) <span class=\\"hljs-comment\\">// たいとる</span>\\n    .setSubtitle(<span class=\\"hljs-string\\">\\"スライダーです。\\"</span>) <span class=\\"hljs-comment\\">// サブタイトル</span>\\n    .setDeviceType(DeviceTypes.TYPE_LIGHT) <span class=\\"hljs-comment\\">// 多分アイコンに使われてる？</span>\\n    .setControlId(SLIDER_BUTTON_ID)\\n    .setStatus(Control.STATUS_OK) <span class=\\"hljs-comment\\">// 現在の状態</span>\\nsliderControl.setControlTemplate(\\n    ToggleRangeTemplate(\\n        <span class=\\"hljs-string\\">\\"slider_template\\"</span>,\\n        ControlButton(<span class=\\"hljs-literal\\">true</span>, <span class=\\"hljs-string\\">\\"slider_button\\"</span>),\\n        RangeTemplate(<span class=\\"hljs-string\\">\\"range\\"</span>, <span class=\\"hljs-number\\">0f</span>, <span class=\\"hljs-number\\">10f</span>, <span class=\\"hljs-number\\">1f</span>, <span class=\\"hljs-number\\">1f</span>, <span class=\\"hljs-literal\\">null</span>)\\n    )\\n)\\nupdatePublisher.onNext(sliderControl.build())</code></pre><p>performControlAction()はこうです。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// スライダー</span>\\n<span class=\\"hljs-comment\\">// RangeTemplate は FloatAction</span>\\n<span class=\\"hljs-keyword\\">if</span> (p1 <span class=\\"hljs-keyword\\">is</span> FloatAction) {\\n    <span class=\\"hljs-comment\\">// 現在の値</span>\\n    <span class=\\"hljs-keyword\\">val</span> currentValue = p1.newValue\\n    <span class=\\"hljs-keyword\\">val</span> sliderControl = Control.StatefulBuilder(SLIDER_BUTTON_ID, pendingIntent)\\n        .setTitle(<span class=\\"hljs-string\\">\\"スライダーサンプル\\"</span>) <span class=\\"hljs-comment\\">// たいとる</span>\\n        .setSubtitle(<span class=\\"hljs-string\\">\\"スライダーです。\\"</span>) <span class=\\"hljs-comment\\">// サブタイトル</span>\\n        .setDeviceType(DeviceTypes.TYPE_LIGHT) <span class=\\"hljs-comment\\">// 多分アイコンに使われてる？</span>\\n        .setControlId(SLIDER_BUTTON_ID)\\n        .setStatus(Control.STATUS_OK) <span class=\\"hljs-comment\\">// 現在の状態</span>\\n    <span class=\\"hljs-keyword\\">val</span> controlButton = ControlButton(<span class=\\"hljs-literal\\">true</span>, <span class=\\"hljs-string\\">\\"slider_button\\"</span>)\\n    sliderControl.setControlTemplate(\\n        ToggleRangeTemplate(\\n            <span class=\\"hljs-string\\">\\"slider_template\\"</span>,\\n            controlButton,\\n            RangeTemplate(<span class=\\"hljs-string\\">\\"range\\"</span>, <span class=\\"hljs-number\\">0f</span>, <span class=\\"hljs-number\\">10f</span>, currentValue, <span class=\\"hljs-number\\">1f</span>, <span class=\\"hljs-literal\\">null</span>)\\n        )\\n    )\\n    updatePublisher.onNext(sliderControl.build())\\n}</code></pre><p>あと<code>DeviceType</code>がいっぱいあるので全種類アイコンと色を見てみたい。やってみるか。</p>\\n<p>やりました→ <a href=\\"https://github.com/takusan23/DeviceControlAllDeviceTypeSample\\">https://github.com/takusan23/DeviceControlAllDeviceTypeSample</a></p>\\n<p>Dynamic Intent Filterもやりたい</p>\\n","dir":"contents/posts/json","base":"android11_devicecontrol.json","ext":".json","sourceBase":"android11_devicecontrol.md","sourceExt":".md"}')},608:function(n){n.exports=JSON.parse('{"title":"Hello Android 11。systemUiVisibility編","created_at":"2020-06-22T00:00:00.000Z","tags":["Android","Android11","Kotlin"],"bodyContent":"よーこそ`targetSdkVersion 30`の世界へ\\r\\n\\r\\n# 本題\\r\\nActivityを全画面にしたり、ステータスバー、ナビゲーションを一時的に消すときに`window?.decorView?.systemUiVisibility`がAndroid 11から非推奨になった  \\r\\n代わりに`WindowInsetsController`を使って消すらしい。\\r\\n\\r\\n# 環境\\r\\n\\r\\n|なまえ|あたい|\\r\\n|---|---|\\r\\n|端末|Pixel 3 XL|\\r\\n|Android|11 Beta 1|\\r\\n\\r\\n# 非表示の種類\\r\\n- **スワイプすることで一時的にはステータスバー、ナビゲーションバーが表示され、数秒操作しないとまた自動で全画面に戻る**\\r\\n    - 動画アプリとか\\r\\n    - `WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE`を使う（後述）\\r\\n- **スワイプして、ステータスバーを表示させるけどそのまま表示したままになる**\\r\\n    - どこで使ってるかはわからんな\\r\\n    - `WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE`を使う（後述）\\r\\n\\r\\n# つくる\\r\\n\\r\\nスワイプすると一時的に表示される方  \\r\\n一時的に表示しているバーは半透明になっている。\\r\\n\\r\\n```kotlin\\r\\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\\r\\n    // Android 11 以上と分岐\\r\\n    window?.insetsController?.apply {\\r\\n        // スワイプで一時的に表示可能\\r\\n        systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\\r\\n        // StatusBar + NavigationBar 非表示\\r\\n        hide(WindowInsets.Type.systemBars())\\r\\n        // ノッチにも侵略\\r\\n        window?.attributes?.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\\r\\n    }\\r\\n} else {\\r\\n    // Android 10 以前。\\r\\n    window?.decorView?.systemUiVisibility = View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\\r\\n}\\r\\n```\\r\\n\\r\\nノッチまでは広げなくていい場合は、ノッチにも侵略の一行をコメントアウトしてね。  \\r\\n\\r\\nもし一時的に表示ではなく、一回表示したらずっと出っぱなしにする際は`systemBarsBehavior`を  \\r\\n\\r\\n```kotlin\\r\\nsystemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE\\r\\n```\\r\\n\\r\\nにすればいいと思います。\\r\\n\\r\\n`Type#systemBars()`を使うと、ステータスバーとナビゲーションバーを消しますが、別に以下のコードでも動きます。  \\r\\n\\r\\n```kotlin\\r\\n// ステータスバー\\r\\nhide(WindowInsets.Type.statusBars())\\r\\n// ナビゲーションバー\\r\\nhide(WindowInsets.Type.navigationBars())\\r\\n```\\r\\n\\r\\n# おまけ\\r\\nIME（キーボードのこと）もこの`WindowInsetsController`を利用することで、一行で消せるようになりました。\\r\\n\\r\\n```kotlin\\r\\nwindow?.insetsController?.hide(WindowInsets.Type.ime())\\r\\n```\\r\\n\\r\\nキーボード隠すのなんか面倒だし成功したことないからこの方法が使えるのは嬉しい。🥳","bodyHtml":"<p>よーこそ<code>targetSdkVersion 30</code>の世界へ</p>\\n<h1>本題</h1>\\n<p>Activityを全画面にしたり、ステータスバー、ナビゲーションを一時的に消すときに<code>window?.decorView?.systemUiVisibility</code>がAndroid 11から非推奨になった<br>\\n代わりに<code>WindowInsetsController</code>を使って消すらしい。</p>\\n<h1>環境</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>なまえ</th>\\n<th>あたい</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>端末</td>\\n<td>Pixel 3 XL</td>\\n</tr>\\n<tr>\\n<td>Android</td>\\n<td>11 Beta 1</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>非表示の種類</h1>\\n<ul>\\n<li><strong>スワイプすることで一時的にはステータスバー、ナビゲーションバーが表示され、数秒操作しないとまた自動で全画面に戻る</strong>\\n<ul>\\n<li>動画アプリとか</li>\\n<li><code>WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</code>を使う（後述）</li>\\n</ul>\\n</li>\\n<li><strong>スワイプして、ステータスバーを表示させるけどそのまま表示したままになる</strong>\\n<ul>\\n<li>どこで使ってるかはわからんな</li>\\n<li><code>WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE</code>を使う（後述）</li>\\n</ul>\\n</li>\\n</ul>\\n<h1>つくる</h1>\\n<p>スワイプすると一時的に表示される方<br>\\n一時的に表示しているバーは半透明になっている。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {\\n    <span class=\\"hljs-comment\\">// Android 11 以上と分岐</span>\\n    window?.insetsController?.apply {\\n        <span class=\\"hljs-comment\\">// スワイプで一時的に表示可能</span>\\n        systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE\\n        <span class=\\"hljs-comment\\">// StatusBar + NavigationBar 非表示</span>\\n        hide(WindowInsets.Type.systemBars())\\n        <span class=\\"hljs-comment\\">// ノッチにも侵略</span>\\n        window?.attributes?.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\\n    }\\n} <span class=\\"hljs-keyword\\">else</span> {\\n    <span class=\\"hljs-comment\\">// Android 10 以前。</span>\\n    window?.decorView?.systemUiVisibility = View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\\n}</code></pre><p>ノッチまでは広げなくていい場合は、ノッチにも侵略の一行をコメントアウトしてね。</p>\\n<p>もし一時的に表示ではなく、一回表示したらずっと出っぱなしにする際は<code>systemBarsBehavior</code>を</p>\\n<pre><code class=\\"hljs\\">systemBarsBehavior = WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE</code></pre><p>にすればいいと思います。</p>\\n<p><code>Type#systemBars()</code>を使うと、ステータスバーとナビゲーションバーを消しますが、別に以下のコードでも動きます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// ステータスバー</span>\\nhide(WindowInsets.Type.statusBars())\\n<span class=\\"hljs-comment\\">// ナビゲーションバー</span>\\nhide(WindowInsets.Type.navigationBars())</code></pre><h1>おまけ</h1>\\n<p>IME（キーボードのこと）もこの<code>WindowInsetsController</code>を利用することで、一行で消せるようになりました。</p>\\n<pre><code class=\\"hljs\\">window?.insetsController?.hide(WindowInsets.Type.ime())</code></pre><p>キーボード隠すのなんか面倒だし成功したことないからこの方法が使えるのは嬉しい。🥳</p>\\n","dir":"contents/posts/json","base":"android11_statusbar_hide.json","ext":".json","sourceBase":"android11_statusbar_hide.md","sourceExt":".md"}')},609:function(n){n.exports=JSON.parse('{"title":"Google Domainsでドメイン買ったからNetlifyで使う","created_at":"2020-06-15T00:00:00.000Z","tags":["Netlify","自作ブログ"],"bodyContent":"どうもこんばんわ。  \\r\\nニコ生で桜Trick一挙見ました。にやにや止まらんかった。一話から勢いすごかった。\\r\\n\\r\\n# 本題\\r\\nドメインを買いました。  \\r\\n三日前ぐらいからドメイン名どうするか考えてたのですが、特に思いつかなかったので好きなお寿司の名前(ねぎとろ)にしました。\\r\\n\\r\\n# ドメイン取得\\r\\n[Google Domains](https://domains.google/intl/ja_jp/)です。  \\r\\n`.dev`ドメイン（かっこいいって理由）を取りました。維持に一年1400円かかるそうです。  \\r\\n一瞬高く見えましたが、ニコ動のプレ垢は一ヶ月550円なのでそんなことなかった。  \\r\\n\\r\\n**Kyashで払えました。** 三井住友銀行アプリUSBデバッグ有効だと起動しないから履歴見るのめんどいんだわ。[^1]\\r\\n\\r\\n## 買い方（いる？）\\r\\n1:ほしいの選ぶ。  \\r\\n![Imgur](https://imgur.com/SkLuylR.png)\\r\\n\\r\\nスイッチとかはそのままにして次へ\\r\\n\\r\\n2:自分の情報入れる。  \\r\\n![Imgur](https://imgur.com/TLrH5Gb.png)\\r\\n\\r\\nWhoisって言うドメイン所有者を検索できる機能があるそうですが、ここに入力した情報は表示されないそうです。てかそうじゃないと困る\\r\\n\\r\\n3:支払い  \\r\\n![Imgur](https://imgur.com/r18xLqi.png)\\r\\n\\r\\n~~消費税怖い~~\\r\\n\\r\\n## Whoisどうなってんの？\\r\\n果たして私の情報はどの様に保護されたのか。  \\r\\n\\r\\nGoogle Domainsのナビゲーションドロワーにある、**登録の設定**押して、**公開連絡先情報**にある、**連絡先情報**に情報が書いてあるそうです。  \\r\\n\\r\\n開くと、こんな感じに（どこまで写して良いのかわからんから適当に抜粋）なってました。\\r\\n\\r\\n```console\\r\\nRegistrar: Google LLC\\r\\nRegistry Registrant ID: REDACTED FOR PRIVACY\\r\\nRegistrant Name: Contact Privacy Inc. なんとか～\\r\\nRegistry Admin ID: REDACTED FOR PRIVACY\\r\\nRegistry Tech ID: REDACTED FOR PRIVACY\\r\\n```\\r\\n\\r\\n多分大丈夫だと思います\\r\\n\\r\\n# Netlifyで使う\\r\\n\\r\\nまずNetlifyで管理画面？を開いて、カスタムドメインを設定する画面を開きます（スクショしそこねた）\\r\\n\\r\\nそしたらこんな感じに買ったドメインを入れて（今回はサブドメインにした）  \\r\\n\\r\\n![Imgur](https://imgur.com/xqMeXJO.png)\\r\\n\\r\\nDNSがなんとかって出るので押すと、この画面が出ると思います。  \\r\\nこの値は使うのでChrome二窓しましょう。  \\r\\n![Imgur](https://imgur.com/Whn3UvK.png)\\r\\n\\r\\nそしたら、**Google Domains**のナビゲーションドロワーにある**DNS**を押して、一番下に有る（編集時現在）**カスタム リソースレコード**にスクショのように情報を入れます（入力する内容は人それぞれ違いますからね！）。\\r\\n\\r\\n![Imgur](https://imgur.com/mg8hT6S.png)\\r\\n\\r\\n以上です。後は待つだけです。私は一時間しない間位に買ったドメインでNetlifyのページを開くことができました。わーい\\r\\n\\r\\nちなみにドメインでひらけるようになった頃にはSSLの設定（Let\'s Encrypt？）も自動でやってくれました。あざす\\r\\n\\r\\n# Google Analytics 直す\\r\\nを開いて、**管理**を押して、**プロパティ設定**選んで、**デフォルトのURL**を直してあげます。`https://`はドロップダウンメニューにすでにあるので、`https://`抜いたURLを書きましょう。\\r\\n\\r\\n![Imgur](https://imgur.com/ILmGn11.png)\\r\\n\\r\\n~~まあAnalytics置いたところで検索エンジンに乗らない(なんで？)ので意味ない~~\\r\\n\\r\\n# おわりに\\r\\nGoogle Domainsで購入する際に`営利目的もしくは商用利用で利用する場合のみ利用できる`みたいなことが書いてあったんだけど大丈夫かな（？）  \\r\\n![Imgur](https://imgur.com/RtQKKEj.png)\\r\\n\\r\\n# 参考にしました\\r\\nありがとうございます\\r\\n\\r\\nhttps://hardworkers.dev/blog/google-domains-setting-netlify/\\r\\n\\r\\nhttps://blog.a-1.dev/post/2019-04-05-migrate-domain/\\r\\n\\r\\n[^1]:Logcatに見られたら困る内容流してるんか？","bodyHtml":"<p>どうもこんばんわ。<br>\\nニコ生で桜Trick一挙見ました。にやにや止まらんかった。一話から勢いすごかった。</p>\\n<h1>本題</h1>\\n<p>ドメインを買いました。<br>\\n三日前ぐらいからドメイン名どうするか考えてたのですが、特に思いつかなかったので好きなお寿司の名前(ねぎとろ)にしました。</p>\\n<h1>ドメイン取得</h1>\\n<p><a href=\\"https://domains.google/intl/ja_jp/\\">Google Domains</a>です。<br>\\n<code>.dev</code>ドメイン（かっこいいって理由）を取りました。維持に一年1400円かかるそうです。<br>\\n一瞬高く見えましたが、ニコ動のプレ垢は一ヶ月550円なのでそんなことなかった。</p>\\n<p><strong>Kyashで払えました。</strong> 三井住友銀行アプリUSBデバッグ有効だと起動しないから履歴見るのめんどいんだわ。<a href=\\"Logcat%E3%81%AB%E8%A6%8B%E3%82%89%E3%82%8C%E3%81%9F%E3%82%89%E5%9B%B0%E3%82%8B%E5%86%85%E5%AE%B9%E6%B5%81%E3%81%97%E3%81%A6%E3%82%8B%E3%82%93%E3%81%8B%EF%BC%9F\\">^1</a></p>\\n<h2>買い方（いる？）</h2>\\n<p>1:ほしいの選ぶ。<br>\\n<img src=\\"https://imgur.com/SkLuylR.png\\" alt=\\"Imgur\\"></p>\\n<p>スイッチとかはそのままにして次へ</p>\\n<p>2:自分の情報入れる。<br>\\n<img src=\\"https://imgur.com/TLrH5Gb.png\\" alt=\\"Imgur\\"></p>\\n<p>Whoisって言うドメイン所有者を検索できる機能があるそうですが、ここに入力した情報は表示されないそうです。てかそうじゃないと困る</p>\\n<p>3:支払い<br>\\n<img src=\\"https://imgur.com/r18xLqi.png\\" alt=\\"Imgur\\"></p>\\n<p><s>消費税怖い</s></p>\\n<h2>Whoisどうなってんの？</h2>\\n<p>果たして私の情報はどの様に保護されたのか。</p>\\n<p>Google Domainsのナビゲーションドロワーにある、<strong>登録の設定</strong>押して、<strong>公開連絡先情報</strong>にある、<strong>連絡先情報</strong>に情報が書いてあるそうです。</p>\\n<p>開くと、こんな感じに（どこまで写して良いのかわからんから適当に抜粋）なってました。</p>\\n<pre><code class=\\"hljs\\">Registrar: Google LLC\\nRegistry Registrant ID: REDACTED FOR PRIVACY\\nRegistrant Name: Contact Privacy Inc. なんとか～\\nRegistry Admin ID: REDACTED FOR PRIVACY\\nRegistry Tech ID: REDACTED FOR PRIVACY</code></pre><p>多分大丈夫だと思います</p>\\n<h1>Netlifyで使う</h1>\\n<p>まずNetlifyで管理画面？を開いて、カスタムドメインを設定する画面を開きます（スクショしそこねた）</p>\\n<p>そしたらこんな感じに買ったドメインを入れて（今回はサブドメインにした）</p>\\n<p><img src=\\"https://imgur.com/xqMeXJO.png\\" alt=\\"Imgur\\"></p>\\n<p>DNSがなんとかって出るので押すと、この画面が出ると思います。<br>\\nこの値は使うのでChrome二窓しましょう。<br>\\n<img src=\\"https://imgur.com/Whn3UvK.png\\" alt=\\"Imgur\\"></p>\\n<p>そしたら、<strong>Google Domains</strong>のナビゲーションドロワーにある<strong>DNS</strong>を押して、一番下に有る（編集時現在）<strong>カスタム リソースレコード</strong>にスクショのように情報を入れます（入力する内容は人それぞれ違いますからね！）。</p>\\n<p><img src=\\"https://imgur.com/mg8hT6S.png\\" alt=\\"Imgur\\"></p>\\n<p>以上です。後は待つだけです。私は一時間しない間位に買ったドメインでNetlifyのページを開くことができました。わーい</p>\\n<p>ちなみにドメインでひらけるようになった頃にはSSLの設定（Let\'s Encrypt？）も自動でやってくれました。あざす</p>\\n<h1>Google Analytics 直す</h1>\\n<p>を開いて、<strong>管理</strong>を押して、<strong>プロパティ設定</strong>選んで、<strong>デフォルトのURL</strong>を直してあげます。<code>https://</code>はドロップダウンメニューにすでにあるので、<code>https://</code>抜いたURLを書きましょう。</p>\\n<p><img src=\\"https://imgur.com/ILmGn11.png\\" alt=\\"Imgur\\"></p>\\n<p><s>まあAnalytics置いたところで検索エンジンに乗らない(なんで？)ので意味ない</s></p>\\n<h1>おわりに</h1>\\n<p>Google Domainsで購入する際に<code>営利目的もしくは商用利用で利用する場合のみ利用できる</code>みたいなことが書いてあったんだけど大丈夫かな（？）<br>\\n<img src=\\"https://imgur.com/RtQKKEj.png\\" alt=\\"Imgur\\"></p>\\n<h1>参考にしました</h1>\\n<p>ありがとうございます</p>\\n<p><a href=\\"https://hardworkers.dev/blog/google-domains-setting-netlify/\\">https://hardworkers.dev/blog/google-domains-setting-netlify/</a></p>\\n<p><a href=\\"https://blog.a-1.dev/post/2019-04-05-migrate-domain/\\">https://blog.a-1.dev/post/2019-04-05-migrate-domain/</a></p>\\n","dir":"contents/posts/json","base":"domain_katta.json","ext":".json","sourceBase":"domain_katta.md","sourceExt":".md"}')},610:function(n){n.exports=JSON.parse('{"title":".NET CoreでWPFアプリ作るぞ","created_at":"2020/06/09","tags":["CS","WPF",".NETCore"],"bodyContent":".NET Coreってなに\\r\\n\\r\\n# ほんだい\\r\\nWPFなんてめったに触らんから未来の私がWPFやる時に見に来る記事。  \\r\\n[WPFアプリ作ったので](../../posts/mousecursor_wpf/)その時に躓いたこ\\r\\n\\r\\n# 環境\\r\\n|なまえ|あたい|\\r\\n|---|---|\\r\\n|OS|Windows 10 Pro 2004|\\r\\n|Visual Studio|Community 2019|\\r\\n\\r\\n# .NET Coreってなに\\r\\nしらない。なんかよくわからんけど使う。  \\r\\n.NET Coreはクロスプラットフォームって言われてるけど、WPFに関してはWindowsに依存してるから関係ないよ\\r\\n\\r\\n[ソース](https://docs.microsoft.com/ja-jp/windows/apps/desktop/modernize/modernize-wpf-tutorial)\\r\\n\\r\\n# Visual Studio 2019 入れる\\r\\n最新版入れましょう。最新版じゃないと`WPF App (.NET Core)`が選べないと思います。  \\r\\nちなみに私は最新版にアップデートする際、ダウンロードするファイルが3GBを超えてました。クソ長かったわ。\\r\\n\\r\\n# プロジェクト作成\\r\\n検索ボックスに`wpf`って入れれば出ます。  \\r\\n`.NET Framework`じゃないほうを選びましょうね。\\r\\n![Imgur](https://imgur.com/BHxIloY.png)\\r\\n\\r\\n\\r\\nその後の`プロジェクト名`とかは各自決めてね。\\r\\n\\r\\n# ぷよぐらみんぐ\\r\\n久々のC#くんです。  \\r\\n（多分）Androidと同じ感じで、xamlでレイアウト決めて、C#でプログラムを書いていく感じですが、ちょっと違うのね。\\r\\n\\r\\n- Androidの`findViewById`\\r\\n    - C#ではレイアウトに`Name`付けとけばC#から扱える。\\r\\n    - KotlinでfindViewByIdが省略できるみたいな感じで書ける。\\r\\n\\r\\n## レイアウト\\r\\n**MainWindow.xaml**\\r\\n\\r\\n```xml\\r\\n<Window x:Class=\\"DotNetCoreWPF.MainWindow\\"\\r\\n        xmlns=\\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\\"\\r\\n        xmlns:x=\\"http://schemas.microsoft.com/winfx/2006/xaml\\"\\r\\n        xmlns:d=\\"http://schemas.microsoft.com/expression/blend/2008\\"\\r\\n        xmlns:mc=\\"http://schemas.openxmlformats.org/markup-compatibility/2006\\"\\r\\n        xmlns:local=\\"clr-namespace:DotNetCoreWPF\\"\\r\\n        mc:Ignorable=\\"d\\"\\r\\n        Title=\\"MainWindow\\" Height=\\"450\\" Width=\\"800\\">\\r\\n    <Grid>\\r\\n        <TextBox FontSize=\\"20\\" HorizontalAlignment=\\"Center\\" Name=\\"TimeTextBox\\" Text=\\"\\" TextWrapping=\\"Wrap\\" TextAlignment=\\"Center\\" VerticalAlignment=\\"Center\\" Height=\\"30\\" Width=\\"228\\"/>\\r\\n\\r\\n    </Grid>\\r\\n</Window>\\r\\n```\\r\\n\\r\\n真ん中にテキストを表示する`TextBox`を置いただけです。  \\r\\n\\r\\n## C#\\r\\n**MainWindow.cs**\\r\\n上の`using`は省略してるので気をつけて\\r\\n```cs\\r\\nnamespace DotNetCoreWPF\\r\\n{\\r\\n    /// <summary>\\r\\n    /// Interaction logic for MainWindow.xaml\\r\\n    /// </summary>\\r\\n    public partial class MainWindow : Window\\r\\n    {\\r\\n        public MainWindow()\\r\\n        {\\r\\n            InitializeComponent();\\r\\n\\r\\n            // タイマー初期化\\r\\n            var dispatcherTimer = new DispatcherTimer();\\r\\n            dispatcherTimer.Tick += new EventHandler(dispatcherTimer_Tick);\\r\\n            dispatcherTimer.Interval = new TimeSpan(0, 0, 1);\\r\\n            dispatcherTimer.Start();\\r\\n\\r\\n        }\\r\\n\\r\\n        // タイマーで毎秒ここ呼ばれる。\\r\\n        private void dispatcherTimer_Tick(object sender, EventArgs e)\\r\\n        {\\r\\n            // 時間を表示\\r\\n            TimeTextBox.Text = DateTime.Now.ToString();\\r\\n        }\\r\\n\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\nこれでデジタル時計の完成です。はっっや\\r\\n\\r\\n![Imgur](https://imgur.com/ZmZzxBb.png)\\r\\n\\r\\n# exeにする\\r\\n`.NET Framework`時代ではどうやってexeを配布してたのかよくわかりませんが、  \\r\\n`.NET Core`では**自己完結型**が使えるそうです。（.NET Frameworkじゃできない？）  \\r\\n## 自己完結型 #とは\\r\\n必要なもの全部を一つの`exeファイル`にできる機能。  \\r\\nちょっと前だとWindowsのフリーソフトを入れる際に、**.NET Framework のバージョンなんとか以上が必要**みたいなやつがよくありましたが、  \\r\\n`.NET Core（正確には3.0から）`では.NET Core（.NET Frameworkの後継）が入っていないPCでも実行できるように、.NET Coreのランタイムやらなんやらを一つのexeにいれて環境に関係なく動くようになるらしい。  \\r\\n変わりにファイルサイズが大きくなるけど。  \\r\\n\\r\\n今回は`.NET Core ランタイム入り（.NET Core入ってないPCでも動くやつ）`と`.NET Coreのランタイム無し`の両方をやろうと思います。\\r\\n\\r\\n## ソリューションエクスプローラー開いて\\r\\n名前のところを押して**発行**を押します。\\r\\n\\r\\n![Imgur](https://imgur.com/xjXxEdu.png)\\r\\n\\r\\n**フォルダー**を選んで次へ\\r\\n\\r\\n![Imgur](https://imgur.com/WBZdhUB.png)\\r\\n\\r\\nそのまま**完了**押して良いと思います。\\r\\n\\r\\n![Imgur](https://imgur.com/gZPdL5D.png)\\r\\n\\r\\nそしたら後ろのVS 2019の内容が画像のように変わるので、**構成**のところの鉛筆マークを押します。\\r\\n\\r\\n![Imgur](https://imgur.com/dGv9U3Z.png)\\r\\n\\r\\nそしてこの先は作りたいexeファイルによって操作が変わります。\\r\\n\\r\\n# .NET Core ランタイム入りのexeファイルを作成する\\r\\n\\r\\nプロファイル設定で、**配置モード**を**自己完結**にします。  \\r\\nそれから、下の**ファイルの公開オプション**を押して、**単一ファイルの作成**にチェックを入れます。\\r\\n\\r\\n![Imgur](https://imgur.com/ARUKDNH.png)\\r\\n\\r\\nそしたら保存して、**発行**ボタンを押せば作成されます。\\r\\n作成された`exeファイル`は`bin/Release/netcoreapp3.1/publish`の中にあると思います。\\r\\n\\r\\n実際に起動してみたの図。これだけなのにファイルサイズでけえ。\\r\\n![Imgur](https://imgur.com/hN2DDg4.png)\\r\\n\\r\\n# .NET Core ランタイム無しのexeファイルを作成する\\r\\n\\r\\nプロファイル設定で、**配置モード**を**フレームワーク依存**にします。  \\r\\nそれから、下の**ファイルの公開オプション**を押して、**単一ファイルの作成**にチェックを入れます。\\r\\n\\r\\n![Imgur](https://imgur.com/sRKKtZN.png)\\r\\n\\r\\nそしたら保存して、**発行**ボタンを押せば作成されます。\\r\\n作成された`exeファイル`は`bin/Release/netcoreapp3.1/publish`の中にあると思います。\\r\\n\\r\\n\\r\\n実際に起動してみたの図。ファイルサイズは小さい。\\r\\n\\r\\n![Imgur](https://imgur.com/byF4X4v.png)\\r\\n\\r\\n\\r\\n# おわりに\\r\\nこれで正解なのかはよく分かっていない。 \\r\\n\\r\\nというかなんで`TextBox`使ったの？`TextBlock`で良かったじゃん。\\r\\n\\r\\n一応ソースコード置いときますね→ https://github.com/takusan23/DotNetCoreWPF\\r\\n\\r\\nあと少しずれるんだけど、画像を入れても何故かコケる問題。画像を右クリックしてプロパティ選んで、ビルドアクションをリソースにすればいいのね。時間奪われた。\\r\\n\\r\\n# 参考にしました\\r\\nありがとうございます\\r\\n\\r\\n\\r\\nhttps://www.telerik.com/blogs/creating-a-single-exe-application-with-net-core\\r\\n\\r\\nhttps://techinfoofmicrosofttech.osscons.jp/index.php?.NET%20Core%E3%81%AE%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\\r\\n\\r\\nhttps://rksoftware.hatenablog.com/entry/2019/02/17/194701","bodyHtml":"<p>.NET Coreってなに</p>\\n<h1>ほんだい</h1>\\n<p>WPFなんてめったに触らんから未来の私がWPFやる時に見に来る記事。<br>\\n<a href=\\"../../posts/mousecursor_wpf/\\">WPFアプリ作ったので</a>その時に躓いたこ</p>\\n<h1>環境</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>なまえ</th>\\n<th>あたい</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>OS</td>\\n<td>Windows 10 Pro 2004</td>\\n</tr>\\n<tr>\\n<td>Visual Studio</td>\\n<td>Community 2019</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>.NET Coreってなに</h1>\\n<p>しらない。なんかよくわからんけど使う。<br>\\n.NET Coreはクロスプラットフォームって言われてるけど、WPFに関してはWindowsに依存してるから関係ないよ</p>\\n<p><a href=\\"https://docs.microsoft.com/ja-jp/windows/apps/desktop/modernize/modernize-wpf-tutorial\\">ソース</a></p>\\n<h1>Visual Studio 2019 入れる</h1>\\n<p>最新版入れましょう。最新版じゃないと<code>WPF App (.NET Core)</code>が選べないと思います。<br>\\nちなみに私は最新版にアップデートする際、ダウンロードするファイルが3GBを超えてました。クソ長かったわ。</p>\\n<h1>プロジェクト作成</h1>\\n<p>検索ボックスに<code>wpf</code>って入れれば出ます。<br>\\n<code>.NET Framework</code>じゃないほうを選びましょうね。\\n<img src=\\"https://imgur.com/BHxIloY.png\\" alt=\\"Imgur\\"></p>\\n<p>その後の<code>プロジェクト名</code>とかは各自決めてね。</p>\\n<h1>ぷよぐらみんぐ</h1>\\n<p>久々のC#くんです。<br>\\n（多分）Androidと同じ感じで、xamlでレイアウト決めて、C#でプログラムを書いていく感じですが、ちょっと違うのね。</p>\\n<ul>\\n<li>Androidの<code>findViewById</code>\\n<ul>\\n<li>C#ではレイアウトに<code>Name</code>付けとけばC#から扱える。</li>\\n<li>KotlinでfindViewByIdが省略できるみたいな感じで書ける。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>レイアウト</h2>\\n<p><strong>MainWindow.xaml</strong></p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">Window</span> <span class=\\"hljs-attr\\">x:Class</span>=<span class=\\"hljs-string\\">\\"DotNetCoreWPF.MainWindow\\"</span>\\n        <span class=\\"hljs-attr\\">xmlns</span>=<span class=\\"hljs-string\\">\\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\\"</span>\\n        <span class=\\"hljs-attr\\">xmlns:x</span>=<span class=\\"hljs-string\\">\\"http://schemas.microsoft.com/winfx/2006/xaml\\"</span>\\n        <span class=\\"hljs-attr\\">xmlns:d</span>=<span class=\\"hljs-string\\">\\"http://schemas.microsoft.com/expression/blend/2008\\"</span>\\n        <span class=\\"hljs-attr\\">xmlns:mc</span>=<span class=\\"hljs-string\\">\\"http://schemas.openxmlformats.org/markup-compatibility/2006\\"</span>\\n        <span class=\\"hljs-attr\\">xmlns:local</span>=<span class=\\"hljs-string\\">\\"clr-namespace:DotNetCoreWPF\\"</span>\\n        <span class=\\"hljs-attr\\">mc:Ignorable</span>=<span class=\\"hljs-string\\">\\"d\\"</span>\\n        <span class=\\"hljs-attr\\">Title</span>=<span class=\\"hljs-string\\">\\"MainWindow\\"</span> <span class=\\"hljs-attr\\">Height</span>=<span class=\\"hljs-string\\">\\"450\\"</span> <span class=\\"hljs-attr\\">Width</span>=<span class=\\"hljs-string\\">\\"800\\"</span>&gt;</span>\\n    <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">Grid</span>&gt;</span>\\n        <span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">TextBox</span> <span class=\\"hljs-attr\\">FontSize</span>=<span class=\\"hljs-string\\">\\"20\\"</span> <span class=\\"hljs-attr\\">HorizontalAlignment</span>=<span class=\\"hljs-string\\">\\"Center\\"</span> <span class=\\"hljs-attr\\">Name</span>=<span class=\\"hljs-string\\">\\"TimeTextBox\\"</span> <span class=\\"hljs-attr\\">Text</span>=<span class=\\"hljs-string\\">\\"\\"</span> <span class=\\"hljs-attr\\">TextWrapping</span>=<span class=\\"hljs-string\\">\\"Wrap\\"</span> <span class=\\"hljs-attr\\">TextAlignment</span>=<span class=\\"hljs-string\\">\\"Center\\"</span> <span class=\\"hljs-attr\\">VerticalAlignment</span>=<span class=\\"hljs-string\\">\\"Center\\"</span> <span class=\\"hljs-attr\\">Height</span>=<span class=\\"hljs-string\\">\\"30\\"</span> <span class=\\"hljs-attr\\">Width</span>=<span class=\\"hljs-string\\">\\"228\\"</span>/&gt;</span>\\n\\n    <span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">Grid</span>&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">Window</span>&gt;</span></code></pre><p>真ん中にテキストを表示する<code>TextBox</code>を置いただけです。</p>\\n<h2>C#</h2>\\n<p><strong>MainWindow.cs</strong>\\n上の<code>using</code>は省略してるので気をつけて</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">namespace</span> <span class=\\"hljs-title\\">DotNetCoreWPF</span>\\n{\\n    <span class=\\"hljs-comment\\"><span class=\\"hljs-doctag\\">///</span> <span class=\\"hljs-doctag\\">&lt;summary&gt;</span></span>\\n    <span class=\\"hljs-comment\\"><span class=\\"hljs-doctag\\">///</span> Interaction logic for MainWindow.xaml</span>\\n    <span class=\\"hljs-comment\\"><span class=\\"hljs-doctag\\">///</span> <span class=\\"hljs-doctag\\">&lt;/summary&gt;</span></span>\\n    <span class=\\"hljs-keyword\\">public</span> <span class=\\"hljs-keyword\\">partial</span> <span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">MainWindow</span> : <span class=\\"hljs-title\\">Window</span>\\n    {\\n        <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">public</span> <span class=\\"hljs-title\\">MainWindow</span>(<span class=\\"hljs-params\\"></span>)</span>\\n        {\\n            InitializeComponent();\\n\\n            <span class=\\"hljs-comment\\">// タイマー初期化</span>\\n            <span class=\\"hljs-keyword\\">var</span> dispatcherTimer = <span class=\\"hljs-keyword\\">new</span> DispatcherTimer();\\n            dispatcherTimer.Tick += <span class=\\"hljs-keyword\\">new</span> EventHandler(dispatcherTimer_Tick);\\n            dispatcherTimer.Interval = <span class=\\"hljs-keyword\\">new</span> TimeSpan(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>);\\n            dispatcherTimer.Start();\\n\\n        }\\n\\n        <span class=\\"hljs-comment\\">// タイマーで毎秒ここ呼ばれる。</span>\\n        <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">private</span> <span class=\\"hljs-keyword\\">void</span> <span class=\\"hljs-title\\">dispatcherTimer_Tick</span>(<span class=\\"hljs-params\\"><span class=\\"hljs-keyword\\">object</span> sender, EventArgs e</span>)</span>\\n        {\\n            <span class=\\"hljs-comment\\">// 時間を表示</span>\\n            TimeTextBox.Text = DateTime.Now.ToString();\\n        }\\n\\n    }\\n}</code></pre><p>これでデジタル時計の完成です。はっっや</p>\\n<p><img src=\\"https://imgur.com/ZmZzxBb.png\\" alt=\\"Imgur\\"></p>\\n<h1>exeにする</h1>\\n<p><code>.NET Framework</code>時代ではどうやってexeを配布してたのかよくわかりませんが、<br>\\n<code>.NET Core</code>では<strong>自己完結型</strong>が使えるそうです。（.NET Frameworkじゃできない？）</p>\\n<h2>自己完結型 #とは</h2>\\n<p>必要なもの全部を一つの<code>exeファイル</code>にできる機能。<br>\\nちょっと前だとWindowsのフリーソフトを入れる際に、<strong>.NET Framework のバージョンなんとか以上が必要</strong>みたいなやつがよくありましたが、<br>\\n<code>.NET Core（正確には3.0から）</code><a href=\\"http://xn--n9jq.NET\\">では.NET</a> Core（.NET Frameworkの後継）が入っていないPCでも実行できるように、.NET Coreのランタイムやらなんやらを一つのexeにいれて環境に関係なく動くようになるらしい。<br>\\n変わりにファイルサイズが大きくなるけど。</p>\\n<p>今回は<code>.NET Core ランタイム入り（.NET Core入ってないPCでも動くやつ）</code>と<code>.NET Coreのランタイム無し</code>の両方をやろうと思います。</p>\\n<h2>ソリューションエクスプローラー開いて</h2>\\n<p>名前のところを押して<strong>発行</strong>を押します。</p>\\n<p><img src=\\"https://imgur.com/xjXxEdu.png\\" alt=\\"Imgur\\"></p>\\n<p><strong>フォルダー</strong>を選んで次へ</p>\\n<p><img src=\\"https://imgur.com/WBZdhUB.png\\" alt=\\"Imgur\\"></p>\\n<p>そのまま<strong>完了</strong>押して良いと思います。</p>\\n<p><img src=\\"https://imgur.com/gZPdL5D.png\\" alt=\\"Imgur\\"></p>\\n<p>そしたら後ろのVS 2019の内容が画像のように変わるので、<strong>構成</strong>のところの鉛筆マークを押します。</p>\\n<p><img src=\\"https://imgur.com/dGv9U3Z.png\\" alt=\\"Imgur\\"></p>\\n<p>そしてこの先は作りたいexeファイルによって操作が変わります。</p>\\n<h1>.NET Core ランタイム入りのexeファイルを作成する</h1>\\n<p>プロファイル設定で、<strong>配置モード</strong>を<strong>自己完結</strong>にします。<br>\\nそれから、下の<strong>ファイルの公開オプション</strong>を押して、<strong>単一ファイルの作成</strong>にチェックを入れます。</p>\\n<p><img src=\\"https://imgur.com/ARUKDNH.png\\" alt=\\"Imgur\\"></p>\\n<p>そしたら保存して、<strong>発行</strong>ボタンを押せば作成されます。\\n作成された<code>exeファイル</code>は<code>bin/Release/netcoreapp3.1/publish</code>の中にあると思います。</p>\\n<p>実際に起動してみたの図。これだけなのにファイルサイズでけえ。\\n<img src=\\"https://imgur.com/hN2DDg4.png\\" alt=\\"Imgur\\"></p>\\n<h1>.NET Core ランタイム無しのexeファイルを作成する</h1>\\n<p>プロファイル設定で、<strong>配置モード</strong>を<strong>フレームワーク依存</strong>にします。<br>\\nそれから、下の<strong>ファイルの公開オプション</strong>を押して、<strong>単一ファイルの作成</strong>にチェックを入れます。</p>\\n<p><img src=\\"https://imgur.com/sRKKtZN.png\\" alt=\\"Imgur\\"></p>\\n<p>そしたら保存して、<strong>発行</strong>ボタンを押せば作成されます。\\n作成された<code>exeファイル</code>は<code>bin/Release/netcoreapp3.1/publish</code>の中にあると思います。</p>\\n<p>実際に起動してみたの図。ファイルサイズは小さい。</p>\\n<p><img src=\\"https://imgur.com/byF4X4v.png\\" alt=\\"Imgur\\"></p>\\n<h1>おわりに</h1>\\n<p>これで正解なのかはよく分かっていない。</p>\\n<p>というかなんで<code>TextBox</code>使ったの？<code>TextBlock</code>で良かったじゃん。</p>\\n<p>一応ソースコード置いときますね→ <a href=\\"https://github.com/takusan23/DotNetCoreWPF\\">https://github.com/takusan23/DotNetCoreWPF</a></p>\\n<p>あと少しずれるんだけど、画像を入れても何故かコケる問題。画像を右クリックしてプロパティ選んで、ビルドアクションをリソースにすればいいのね。時間奪われた。</p>\\n<h1>参考にしました</h1>\\n<p>ありがとうございます</p>\\n<p><a href=\\"https://www.telerik.com/blogs/creating-a-single-exe-application-with-net-core\\">https://www.telerik.com/blogs/creating-a-single-exe-application-with-net-core</a></p>\\n<p><a href=\\"https://techinfoofmicrosofttech.osscons.jp/index.php?.NET%20Core%E3%81%AE%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4\\">https://techinfoofmicrosofttech.osscons.jp/index.php?.NET Coreのデプロイ</a></p>\\n<p><a href=\\"https://rksoftware.hatenablog.com/entry/2019/02/17/194701\\">https://rksoftware.hatenablog.com/entry/2019/02/17/194701</a></p>\\n","dir":"contents/posts/json","base":"dotnet_wpf.json","ext":".json","sourceBase":"dotnet_wpf.md","sourceExt":".md"}')},611:function(n){n.exports=JSON.parse('{"title":"Nuxt.jsとprocessmdでブログ作りたい。","created_at":"2020-05-30 21:10:00","tags":["NuxtJS","Markdown","JavaScript"],"bodyContent":"**Nuxt.js+processmd**でブログ作るよ\\r\\n\\r\\n# 環境\\r\\n| なまえ | あたい         |\\r\\n|--------|----------------|\\r\\n| OS     | Windows 10 Pro |\\r\\n| Node   | 12.14.1        |\\r\\n\\r\\n# Nuxt.jsプロジェクト作成\\r\\n\\r\\n```console\\r\\nnpx create-nuxt-app nuxtblog\\r\\n```\\r\\n\\r\\nあとは好きな方を選んでいきます\\r\\n- programming language\\r\\n    - TypeScriptにしといた（けどTS書き方分かんなくて途中からJSになってる。クソ参考にならねえじゃん）\\r\\n- UI framework\\r\\n    - Vuetifyがマテリアルデザイン（今回はElement使ってみる）\\r\\n- あとは適当に（PWA入れといた）\\r\\n\\r\\n```console\\r\\n✨  Generating Nuxt.js project in nuxtblog\\r\\n? Project name nuxtblog\\r\\n? Project description My cool Nuxt.js project\\r\\n? Author name takusan23\\r\\n? Choose programming language TypeScript     \\r\\n? Choose the package manager Npm      \\r\\n? Choose UI framework Element\\r\\n? Choose custom server framework None (Recommended) \\r\\n? Choose the runtime for TypeScript Default\\r\\n? Choose Nuxt.js modules Progressive Web App (PWA) Support\\r\\n? Choose linting tools (Press <space> to select, <a> to toggle all, <i> to invert selection)\\r\\n? Choose test framework None\\r\\n? Choose rendering mode Single Page App\\r\\n? Choose development tools (Press <space> to select, <a> to toggle all, <i> to invert selection)\\r\\n```\\r\\n\\r\\nそしたら移動して、サーバー起動させます\\r\\n\\r\\n```console\\r\\ncd nuxt blog\\r\\nnpm run dev\\r\\n```\\r\\n\\r\\n![Imgur](https://i.imgur.com/fsdnyw3.png)\\r\\n\\r\\n# Markdownファイルの保存場所を作る\\r\\n\\r\\nnuxtblogフォルダ(componentsとかassetsとかnode_moduleがあるフォルダ)に  \\r\\n**contentsフォルダ**を作り、その中に  \\r\\n**postsフォルダ**を作り、その中に  \\r\\n**markdownフォルダ**を作成します。\\r\\n\\r\\nこんな感じに\\r\\n\\r\\n![Imgur](https://i.imgur.com/9MkedEP.png)\\r\\n\\r\\n後は**Markdownフォルダ**にMarkdownファイルを置いていきます。  \\r\\n\\r\\n今回は適当にこんなMarkdownファイル（名前：first.md）を入れます。\\r\\n\\r\\n```markdown\\r\\n---\\r\\ntitle: Nuxt.jsの練習\\r\\ncreated_at: 2020-05-31\\r\\ntags:\\r\\n- JavaScript\\r\\n---\\r\\n# Hello World\\r\\n\\r\\n```\\r\\n\\r\\n# Markdownファイルの情報をJSONに変換するprocessmd\\r\\n\\r\\n## processmd入れます\\r\\n\\r\\n\\r\\n```console\\r\\nnpm install --save-dev processmd\\r\\n```\\r\\n\\r\\n## コマンド長いのでpackage.jsonに書き足します\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\"name\\": \\"nuxtblog\\",\\r\\n  \\"version\\": \\"1.0.0\\",\\r\\n  \\"description\\": \\"My cool Nuxt.js project\\",\\r\\n  \\"author\\": \\"takusan23\\",\\r\\n  \\"private\\": true,\\r\\n  \\"scripts\\": {\\r\\n    \\"dev\\": \\"nuxt\\",\\r\\n    \\"build\\": \\"nuxt build\\",\\r\\n    \\"start\\": \\"nuxt start\\",\\r\\n    \\"generate\\": \\"nuxt generate\\",\\r\\n    \\"md\\": \\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json\\"\\r\\n  },\\r\\n  \\"dependencies\\": {\\r\\n    \\"nuxt\\": \\"^2.0.0\\",\\r\\n    \\"element-ui\\": \\"^2.4.11\\",\\r\\n    \\"@nuxtjs/pwa\\": \\"^3.0.0-0\\"\\r\\n  },\\r\\n  \\"devDependencies\\": {\\r\\n    \\"@nuxt/typescript-build\\": \\"^0.6.0\\",\\r\\n    \\"processmd\\": \\"^4.5.0\\"\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\nscriptsの中にmdの一行書き足せばおｋ\\r\\n```json\\r\\n\\"md\\": \\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json\\"\\r\\n```\\r\\n\\r\\nあとはターミナルで以下叩きます。  \\r\\nこの作業は記事を追加したら毎回叩く必要があります。\\r\\n```console\\r\\nnpm run md\\r\\n```\\r\\n\\r\\n叩くとcontents/postsにjsonってフォルダが出来てると思います。あとsummary.jsonも\\r\\n\\r\\n# Nuxt.jsで記事一覧用意する\\r\\n\\r\\nこっからはコピペです。いくぞおおおおお  \\r\\n**pages/index.vue**を開いて以下のJSをどーん\\r\\n```vue\\r\\n<template>\\r\\n  <div class=\\"container\\">\\r\\n    <div>\\r\\n      <el-card class=\\"box-card\\" v-for=\\"item in blogItems\\" :key=\\"item\\">\\r\\n        <nuxt-link class=\\"text item\\" :to=\\"`posts/${item.fileName}`\\">{{ item.title }}</nuxt-link>\\r\\n      </el-card>\\r\\n    </div>\\r\\n  </div>\\r\\n</template>\\r\\n\\r\\n<script lang=\\"js\\">\\r\\nimport Vue from \'vue\'\\r\\nimport { fileMap } from \\"../contents/posts/summary.json\\";\\r\\n\\r\\nexport default {\\r\\n  data: () => {\\r\\n    return {\\r\\n      blogItems: []\\r\\n    };\\r\\n  },\\r\\n  created() {\\r\\n    // キーを取り出す\\r\\n    Object.keys(fileMap).forEach(title => {\\r\\n      // 記事一個ずつ取る\\r\\n      const blog = fileMap[title];\\r\\n      // 名前\\r\\n      const name = blog.sourceBase.replace(\\".md\\", \\"\\");\\r\\n      blog.fileName = name;\\r\\n      this.blogItems.push(blog);\\r\\n    });\\r\\n  }\\r\\n};\\r\\n<\/script>\\r\\n```\\r\\n\\r\\nここではタイトルしか出てませんが、日付とかタグとかも出せると思います。\\r\\n\\r\\n![Imgur](https://i.imgur.com/LJF3l5H.png)\\r\\n\\r\\n> localhost:4545は別に気にしないでいいです。だた調子が悪かったのでポート番号を変えただけです。（nuxt --port 4545で変えられる）\\r\\n\\r\\n# 記事一覧ページを作る\\r\\n\\r\\n## 動的ルーティング # とは\\r\\nよくわからんけど静的サイトジェネレートに必要。  \\r\\nというわけで**nuxt.config.js**開いてね\\r\\n\\r\\n参考：https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2/\\r\\n参考：https://isoppp.com/note/2018-05-16/3-nuxt-firebase-blog-markdown/\\r\\n\\r\\n開いたらJS書き足していきます。\\r\\n\\r\\n```js\\r\\nconst { sourceFileArray } = require(\'./contents/posts/summary.json\');\\r\\n\\r\\n/** パス生成 */\\r\\nconst sourceFileNameToUrl = filepath => {\\r\\n  const name = filepath.replace(\'contents/posts/markdown/\', \'\').replace(\'.md\', \'\')\\r\\n  return `/posts/${name}`\\r\\n}\\r\\n\\r\\nconst generateDynamicRoutes = callback => {\\r\\n  const routes = sourceFileArray.map(sourceFileName => {\\r\\n    return sourceFileNameToUrl(sourceFileName);\\r\\n  });\\r\\n  callback(null, routes);\\r\\n};\\r\\n\\r\\nexport default {\\r\\n// 省略\\r\\n  generate: {\\r\\n    routes: generateDynamicRoutes\\r\\n  },\\r\\n}\\r\\n```\\r\\n\\r\\nsourceFileNameToUrl()関数は`posts/${ファイル名}`の文字列を返す関数です。\\r\\n\\r\\nこうすることでURLが`posts/{タイトル}`になるはずです。  \\r\\nですがこれだけではまだ生成できません。\\r\\n\\r\\n生成するには、  \\r\\n**pagesフォルダ**に**posts**フォルダを作成して、  \\r\\nその中に **_slug.vue** ファイルを作成します。\\r\\n\\r\\n![Imgur](https://imgur.com/DSJ9WSc.png)\\r\\n\\r\\n## _slug.vueの中身\\r\\n**_slug.vue**は記事の表示に使います。  \\r\\n\\r\\n```vue\\r\\n<template>\\r\\n  <div class=\\"container\\">\\r\\n    <div>\\r\\n      <el-card class=\\"box-card\\">\\r\\n        <div>{{(new Date(created_at).toLocaleDateString())}} 投稿</div>\\r\\n        <div v-html=\\"bodyHtml\\"></div>\\r\\n      </el-card>\\r\\n    </div>\\r\\n  </div>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport { sourceFileArray } from \\"../../contents/posts/summary.json\\";\\r\\n\\r\\nexport default {\\r\\n  // 記事があるかどうか。JSONのsourceFileArrayの配列に含まれているか確認している。\\r\\n  validate({ params }) {\\r\\n    return sourceFileArray.includes(\\r\\n      `contents/posts/markdown/${params.slug}.md`\\r\\n    );\\r\\n  },\\r\\n  // 各記事のJSONファイルを読み込んでる。\\r\\n  asyncData({ params }) {\\r\\n    return Object.assign(\\r\\n      {},\\r\\n      require(`~/contents/posts/json/${params.slug}.json`),\\r\\n      { params }\\r\\n    );\\r\\n  },\\r\\n  mounted() {\\r\\n    // DOM生成後\\r\\n  },\\r\\n  // さあ？\\r\\n  head() {\\r\\n    const title = `${this.title}`;\\r\\n    const url = `posts/${this.params.slug}/`;\\r\\n    return {\\r\\n      title: title,\\r\\n      meta: [\\r\\n        { hid: \\"og:url\\", property: \\"og:url\\", content: url },\\r\\n        { hid: \\"og:title\\", property: \\"og:title\\", content: title }\\r\\n      ],\\r\\n      link: [{ rel: \\"canonical\\", href: url }]\\r\\n    };\\r\\n  }\\r\\n};\\r\\n<\/script>\\r\\n```\\r\\n\\r\\n記事一覧から選んだ時にちゃんとMarkdownの中身が表示されていれば動いてます。\\r\\n\\r\\n![Imgur](https://i.imgur.com/qbUf0P4.png)\\r\\n\\r\\n# おまけ 静的サイトジェネレートしてみる\\r\\n\\r\\n以下の一行をターミナルに入れます\\r\\n\\r\\n```console\\r\\nnpm run generate\\r\\n```\\r\\n\\r\\nこれで静的サイトが生成されました。後はこれをGitHubPagesに上げるなりすればいいと思います。  \\r\\n今回は**Web Server for Chrome**が入ってたのでそれ使って見てみます。  \\r\\n\\r\\n`npm run generate`の出力先は**dist**になってるのでそれを指定してWeb鯖立てます。\\r\\n\\r\\n![Imgur](https://i.imgur.com/O6uBFod.png)\\r\\n\\r\\n以上です。  \\r\\n一応/posts/first/にアクセスした後にF5（再読み込み）をかけても404にならないことを確認できたところで終わろうと思います。\\r\\n\\r\\n![Imgur](https://i.imgur.com/74quEU3.png)\\r\\n\\r\\nPWAも入れてあるので試せる。\\r\\n\\r\\n# おまけ\\r\\nGitHub Pages使う場合は、nuxt.config.jsをこんな感じにすればいいと思います。\\r\\n\\r\\n```js\\r\\nexport default {\\r\\n// 省略\\r\\n  router: {\\r\\n    base: \'/リポジトリ名/\'\\r\\n  },\\r\\n  generate: {\\r\\n    routes: generateDynamicRoutes,\\r\\n    dir: \'docs\',\\r\\n  },\\r\\n}\\r\\n```\\r\\n\\r\\n# おわりに\\r\\n**nuxt.config.js**の`mode: \'spa\'`ってSPAであってるの？\\r\\n静的サイトジェネレートの時は書いてなかったんだけど？\\r\\n\\r\\nソースコード：https://github.com/takusan23/NuxtBlog","bodyHtml":"<p><strong>Nuxt.js+processmd</strong>でブログ作るよ</p>\\n<h1>環境</h1>\\n<table>\\n<thead>\\n<tr>\\n<th>なまえ</th>\\n<th>あたい</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>OS</td>\\n<td>Windows 10 Pro</td>\\n</tr>\\n<tr>\\n<td>Node</td>\\n<td>12.14.1</td>\\n</tr>\\n</tbody>\\n</table>\\n<h1>Nuxt.jsプロジェクト作成</h1>\\n<pre><code class=\\"hljs\\">npx create-nuxt-app nuxtblog</code></pre><p>あとは好きな方を選んでいきます</p>\\n<ul>\\n<li>programming language\\n<ul>\\n<li>TypeScriptにしといた（けどTS書き方分かんなくて途中からJSになってる。クソ参考にならねえじゃん）</li>\\n</ul>\\n</li>\\n<li>UI framework\\n<ul>\\n<li>Vuetifyがマテリアルデザイン（今回はElement使ってみる）</li>\\n</ul>\\n</li>\\n<li>あとは適当に（PWA入れといた）</li>\\n</ul>\\n<pre><code class=\\"hljs\\">✨  Generating Nuxt.js project in nuxtblog\\n? Project name nuxtblog\\n? Project description My cool Nuxt.js project\\n? Author name takusan23\\n? Choose programming language TypeScript     \\n? Choose the package manager Npm      \\n? Choose UI framework Element\\n? Choose custom server framework None (Recommended) \\n? Choose the runtime for TypeScript Default\\n? Choose Nuxt.js modules Progressive Web App (PWA) Support\\n? Choose linting tools (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)\\n? Choose test framework None\\n? Choose rendering mode Single Page App\\n? Choose development tools (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</code></pre><p>そしたら移動して、サーバー起動させます</p>\\n<pre><code class=\\"hljs\\">cd nuxt blog\\nnpm run dev</code></pre><p><img src=\\"https://i.imgur.com/fsdnyw3.png\\" alt=\\"Imgur\\"></p>\\n<h1>Markdownファイルの保存場所を作る</h1>\\n<p>nuxtblogフォルダ(componentsとかassetsとかnode_moduleがあるフォルダ)に<br>\\n<strong>contentsフォルダ</strong>を作り、その中に<br>\\n<strong>postsフォルダ</strong>を作り、その中に<br>\\n<strong>markdownフォルダ</strong>を作成します。</p>\\n<p>こんな感じに</p>\\n<p><img src=\\"https://i.imgur.com/9MkedEP.png\\" alt=\\"Imgur\\"></p>\\n<p>後は<strong>Markdownフォルダ</strong>にMarkdownファイルを置いていきます。</p>\\n<p>今回は適当にこんなMarkdownファイル（名前：<a href=\\"http://first.md\\">first.md</a>）を入れます。</p>\\n<pre><code class=\\"hljs\\">---\\ntitle: Nuxt.jsの練習\\ncreated_at: 2020-05-31\\ntags:\\n<span class=\\"hljs-section\\">- JavaScript\\n---</span>\\n<span class=\\"hljs-section\\"># Hello World</span></code></pre><h1>Markdownファイルの情報をJSONに変換するprocessmd</h1>\\n<h2>processmd入れます</h2>\\n<pre><code class=\\"hljs\\">npm install --save-dev processmd</code></pre><h2>コマンド長いのでpackage.jsonに書き足します</h2>\\n<pre><code class=\\"hljs\\">{\\n  <span class=\\"hljs-attr\\">\\"name\\"</span>: <span class=\\"hljs-string\\">\\"nuxtblog\\"</span>,\\n  <span class=\\"hljs-attr\\">\\"version\\"</span>: <span class=\\"hljs-string\\">\\"1.0.0\\"</span>,\\n  <span class=\\"hljs-attr\\">\\"description\\"</span>: <span class=\\"hljs-string\\">\\"My cool Nuxt.js project\\"</span>,\\n  <span class=\\"hljs-attr\\">\\"author\\"</span>: <span class=\\"hljs-string\\">\\"takusan23\\"</span>,\\n  <span class=\\"hljs-attr\\">\\"private\\"</span>: <span class=\\"hljs-literal\\">true</span>,\\n  <span class=\\"hljs-attr\\">\\"scripts\\"</span>: {\\n    <span class=\\"hljs-attr\\">\\"dev\\"</span>: <span class=\\"hljs-string\\">\\"nuxt\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"build\\"</span>: <span class=\\"hljs-string\\">\\"nuxt build\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"start\\"</span>: <span class=\\"hljs-string\\">\\"nuxt start\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"generate\\"</span>: <span class=\\"hljs-string\\">\\"nuxt generate\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"md\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json &gt; contents/posts/summary.json\\"</span>\\n  },\\n  <span class=\\"hljs-attr\\">\\"dependencies\\"</span>: {\\n    <span class=\\"hljs-attr\\">\\"nuxt\\"</span>: <span class=\\"hljs-string\\">\\"^2.0.0\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"element-ui\\"</span>: <span class=\\"hljs-string\\">\\"^2.4.11\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"@nuxtjs/pwa\\"</span>: <span class=\\"hljs-string\\">\\"^3.0.0-0\\"</span>\\n  },\\n  <span class=\\"hljs-attr\\">\\"devDependencies\\"</span>: {\\n    <span class=\\"hljs-attr\\">\\"@nuxt/typescript-build\\"</span>: <span class=\\"hljs-string\\">\\"^0.6.0\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"processmd\\"</span>: <span class=\\"hljs-string\\">\\"^4.5.0\\"</span>\\n  }\\n}</code></pre><p>scriptsの中にmdの一行書き足せばおｋ</p>\\n<pre><code class=\\"hljs\\">\\"md\\": \\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json &gt; contents/posts/summary.json\\"</code></pre><p>あとはターミナルで以下叩きます。<br>\\nこの作業は記事を追加したら毎回叩く必要があります。</p>\\n<pre><code class=\\"hljs\\">npm run md</code></pre><p>叩くとcontents/postsにjsonってフォルダが出来てると思います。あとsummary.jsonも</p>\\n<h1>Nuxt.jsで記事一覧用意する</h1>\\n<p>こっからはコピペです。いくぞおおおおお<br>\\n<strong>pages/index.vue</strong>を開いて以下のJSをどーん</p>\\n<pre><code class=\\"hljs\\">&lt;template&gt;\\n  &lt;div class=\\"container\\"&gt;\\n    &lt;div&gt;\\n      &lt;el-card class=\\"box-card\\" v-for=\\"item in blogItems\\" :key=\\"item\\"&gt;\\n        &lt;nuxt-link class=\\"text item\\" :to=\\"`posts/${item.fileName}`\\"&gt;{{ item.title }}&lt;/nuxt-link&gt;\\n      &lt;/el-card&gt;\\n    &lt;/div&gt;\\n  &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script lang=\\"js\\"&gt;\\nimport Vue from \'vue\'\\nimport { fileMap } from \\"../contents/posts/summary.json\\";\\n\\nexport default {\\n  data: () =&gt; {\\n    return {\\n      blogItems: []\\n    };\\n  },\\n  created() {\\n    // キーを取り出す\\n    Object.keys(fileMap).forEach(title =&gt; {\\n      // 記事一個ずつ取る\\n      const blog = fileMap[title];\\n      // 名前\\n      const name = blog.sourceBase.replace(\\".md\\", \\"\\");\\n      blog.fileName = name;\\n      this.blogItems.push(blog);\\n    });\\n  }\\n};\\n&lt;/script&gt;</code></pre><p>ここではタイトルしか出てませんが、日付とかタグとかも出せると思います。</p>\\n<p><img src=\\"https://i.imgur.com/LJF3l5H.png\\" alt=\\"Imgur\\"></p>\\n<blockquote>\\n<p>localhost:4545は別に気にしないでいいです。だた調子が悪かったのでポート番号を変えただけです。（nuxt --port 4545で変えられる）</p>\\n</blockquote>\\n<h1>記事一覧ページを作る</h1>\\n<h2>動的ルーティング # とは</h2>\\n<p>よくわからんけど静的サイトジェネレートに必要。<br>\\nというわけで<strong>nuxt.config.js</strong>開いてね</p>\\n<p>参考：<a href=\\"https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2/\\">https://jmblog.jp/posts/2018-01-18/build-a-blog-with-nuxtjs-and-markdown-2/</a>\\n参考：<a href=\\"https://isoppp.com/note/2018-05-16/3-nuxt-firebase-blog-markdown/\\">https://isoppp.com/note/2018-05-16/3-nuxt-firebase-blog-markdown/</a></p>\\n<p>開いたらJS書き足していきます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">const</span> { sourceFileArray } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">\'./contents/posts/summary.json\'</span>);\\n\\n<span class=\\"hljs-comment\\">/** パス生成 */</span>\\n<span class=\\"hljs-keyword\\">const</span> sourceFileNameToUrl = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">filepath</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> name = filepath.replace(<span class=\\"hljs-string\\">\'contents/posts/markdown/\'</span>, <span class=\\"hljs-string\\">\'\'</span>).replace(<span class=\\"hljs-string\\">\'.md\'</span>, <span class=\\"hljs-string\\">\'\'</span>)\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">`/posts/<span class=\\"hljs-subst\\">${name}</span>`</span>\\n}\\n\\n<span class=\\"hljs-keyword\\">const</span> generateDynamicRoutes = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">callback</span> =&gt;</span> {\\n  <span class=\\"hljs-keyword\\">const</span> routes = sourceFileArray.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">sourceFileName</span> =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">return</span> sourceFileNameToUrl(sourceFileName);\\n  });\\n  callback(<span class=\\"hljs-literal\\">null</span>, routes);\\n};\\n\\n<span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> {\\n<span class=\\"hljs-comment\\">// 省略</span>\\n  <span class=\\"hljs-attr\\">generate</span>: {\\n    <span class=\\"hljs-attr\\">routes</span>: generateDynamicRoutes\\n  },\\n}</code></pre><p>sourceFileNameToUrl()関数は<code>posts/${ファイル名}</code>の文字列を返す関数です。</p>\\n<p>こうすることでURLが<code>posts/{タイトル}</code>になるはずです。<br>\\nですがこれだけではまだ生成できません。</p>\\n<p>生成するには、<br>\\n<strong>pagesフォルダ</strong>に<strong>posts</strong>フォルダを作成して、<br>\\nその中に <strong>_slug.vue</strong> ファイルを作成します。</p>\\n<p><img src=\\"https://imgur.com/DSJ9WSc.png\\" alt=\\"Imgur\\"></p>\\n<h2>_slug.vueの中身</h2>\\n<p><strong>_slug.vue</strong>は記事の表示に使います。</p>\\n<pre><code class=\\"hljs\\">&lt;template&gt;\\n  &lt;div class=\\"container\\"&gt;\\n    &lt;div&gt;\\n      &lt;el-card class=\\"box-card\\"&gt;\\n        &lt;div&gt;{{(new Date(created_at).toLocaleDateString())}} 投稿&lt;/div&gt;\\n        &lt;div v-html=\\"bodyHtml\\"&gt;&lt;/div&gt;\\n      &lt;/el-card&gt;\\n    &lt;/div&gt;\\n  &lt;/div&gt;\\n&lt;/template&gt;\\n\\n&lt;script&gt;\\nimport { sourceFileArray } from \\"../../contents/posts/summary.json\\";\\n\\nexport default {\\n  // 記事があるかどうか。JSONのsourceFileArrayの配列に含まれているか確認している。\\n  validate({ params }) {\\n    return sourceFileArray.includes(\\n      `contents/posts/markdown/${params.slug}.md`\\n    );\\n  },\\n  // 各記事のJSONファイルを読み込んでる。\\n  asyncData({ params }) {\\n    return Object.assign(\\n      {},\\n      require(`~/contents/posts/json/${params.slug}.json`),\\n      { params }\\n    );\\n  },\\n  mounted() {\\n    // DOM生成後\\n  },\\n  // さあ？\\n  head() {\\n    const title = `${this.title}`;\\n    const url = `posts/${this.params.slug}/`;\\n    return {\\n      title: title,\\n      meta: [\\n        { hid: \\"og:url\\", property: \\"og:url\\", content: url },\\n        { hid: \\"og:title\\", property: \\"og:title\\", content: title }\\n      ],\\n      link: [{ rel: \\"canonical\\", href: url }]\\n    };\\n  }\\n};\\n&lt;/script&gt;</code></pre><p>記事一覧から選んだ時にちゃんとMarkdownの中身が表示されていれば動いてます。</p>\\n<p><img src=\\"https://i.imgur.com/qbUf0P4.png\\" alt=\\"Imgur\\"></p>\\n<h1>おまけ 静的サイトジェネレートしてみる</h1>\\n<p>以下の一行をターミナルに入れます</p>\\n<pre><code class=\\"hljs\\">npm run generate</code></pre><p>これで静的サイトが生成されました。後はこれをGitHubPagesに上げるなりすればいいと思います。<br>\\n今回は<strong>Web Server for Chrome</strong>が入ってたのでそれ使って見てみます。</p>\\n<p><code>npm run generate</code>の出力先は<strong>dist</strong>になってるのでそれを指定してWeb鯖立てます。</p>\\n<p><img src=\\"https://i.imgur.com/O6uBFod.png\\" alt=\\"Imgur\\"></p>\\n<p>以上です。<br>\\n一応/posts/first/にアクセスした後にF5（再読み込み）をかけても404にならないことを確認できたところで終わろうと思います。</p>\\n<p><img src=\\"https://i.imgur.com/74quEU3.png\\" alt=\\"Imgur\\"></p>\\n<p>PWAも入れてあるので試せる。</p>\\n<h1>おまけ</h1>\\n<p>GitHub Pages使う場合は、nuxt.config.jsをこんな感じにすればいいと思います。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> {\\n<span class=\\"hljs-comment\\">// 省略</span>\\n  <span class=\\"hljs-attr\\">router</span>: {\\n    <span class=\\"hljs-attr\\">base</span>: <span class=\\"hljs-string\\">\'/リポジトリ名/\'</span>\\n  },\\n  <span class=\\"hljs-attr\\">generate</span>: {\\n    <span class=\\"hljs-attr\\">routes</span>: generateDynamicRoutes,\\n    <span class=\\"hljs-attr\\">dir</span>: <span class=\\"hljs-string\\">\'docs\'</span>,\\n  },\\n}</code></pre><h1>おわりに</h1>\\n<p><strong>nuxt.config.js</strong>の<code>mode: \'spa\'</code>ってSPAであってるの？\\n静的サイトジェネレートの時は書いてなかったんだけど？</p>\\n<p>ソースコード：<a href=\\"https://github.com/takusan23/NuxtBlog\\">https://github.com/takusan23/NuxtBlog</a></p>\\n","dir":"contents/posts/json","base":"first.json","ext":".json","sourceBase":"first.md","sourceExt":".md"}')},612:function(n){n.exports=JSON.parse('{"title":"マウスカーソルの速度変えるアプリ作った","created_at":"2020/06/08","tags":["CS","WPF",".NETCore"],"bodyContent":"Windowsむずくね？  \\r\\nC#とWPFは良いとして、.Net Core（.Net Framework）ってなに？\\r\\n\\r\\n# 本題\\r\\nマウスカーソルの速度変えられるやつ(WPF製)作った。\\r\\n\\r\\n![Imgur](https://i.imgur.com/gAxYowU.png)\\r\\n\\r\\n- マウスの速度に変更\\r\\n    - Windowsの設定で`5`\\r\\n- タッチパッドの速度に変更\\r\\n    - Windowsの設定で`10`\\r\\n\\r\\nにするだけのアプリ！！！\\r\\n\\r\\n# ダウンロード\\r\\nhttps://github.com/takusan23/MouseCursorSpeedChanger/releases/tag/1.0\\r\\n\\r\\n# 作るのに大変だったこと\\r\\nを別の記事で書きたいと思います。\\r\\n\\r\\n# なんで作ったの？\\r\\nお友達から無線マウスもらった。（うれしい🥳）  \\r\\nそれでカーソルの速度が遅かったからWindowsの設定を変えたら、タッチパッドのときの操作が遅くなっちゃった。  \\r\\nその都度変えれば良いんだけどめんどいので解決してみた。\\r\\n\\r\\n## C#でマウスカーソルの速度が変更できるらしい。\\r\\n参考：https://ez-net.jp/article/D8/VnBq1qVD/s7VwewtZmDws/\\r\\n\\r\\nC#ほぼ書かないからわからん\\r\\n\\r\\n```cs\\r\\n/** マウスのカーソルの速度変更関係 */\\r\\npublic const uint SPI_GETMOUSESPEED = 0x70;\\r\\npublic const uint SPI_SETMOUSESPEED = 0x71;\\r\\n\\r\\n[DllImport(\\"User32.dll\\")]\\r\\nstatic extern Boolean SystemParametersInfo(\\r\\n    UInt32 uiAction,\\r\\n    UInt32 uiParam,\\r\\n    IntPtr pvParam,\\r\\n    UInt32 fWinIni);\\r\\n```\\r\\n\\r\\n使い方はこうです。  \\r\\nこれはカーソルの速度を5にするコードですね。\\r\\n```cs\\r\\nint speed = 5;\\r\\nSystemParametersInfo(SPI_SETMOUSESPEED, 0, new IntPtr(speed), 0);\\r\\n```\\r\\n\\r\\n以上です。  \\r\\n話変わるけど午後登校長く寝れるから良いね。早起きしたら学校までのカウントダウンのせいで苦痛だろうけど。","bodyHtml":"<p>Windowsむずくね？<br>\\nC#とWPFは良いとして、.Net Core（.Net Framework）ってなに？</p>\\n<h1>本題</h1>\\n<p>マウスカーソルの速度変えられるやつ(WPF製)作った。</p>\\n<p><img src=\\"https://i.imgur.com/gAxYowU.png\\" alt=\\"Imgur\\"></p>\\n<ul>\\n<li>マウスの速度に変更\\n<ul>\\n<li>Windowsの設定で<code>5</code></li>\\n</ul>\\n</li>\\n<li>タッチパッドの速度に変更\\n<ul>\\n<li>Windowsの設定で<code>10</code></li>\\n</ul>\\n</li>\\n</ul>\\n<p>にするだけのアプリ！！！</p>\\n<h1>ダウンロード</h1>\\n<p><a href=\\"https://github.com/takusan23/MouseCursorSpeedChanger/releases/tag/1.0\\">https://github.com/takusan23/MouseCursorSpeedChanger/releases/tag/1.0</a></p>\\n<h1>作るのに大変だったこと</h1>\\n<p>を別の記事で書きたいと思います。</p>\\n<h1>なんで作ったの？</h1>\\n<p>お友達から無線マウスもらった。（うれしい🥳）<br>\\nそれでカーソルの速度が遅かったからWindowsの設定を変えたら、タッチパッドのときの操作が遅くなっちゃった。<br>\\nその都度変えれば良いんだけどめんどいので解決してみた。</p>\\n<h2>C#でマウスカーソルの速度が変更できるらしい。</h2>\\n<p>参考：<a href=\\"https://ez-net.jp/article/D8/VnBq1qVD/s7VwewtZmDws/\\">https://ez-net.jp/article/D8/VnBq1qVD/s7VwewtZmDws/</a></p>\\n<p>C#ほぼ書かないからわからん</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/** マウスのカーソルの速度変更関係 */</span>\\n<span class=\\"hljs-keyword\\">public</span> <span class=\\"hljs-keyword\\">const</span> <span class=\\"hljs-keyword\\">uint</span> SPI_GETMOUSESPEED = <span class=\\"hljs-number\\">0x70</span>;\\n<span class=\\"hljs-keyword\\">public</span> <span class=\\"hljs-keyword\\">const</span> <span class=\\"hljs-keyword\\">uint</span> SPI_SETMOUSESPEED = <span class=\\"hljs-number\\">0x71</span>;\\n\\n[<span class=\\"hljs-meta\\">DllImport(<span class=\\"hljs-meta-string\\">\\"User32.dll\\"</span>)</span>]\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">static</span> <span class=\\"hljs-keyword\\">extern</span> Boolean <span class=\\"hljs-title\\">SystemParametersInfo</span>(<span class=\\"hljs-params\\">\\n    UInt32 uiAction,\\n    UInt32 uiParam,\\n    IntPtr pvParam,\\n    UInt32 fWinIni</span>)</span>;</code></pre><p>使い方はこうです。<br>\\nこれはカーソルの速度を5にするコードですね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">int</span> speed = <span class=\\"hljs-number\\">5</span>;\\nSystemParametersInfo(SPI_SETMOUSESPEED, <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-keyword\\">new</span> IntPtr(speed), <span class=\\"hljs-number\\">0</span>);</code></pre><p>以上です。<br>\\n話変わるけど午後登校長く寝れるから良いね。早起きしたら学校までのカウントダウンのせいで苦痛だろうけど。</p>\\n","dir":"contents/posts/json","base":"mousecursor_wpf.json","ext":".json","sourceBase":"mousecursor_wpf.md","sourceExt":".md"}')},613:function(n){n.exports=JSON.parse('{"title":"Nuxt.jsのFull Staticがすごい","created_at":"2020-06-27T00:00:00.000Z","tags":["NuxtJS","JavaScript","Vuetify"],"bodyContent":"歯磨きしたら血が出た。ちょっとびっくりした\\r\\n\\r\\n# 本題\\r\\nNuxt.jsの2.13から`完全な静的生成`機能がついた模様。  \\r\\nむしろ今までは完全ではなかったのか？って話でよくわからないけど、この中にある`ルーティング自動生成`が多分強い。\\r\\n\\r\\n詳しくはこれ  \\r\\n[本家ブログ](https://nuxtjs.org/blog/going-full-static)\\r\\n\\r\\n\\r\\n# こんなん読んでられんわ\\r\\n\\r\\n- 1.Nuxt.jsをアップデートする\\r\\n- 2.`nuxt.config.js`にこんな感じで`target:static`を指定\\r\\n```js\\r\\nexport default {\\r\\n  // 静的サイト書き出し。universalとstatic入れてね\\r\\n  mode: \'universal\',\\r\\n  target: \'static\',\\r\\n}\\r\\n```\\r\\n- 3.`package.json`の`generate`スクリプトを以下に変更\\r\\n```json\\r\\n\\"scripts\\": {\\r\\n  \\"generate\\": \\"nuxt build && nuxt export\\",\\r\\n}\\r\\n```\\r\\n- 4.`npm run generate`を実行する。`dist`フォルダができる。おつかれ様です。\\r\\n- おまけ：`npx nuxt serve`で静的生成したサイトをすぐに確認できるようになりました。\\r\\n\\r\\n# 何ができるようになるの？\\r\\n- 新しくなった静的生成\\r\\n    - `nuxt generate`から\\r\\n    - `nuxt build && nuxt export`へ\\r\\n- 怖くないルーティング\\r\\n    - 勝手にページを解析し、リンクを自動で見つけて勝手に生成します。\\r\\n    - どういうことかと言うと、以下のJSの用に`generate.routes`を書く必要がもうないということです。**コメントと化した結構重要（多分一番めんどい）な部分**\\r\\n```js\\r\\nexport default {\\r\\n  generate: {\\r\\n    // routes: generateRoutes, // 生成する\\r\\n    dir: \'docs\'\\r\\n  },\\r\\n}\\r\\n```\\r\\n\\r\\n# Nuxt.jsのアップデート\\r\\n2.0から2.13へ上げます。  \\r\\n## package.json 開いて\\r\\n\\r\\n`dependencies`の中の`nuxt`を`^2.13.1`にします。以下は一例\\r\\n\\r\\n```json\\r\\n\\"dependencies\\": {\\r\\n  \\"@nuxtjs/google-analytics\\": \\"^2.3.0\\",\\r\\n  \\"@nuxtjs/markdownit\\": \\"^1.2.9\\",\\r\\n  \\"@nuxtjs/pwa\\": \\"^3.0.0-0\\",\\r\\n  \\"markdown-it-footnote\\": \\"^3.0.2\\",\\r\\n  \\"markdown-it-highlight\\": \\"^0.2.0\\",\\r\\n  \\"nuxt\\": \\"^2.13.1\\"\\r\\n},\\r\\n```\\r\\n\\r\\nなお私もよく分かっていない。`^`←これなに？\\r\\n\\r\\n## package-lock.json ファイルと node_modules フォルダを消す\\r\\n\\r\\nnpm installで再召喚するので大丈夫\\r\\n\\r\\n## npm install を実行\\r\\n`npm install`を実行します。  \\r\\nおそらくおま環だろうけど私の環境では**管理者権限**ないとできませんでした。\\r\\n\\r\\n### こける\\r\\nまあうまく行かないよね\\r\\n- `Unexpected end of JSON input while parsing`なんとか\\r\\n    - 管理者権限でcmd等を開いて`npm cache clean --force`を実行する。**何してるか分かってるよな？** って言われた。分からない  \\r\\n    `npm WARN using --force I sure hope you know what you are doing.`\\r\\n\\r\\n# nuxt.config.js を開く\\r\\n開いたら、静的生成して＾～ってNuxtに伝えます。  \\r\\n`target:static`を追加します。\\r\\n\\r\\n```js\\r\\nexport default {\\r\\n  // 静的サイト書き出し。universalとstatic入れてね\\r\\n  mode: \'universal\',\\r\\n  target: \'static\',\\r\\n}\\r\\n```\\r\\n\\r\\n# nuxt build && nuxt export\\r\\n`package.json`を開いて、`script`にある、`generate`を書き換えます。\\r\\n\\r\\n```json\\r\\n\\"scripts\\": {\\r\\n  \\"generate\\": \\"nuxt build && nuxt export\\",\\r\\n}\\r\\n```\\r\\n\\r\\n# npm run generate 実行\\r\\nすると生成されます。お疲れ様でした～\\r\\n\\r\\n# 怖くないルーティング  \\r\\n今回のNuxt.jsさんは、勝手にリンクを見つけてリンクの分だけ生成するようになったのでもう不要です。  \\r\\nいやールーティング面倒だったのでこれはとてもありがたい。\\r\\n\\r\\n一応、`nuxt.config.js`で明示的に無効にする（`generate.crawler: false`）ことで旧仕様（`generate.routes`）を利用できるっぽい。\\r\\n\\r\\n# 静的生成したサイトを確認できる機能\\r\\n本番環境（私ならNetlify）に公開された場合どんな感じに見れるのか（多分変わらんと思うけど）を確認できる機能が付きました。\\r\\n\\r\\n- 一度きりなら\\r\\n    - `npx nuxt serve`（package.jsonにscript書かなくても、`npx`使えば直接使える）\\r\\n- package.jsonに書くなら\\r\\n```json\\r\\n\\"scripts\\": {\\r\\n  \\"staticdev\\": \\"nuxt serve\\",\\r\\n}\\r\\n```\\r\\n実行は`npm run staticdev`（別に`staticdev`って名前である必要はない。みんなはかっこいい名前をつけてあげよう）\\r\\n\\r\\n# おまけ\\r\\n## Vuetifyが変わった？\\r\\n\\r\\n`v-content`から`v-main`になった模様\\r\\n\\r\\nあと強制上書きCSSがまた動かなくなってた（力技やめとけ）  \\r\\nそれでふと`SCSS`ってやつでVuetifyが適用するCSSの内容変えられるやんって思って見てみると、あるんですね～\\r\\n\\r\\n```scss\\r\\n// Vuetifyが勝手に色つける問題\\r\\n$code-background-color: \'#000000\';\\r\\n```\\r\\n\\r\\n`code-background-color`なんていつの間に追加してたの？\\r\\n\\r\\nまた今度やろうと思います\\r\\n\\r\\n# おわりに\\r\\n`npx`なんて便利な機能あったんですね（え）\\r\\n\\r\\n# 参考にしました。\\r\\nhttps://nuxtjs.org/blog/going-full-static  \\r\\nhttps://ja.nuxtjs.org/guide/upgrading/  \\r\\nhttps://microcms.io/blog/nuxt-full-static-generation/","bodyHtml":"<p>歯磨きしたら血が出た。ちょっとびっくりした</p>\\n<h1>本題</h1>\\n<p>Nuxt.jsの2.13から<code>完全な静的生成</code>機能がついた模様。<br>\\nむしろ今までは完全ではなかったのか？って話でよくわからないけど、この中にある<code>ルーティング自動生成</code>が多分強い。</p>\\n<p>詳しくはこれ<br>\\n<a href=\\"https://nuxtjs.org/blog/going-full-static\\">本家ブログ</a></p>\\n<h1>こんなん読んでられんわ</h1>\\n<ul>\\n<li>1.Nuxt.jsをアップデートする</li>\\n<li>2.<code>nuxt.config.js</code>にこんな感じで<code>target:static</code>を指定</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> {\\n  <span class=\\"hljs-comment\\">// 静的サイト書き出し。universalとstatic入れてね</span>\\n  <span class=\\"hljs-attr\\">mode</span>: <span class=\\"hljs-string\\">\'universal\'</span>,\\n  <span class=\\"hljs-attr\\">target</span>: <span class=\\"hljs-string\\">\'static\'</span>,\\n}</code></pre><ul>\\n<li>3.<code>package.json</code>の<code>generate</code>スクリプトを以下に変更</li>\\n</ul>\\n<pre><code class=\\"hljs\\">\\"scripts\\": {\\n  \\"generate\\": \\"nuxt build &amp;&amp; nuxt export\\",\\n}</code></pre><ul>\\n<li>4.<code>npm run generate</code>を実行する。<code>dist</code>フォルダができる。おつかれ様です。</li>\\n<li>おまけ：<code>npx nuxt serve</code>で静的生成したサイトをすぐに確認できるようになりました。</li>\\n</ul>\\n<h1>何ができるようになるの？</h1>\\n<ul>\\n<li>新しくなった静的生成\\n<ul>\\n<li><code>nuxt generate</code>から</li>\\n<li><code>nuxt build &amp;&amp; nuxt export</code>へ</li>\\n</ul>\\n</li>\\n<li>怖くないルーティング\\n<ul>\\n<li>勝手にページを解析し、リンクを自動で見つけて勝手に生成します。</li>\\n<li>どういうことかと言うと、以下のJSの用に<code>generate.routes</code>を書く必要がもうないということです。<strong>コメントと化した結構重要（多分一番めんどい）な部分</strong></li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> {\\n  <span class=\\"hljs-attr\\">generate</span>: {\\n    <span class=\\"hljs-comment\\">// routes: generateRoutes, // 生成する</span>\\n    <span class=\\"hljs-attr\\">dir</span>: <span class=\\"hljs-string\\">\'docs\'</span>\\n  },\\n}</code></pre><h1>Nuxt.jsのアップデート</h1>\\n<p>2.0から2.13へ上げます。</p>\\n<h2>package.json 開いて</h2>\\n<p><code>dependencies</code>の中の<code>nuxt</code>を<code>^2.13.1</code>にします。以下は一例</p>\\n<pre><code class=\\"hljs\\">\\"dependencies\\": {\\n  \\"@nuxtjs/google-analytics\\": \\"^2.3.0\\",\\n  \\"@nuxtjs/markdownit\\": \\"^1.2.9\\",\\n  \\"@nuxtjs/pwa\\": \\"^3.0.0-0\\",\\n  \\"markdown-it-footnote\\": \\"^3.0.2\\",\\n  \\"markdown-it-highlight\\": \\"^0.2.0\\",\\n  \\"nuxt\\": \\"^2.13.1\\"\\n},</code></pre><p>なお私もよく分かっていない。<code>^</code>←これなに？</p>\\n<h2>package-lock.json ファイルと node_modules フォルダを消す</h2>\\n<p>npm installで再召喚するので大丈夫</p>\\n<h2>npm install を実行</h2>\\n<p><code>npm install</code>を実行します。<br>\\nおそらくおま環だろうけど私の環境では<strong>管理者権限</strong>ないとできませんでした。</p>\\n<h3>こける</h3>\\n<p>まあうまく行かないよね</p>\\n<ul>\\n<li><code>Unexpected end of JSON input while parsing</code>なんとか\\n<ul>\\n<li>管理者権限でcmd等を開いて<code>npm cache clean --force</code>を実行する。<strong>何してるか分かってるよな？</strong> って言われた。分からない<br>\\n<code>npm WARN using --force I sure hope you know what you are doing.</code></li>\\n</ul>\\n</li>\\n</ul>\\n<h1>nuxt.config.js を開く</h1>\\n<p>開いたら、静的生成して＾～ってNuxtに伝えます。<br>\\n<code>target:static</code>を追加します。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">export</span> <span class=\\"hljs-keyword\\">default</span> {\\n  <span class=\\"hljs-comment\\">// 静的サイト書き出し。universalとstatic入れてね</span>\\n  <span class=\\"hljs-attr\\">mode</span>: <span class=\\"hljs-string\\">\'universal\'</span>,\\n  <span class=\\"hljs-attr\\">target</span>: <span class=\\"hljs-string\\">\'static\'</span>,\\n}</code></pre><h1>nuxt build &amp;&amp; nuxt export</h1>\\n<p><code>package.json</code>を開いて、<code>script</code>にある、<code>generate</code>を書き換えます。</p>\\n<pre><code class=\\"hljs\\">\\"scripts\\": {\\n  \\"generate\\": \\"nuxt build &amp;&amp; nuxt export\\",\\n}</code></pre><h1>npm run generate 実行</h1>\\n<p>すると生成されます。お疲れ様でした～</p>\\n<h1>怖くないルーティング</h1>\\n<p>今回のNuxt.jsさんは、勝手にリンクを見つけてリンクの分だけ生成するようになったのでもう不要です。<br>\\nいやールーティング面倒だったのでこれはとてもありがたい。</p>\\n<p>一応、<code>nuxt.config.js</code>で明示的に無効にする（<code>generate.crawler: false</code>）ことで旧仕様（<code>generate.routes</code>）を利用できるっぽい。</p>\\n<h1>静的生成したサイトを確認できる機能</h1>\\n<p>本番環境（私ならNetlify）に公開された場合どんな感じに見れるのか（多分変わらんと思うけど）を確認できる機能が付きました。</p>\\n<ul>\\n<li>一度きりなら\\n<ul>\\n<li><code>npx nuxt serve</code>（package.jsonにscript書かなくても、<code>npx</code>使えば直接使える）</li>\\n</ul>\\n</li>\\n<li>package.jsonに書くなら</li>\\n</ul>\\n<pre><code class=\\"hljs\\">\\"scripts\\": {\\n  \\"staticdev\\": \\"nuxt serve\\",\\n}</code></pre><p>実行は<code>npm run staticdev</code>（別に<code>staticdev</code>って名前である必要はない。みんなはかっこいい名前をつけてあげよう）</p>\\n<h1>おまけ</h1>\\n<h2>Vuetifyが変わった？</h2>\\n<p><code>v-content</code>から<code>v-main</code>になった模様</p>\\n<p>あと強制上書きCSSがまた動かなくなってた（力技やめとけ）<br>\\nそれでふと<code>SCSS</code>ってやつでVuetifyが適用するCSSの内容変えられるやんって思って見てみると、あるんですね～</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// Vuetifyが勝手に色つける問題</span>\\n<span class=\\"hljs-variable\\">$code-background-color</span>: <span class=\\"hljs-string\\">\'#000000\'</span>;</code></pre><p><code>code-background-color</code>なんていつの間に追加してたの？</p>\\n<p>また今度やろうと思います</p>\\n<h1>おわりに</h1>\\n<p><code>npx</code>なんて便利な機能あったんですね（え）</p>\\n<h1>参考にしました。</h1>\\n<p><a href=\\"https://nuxtjs.org/blog/going-full-static\\">https://nuxtjs.org/blog/going-full-static</a><br>\\n<a href=\\"https://ja.nuxtjs.org/guide/upgrading/\\">https://ja.nuxtjs.org/guide/upgrading/</a><br>\\n<a href=\\"https://microcms.io/blog/nuxt-full-static-generation/\\">https://microcms.io/blog/nuxt-full-static-generation/</a></p>\\n","dir":"contents/posts/json","base":"nuxt_2_13_sugoi.json","ext":".json","sourceBase":"nuxt_2_13_sugoi.md","sourceExt":".md"}')},614:function(n){n.exports=JSON.parse('{"title":"Nuxt.jsのプリフェッチがはやい","created_at":"2020-06-28T00:00:00.000Z","tags":["NuxtJS","JavaScript","Vuetify"],"bodyContent":"まずはこちらのGIFを見てください（3MBぐらい。でけえんだよ）\\r\\n\\r\\n![Imgur](https://i.imgur.com/oyePdWI.gif)\\r\\n\\r\\n左側は今まで、右側はNuxt.jsのSmart Prefeching機能を使ったページ遷移です。  \\r\\n\\r\\n押した瞬間に切り替わっていることが分かると思います。\\r\\n\\r\\n# Smart Prefeching とは\\r\\n[本家ブログ](https://nuxtjs.org/blog/introducing-smart-prefetching)\\r\\n\\r\\nブラウザの表示領域にリンク`<nuxt-link>`を見つけたらそのリンクをブラウザが先読みする機能。これをプリフェッチ機能っていうらしい。\\r\\n\\r\\n# 使い方\\r\\n- `<nuxt-link>`を使う\\r\\n- Vuetifyの場合\\r\\n    - `to=\\"遷移先\\"`と`nuxt`を属性に付けることで利用可能。`nuxt`を付け忘れると機能しない。\\r\\n    - GIFの用に`<v-card>`をページ遷移に使う際はこんな風に\\r\\n```html\\r\\n<v-card\\r\\n  class=\\"ma-2 pa-5\\"\\r\\n  to=\\"`/posts/taihendattakoto\\"\\r\\n  nuxt\\r\\n>\\r\\n</v-card>\\r\\n```\\r\\n\\r\\n以上です。","bodyHtml":"<p>まずはこちらのGIFを見てください（3MBぐらい。でけえんだよ）</p>\\n<p><img src=\\"https://i.imgur.com/oyePdWI.gif\\" alt=\\"Imgur\\"></p>\\n<p>左側は今まで、右側はNuxt.jsのSmart Prefeching機能を使ったページ遷移です。</p>\\n<p>押した瞬間に切り替わっていることが分かると思います。</p>\\n<h1>Smart Prefeching とは</h1>\\n<p><a href=\\"https://nuxtjs.org/blog/introducing-smart-prefetching\\">本家ブログ</a></p>\\n<p>ブラウザの表示領域にリンク<code>&lt;nuxt-link&gt;</code>を見つけたらそのリンクをブラウザが先読みする機能。これをプリフェッチ機能っていうらしい。</p>\\n<h1>使い方</h1>\\n<ul>\\n<li><code>&lt;nuxt-link&gt;</code>を使う</li>\\n<li>Vuetifyの場合\\n<ul>\\n<li><code>to=&quot;遷移先&quot;</code>と<code>nuxt</code>を属性に付けることで利用可能。<code>nuxt</code>を付け忘れると機能しない。</li>\\n<li>GIFの用に<code>&lt;v-card&gt;</code>をページ遷移に使う際はこんな風に</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">v-card</span>\\n  <span class=\\"hljs-attr\\">class</span>=<span class=\\"hljs-string\\">\\"ma-2 pa-5\\"</span>\\n  <span class=\\"hljs-attr\\">to</span>=<span class=\\"hljs-string\\">\\"`/posts/taihendattakoto\\"</span>\\n  <span class=\\"hljs-attr\\">nuxt</span>\\n&gt;</span>\\n<span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">v-card</span>&gt;</span></code></pre><p>以上です。</p>\\n","dir":"contents/posts/json","base":"nuxt_link_hayai.json","ext":".json","sourceBase":"nuxt_link_hayai.md","sourceExt":".md"}')},615:function(n){n.exports=JSON.parse('{"title":"Nuxtの静的サイトジェネレートはモードをuniversalにしよう","created_at":"2020-06-16T00:00:00.000Z","tags":["NuxtJS","JavaScript","自作ブログ"],"bodyContent":"静的サイト書き出せてたと思ったら書き出せてなかった話です。  \\r\\nこれ以外にも大変だったことがいっぱいあるのでもしよければ見てね。→[大変だったこと](/posts/taihendattakoto)\\r\\n\\r\\n# なにがあったの\\r\\nMastodonの認証マークが付かなかった。  \\r\\nMastodonの認証マークはサイトにaタグ置いて、hrefと`rel=\\"me\\"`付けば通る。ちゃんとChromeであってるか確認したんだけど、なぜか認証されなかった。\\r\\n\\r\\n## さらに\\r\\nJavaScriptを無効にすると（めったにないけど）真っ白になった。  \\r\\n静的サイト書き出しならただHTMLを表示するだけなのになんでJS消すと動かなくなるんだ？。JSがどうこう関係なくね？  \\r\\n\\r\\n**あれこれJavaScriptで動的にDOM操作？**\\r\\n\\r\\n# 静的サイトを書き出す方法\\r\\n\\r\\n`nuxt.config.js`の`mode`を`universal`にする必要があります。  \\r\\n\\r\\nそうすればHTMLファイルにちゃんと内容がまんま入ってるはずです。\\r\\n\\r\\nこんな感じに↓  \\r\\n![Imgur](https://imgur.com/WkV9GT2.png)\\r\\n\\r\\n(ちなみにVSCode、`Ctrlと+`で拡大、`Ctrlと-`で縮小ができます。間違えて押した時に覚えておけば良いかも？)\\r\\n\\r\\n以上です。\\r\\n\\r\\n# おまけ\\r\\n`mode:\'universal\'`にしたせいか、VuetifyのChipのところでエラーが出るようになっちゃった。  \\r\\nよくわからないのでとりあえず`<client-only>`で黙らせた（え）\\r\\n\\r\\n# 参考にしました\\r\\nhttps://jamstack.jp/blog/nuxt_stumble_point/","bodyHtml":"<p>静的サイト書き出せてたと思ったら書き出せてなかった話です。<br>\\nこれ以外にも大変だったことがいっぱいあるのでもしよければ見てね。→<a href=\\"/posts/taihendattakoto\\">大変だったこと</a></p>\\n<h1>なにがあったの</h1>\\n<p>Mastodonの認証マークが付かなかった。<br>\\nMastodonの認証マークはサイトにaタグ置いて、hrefと<code>rel=&quot;me&quot;</code>付けば通る。ちゃんとChromeであってるか確認したんだけど、なぜか認証されなかった。</p>\\n<h2>さらに</h2>\\n<p>JavaScriptを無効にすると（めったにないけど）真っ白になった。<br>\\n静的サイト書き出しならただHTMLを表示するだけなのになんでJS消すと動かなくなるんだ？。JSがどうこう関係なくね？</p>\\n<p><strong>あれこれJavaScriptで動的にDOM操作？</strong></p>\\n<h1>静的サイトを書き出す方法</h1>\\n<p><code>nuxt.config.js</code>の<code>mode</code>を<code>universal</code>にする必要があります。</p>\\n<p>そうすればHTMLファイルにちゃんと内容がまんま入ってるはずです。</p>\\n<p>こんな感じに↓<br>\\n<img src=\\"https://imgur.com/WkV9GT2.png\\" alt=\\"Imgur\\"></p>\\n<p>(ちなみにVSCode、<code>Ctrlと+</code>で拡大、<code>Ctrlと-</code>で縮小ができます。間違えて押した時に覚えておけば良いかも？)</p>\\n<p>以上です。</p>\\n<h1>おまけ</h1>\\n<p><code>mode:\'universal\'</code>にしたせいか、VuetifyのChipのところでエラーが出るようになっちゃった。<br>\\nよくわからないのでとりあえず<code>&lt;client-only&gt;</code>で黙らせた（え）</p>\\n<h1>参考にしました</h1>\\n<p><a href=\\"https://jamstack.jp/blog/nuxt_stumble_point/\\">https://jamstack.jp/blog/nuxt_stumble_point/</a></p>\\n","dir":"contents/posts/json","base":"nuxt_universal.json","ext":".json","sourceBase":"nuxt_universal.md","sourceExt":".md"}')},616:function(n){n.exports=JSON.parse('{"title":"タグのページ作った","created_at":"2020-06-03T00:00:00.000Z","tags":["その他","NuxtJS","自作ブログ","JavaScript"],"bodyContent":"タグのページ作りました。  \\r\\n**まだタグ一覧は作ってませんが**、タグが含まれている記事の一覧表示ならできるようになりました\\r\\n\\r\\n試しにChipを押してみてね。  \\r\\n\\r\\n**あとページネーション(二ページ目みたいなやつ)付けてないから多分大変なことになる**\\r\\n\\r\\n## 技術的な話\\r\\n\\r\\n`posts/tag/自作ブログ/index.html` みたいなファイルが生成されるようになりました。  \\r\\n\\r\\n```js\\r\\n/** タグが含まれている記事一覧のパス配列生成関数。 */\\r\\nconst generateTagPageRoutesList = () => {\\r\\n  // 記事オブジェクト一覧配列を生成する。キーだけの配列にしてmapで取り出す\\r\\n  const blogItems = Object.keys(postsJSON.fileMap).map(key => postsJSON.fileMap[key])\\r\\n  // タグだけの配列を作る\\r\\n  const allTagItems = blogItems.map(blog => blog.tags).flat()\\r\\n  // 被りを消す。new Set()でいいらしい\\r\\n  const tagList = [...new Set(allTagItems)]\\r\\n  // パス生成。こんな感じの→ /posts/tag/自作ブログ みたいな感じに\\r\\n  const pathList = tagList.map(tagName => `/posts/tag/${tagName}`)\\r\\n  return pathList\\r\\n}\\r\\n// 省略\\r\\n/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */\\r\\nconst generateRoutes = callback => {\\r\\n  callback(null, [generateTagPageRoutesList()].flat())\\r\\n}\\r\\n```\\r\\n\\r\\nJavaScriptの配列、被りを消す方法にこんな方法があったんですね。  \\r\\n```js\\r\\nconsole.log([...new Set([1,2,1])]) // [1,2]\\r\\n```\\r\\n\\r\\nちなみにKotlinだと`array()#distinct()`があります。超便利\\r\\n\\r\\n以上です（？）  \\r\\n久々の学校はまあまあ楽しかったです。帰り陽キャが絡んできたのが減点ポイントですね。  \\r\\n\\r\\nあと2m確保とが無理じゃね？","bodyHtml":"<p>タグのページ作りました。<br>\\n<strong>まだタグ一覧は作ってませんが</strong>、タグが含まれている記事の一覧表示ならできるようになりました</p>\\n<p>試しにChipを押してみてね。</p>\\n<p><strong>あとページネーション(二ページ目みたいなやつ)付けてないから多分大変なことになる</strong></p>\\n<h2>技術的な話</h2>\\n<p><code>posts/tag/自作ブログ/index.html</code> みたいなファイルが生成されるようになりました。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/** タグが含まれている記事一覧のパス配列生成関数。 */</span>\\n<span class=\\"hljs-keyword\\">const</span> generateTagPageRoutesList = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 記事オブジェクト一覧配列を生成する。キーだけの配列にしてmapで取り出す</span>\\n  <span class=\\"hljs-keyword\\">const</span> blogItems = <span class=\\"hljs-built_in\\">Object</span>.keys(postsJSON.fileMap).map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">key</span> =&gt;</span> postsJSON.fileMap[key])\\n  <span class=\\"hljs-comment\\">// タグだけの配列を作る</span>\\n  <span class=\\"hljs-keyword\\">const</span> allTagItems = blogItems.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">blog</span> =&gt;</span> blog.tags).flat()\\n  <span class=\\"hljs-comment\\">// 被りを消す。new Set()でいいらしい</span>\\n  <span class=\\"hljs-keyword\\">const</span> tagList = [...new <span class=\\"hljs-built_in\\">Set</span>(allTagItems)]\\n  <span class=\\"hljs-comment\\">// パス生成。こんな感じの→ /posts/tag/自作ブログ みたいな感じに</span>\\n  <span class=\\"hljs-keyword\\">const</span> pathList = tagList.map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">tagName</span> =&gt;</span> <span class=\\"hljs-string\\">`/posts/tag/<span class=\\"hljs-subst\\">${tagName}</span>`</span>)\\n  <span class=\\"hljs-keyword\\">return</span> pathList\\n}\\n<span class=\\"hljs-comment\\">// 省略</span>\\n<span class=\\"hljs-comment\\">/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */</span>\\n<span class=\\"hljs-keyword\\">const</span> generateRoutes = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">callback</span> =&gt;</span> {\\n  callback(<span class=\\"hljs-literal\\">null</span>, [generateTagPageRoutesList()].flat())\\n}</code></pre><p>JavaScriptの配列、被りを消す方法にこんな方法があったんですね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-built_in\\">console</span>.log([...new <span class=\\"hljs-built_in\\">Set</span>([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">1</span>])]) <span class=\\"hljs-comment\\">// [1,2]</span></code></pre><p>ちなみにKotlinだと<code>array()#distinct()</code>があります。超便利</p>\\n<p>以上です（？）<br>\\n久々の学校はまあまあ楽しかったです。帰り陽キャが絡んできたのが減点ポイントですね。</p>\\n<p>あと2m確保とが無理じゃね？</p>\\n","dir":"contents/posts/json","base":"taglist.json","ext":".json","sourceBase":"taglist.md","sourceExt":".md"}')},617:function(n){n.exports=JSON.parse('{"title":"これ作るのに大変だったこと","created_at":"2020-06-02T00:00:00.000Z","tags":["その他","自作ブログ"],"bodyContent":"Hexoってすごいんだなって。  \\r\\nなお完成はいつになるかわかりません。いつ出来上がるんだこれ？  \\r\\n完成までに思ったことを書いていくと思う。\\r\\n\\r\\n~~あとドメインが欲しい。買ったこと無いけどどうなんですかね？~~\\r\\n\\r\\n[取りました](/posts/domain_katta)\\r\\n\\r\\n## これ作るのに大変だったこと\\r\\n書く。\\r\\n\\r\\n### Vuetifyが`<code>`に色つける。\\r\\n\\r\\nVuetifyくんが勝手に色を付けてくれます。が、なんかいまいちなので頑張ってCSS書いて直したいんですが、  \\r\\nVuetifyくんが許してくれません。？  \\r\\nしかたないので`!important`で黙らせました。    \\r\\n\\r\\nassets/css/styles.css\\r\\n```css\\r\\n/* VuetifyのせいでCodeタグに勝手にCSS適用されるので強制上書き */\\r\\n\\r\\n.v-application code {\\r\\n    box-shadow: initial !important;\\r\\n    border: 1px solid gray;\\r\\n    border-radius: 5px !important;\\r\\n    font-family: \'Koruri Regular\';\\r\\n    margin: 10px;\\r\\n}\\r\\n\\r\\n.v-application code, .v-application kbd {\\r\\n    font-weight: initial !important;\\r\\n}\\r\\n```\\r\\n\\r\\nついでに`highlight.js`のCSS、`vs2015.css`を入れてコードにシンタックスハイライトをつけようとしたんですけど、これもうまく動かなかったので`vs2015.css`に`!important`付けて対応しました。\\r\\n\\r\\n### CSS\\r\\nCSSよくわがんね。\\r\\n\\r\\n```css\\r\\n/* ほばー */\\r\\n.titleHover:hover {\\r\\n    color: #5870cb;\\r\\n    transition: color 0.5s;\\r\\n}\\r\\n```\\r\\n\\r\\nこれは記事一覧のタイトルをマウスオーバーするとジワーッと色が変わるCSSです。  \\r\\n\\r\\n### Processmdくんが時系列順に並べてくれない\\r\\n\\r\\nこれはおま環境かもしれないけど、時系列順に並んでくれません。  \\r\\n流石に時系列順にならないのはきついので、JavaScriptで時系列に並び替えるコードを書きました。sort関数あったし。\\r\\n\\r\\n```js\\r\\n// なんかしらんけど並び順が新しい順とは限らないらしい？\\r\\nconst sortedKeyList = Object.keys(fileMap);\\r\\nsortedKeyList.sort(function(a, b) {\\r\\n  const aDate = new Date(fileMap[a].created_at).getTime();\\r\\n  const bDate = new Date(fileMap[b].created_at).getTime();\\r\\n  if (aDate > bDate) return -1;\\r\\n  if (aDate < bDate) return 1;\\r\\n  return 0;\\r\\n});\\r\\n```\\r\\n\\r\\nKotlinの`sortBy{}`とは使い方が違っててちょっと迷った。\\r\\n\\r\\nあとprocessmdくん、/posts/jsonに消した記事が残ってるんですがそれは、、\\r\\n\\r\\n### ページネーション\\r\\n\\r\\n追記（2020/06/27）：もしかしたらこれ書く必要ないと思う（`_id.vue`ファイルは必要だと思う）  \\r\\n詳細→ [Nuxt.jsを2.13に上げた時の話](/posts/nuxt_2_13_sugoi)\\r\\n\\r\\n次のページ、前のページを付けることを、ページネーションって言うそうですよ。  \\r\\nこれ付けないと記事が増えたときのスクロールがとんでもないことになる。  \\r\\n\\r\\n記事一覧はこんな感じに静的に出してほしいので（postsに置くとタイトル被りそうなのでpageフォルダがある。）\\r\\n```js\\r\\n/posts/page/1\\r\\n```\\r\\n\\r\\n特に需要はなさそうですが一応必要なページ数に合わせて`posts/page`の配列を返す関数置いときますね。\\r\\n\\r\\n```js\\r\\n/** 次のページ機能をつける。そうしないと記事一覧にどばーってなってスクロール大変になる */\\r\\nconst generatePagenationRoutesList = () => {\\r\\n  // 何ページ必要か計算する（10で割ればいいっしょ）。ただ1ページ目は最低限必要なので1足す\\r\\n  const calc = Math.floor(postsJSON.sourceFileArray.length / PAGE_LIMIT) + 1\\r\\n  // ページ分だけ動的ルーティングの配列出す？\\r\\n  const dynamicRouterPathList = []\\r\\n  // console.log(`ページ数：${calc} / 記事数：${postsJSON.sourceFileArray.length}`)\\r\\n  // ページ生成。1ページ目から作るので1からスタート\\r\\n  for (let i = 1; i <= calc; i++) {\\r\\n    dynamicRouterPathList.push(`/posts/page/${i}`)\\r\\n  }\\r\\n  return dynamicRouterPathList\\r\\n}\\r\\n\\r\\n// 省略\\r\\n\\r\\n/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */\\r\\nconst generateRoutes = callback => {\\r\\n  callback(null, [generatePagenationRoutesList()].flat())\\r\\n}\\r\\n\\r\\n```\\r\\n\\r\\nこれ動かすには`postsフォルダ`に`pageフォルダ`を作って中に、`_id.vue`を置いておく必要があります。\\r\\n\\r\\nこれで`posts/page/1`などが生成されるようになります（多分）\\r\\n\\r\\n~~この記事書いてる途中でなんでこれ動いてんのかよくわからなくなったのは内緒~~←やっぱり生成できてなかったので直しました。（2020/06/03）\\r\\n\\r\\n### `<v-card>`が遅い？→いつの間にか直った？\\r\\n何故か知りませんが、VuetiryのCardコンポーネントがおそい。というかページ遷移がこいつのせいで遅くなる。  \\r\\n\\r\\nせっかくの静的サイトで遅いのは辛いので直したい。（しかも記事一覧に戻った時にワンテンポ遅れるとか見てられない）\\r\\n\\r\\nで、なぜか`<v-card>`を`<v-sheet>`に置き換えることで解決しました。  \\r\\n\\r\\nなんで？\\r\\n\\r\\n### 記事一覧を再読み込みした後記事を開くと404\\r\\n\\r\\nなんかしらんけどF5するとURLの後ろに`/`が入ります。  \\r\\n最後に`/`が入っていないのが前提で作っているので、最後に入ると **`../`(一個前に戻る)** がおかしな場所を指すようになります。\\r\\n\\r\\n---追記---\\r\\n\\r\\n**別に`../`使わなくても良いことに気付いたのでこの問題は解決しました。**  \\r\\n**`to=\'/posts/first\'`みたいな感じで別に戻る必要ありませんでした。**\\r\\n\\r\\n---追記おわり---\\r\\n\\r\\nというかこれは私の作り方（ファイル構成）が悪いですね、なんで戻ったりしないといけないんだ。\\r\\n\\r\\n- pages\\r\\n  - pages（固定ページ。今回は省略）\\r\\n  - posts（ブログ）\\r\\n    - page\\r\\n      - _id.vue（記事一覧）\\r\\n    - tag\\r\\n      - _id.vue（タグ検索結果）\\r\\n    - index.vue（本来ここに記事一覧が有るべき？）\\r\\n    - _slug.vue（記事。ここに居るので一覧から来たら戻らないといけない。）\\r\\n\\r\\n\\r\\n今回は`nuxt.config.js`を開き、URLの最後に`/`を入れる設定を付けました。おかげて修正が必要になりましたが。\\r\\n\\r\\n```js\\r\\nexport.default {\\r\\n  // 省略\\r\\n  router: {\\r\\n    base: \'/Ziyuutyou/\',\\r\\n    trailingSlash: true // ←これ\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### `sw.js`がよくわからんけどバージョン管理対象外になってて**ホーム画面に追加**が消えてた\\r\\n\\r\\nGitHubのリポジトリ開いて`/docs`開いたら見事にServiceWorkerだけ抜けてました。なんで？\\r\\n\\r\\n### Hexoと違ってリアルタイムで記事の内容が反映されない\\r\\n\\r\\nHexoって書いてる途中でも、リロードすれば記事の内容が更新されてどんな感じに見れてるか確認できるんですけど、processmdくんデフォルトだとできないっぽい？  \\r\\n`processmd`見る感じ、ファイルの中身を監視する`--watch`オプションが存在するのでそれ使えばよさそうです、  \\r\\nそれで適当に`package.json`の`scripts`の中に実行とprocessmdの監視オプション付きを同時に実行する様に書いたんですけど、  \\r\\n**nuxt起動から先に進みません！そりゃnuxtもファイルを監視してるからそこで止まりますよね。**\\r\\n\\r\\nそれでどうすれば同時に（並列に）起動できるかって話ですが、`npm-run-all`ってのを使えば並列実行ができそうです。  \\r\\nただ、これ使っても更新できるのは記事の中身だけで記事一覧(summary.json)は更新できないっぽいです。(nuxt起動時にsummary.jsonが空っぽだぞって怒られる。どうやら一度消えるらしい？)  \\r\\n\\r\\nでも記事の中身がリアルタイムで反映されるようになったので満足です。VSCode半分にしなくて済むし。  \\r\\n参考程度の`package.json`のscript\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\"scripts\\": {\\r\\n    \\"dev\\": \\"nuxt --port 11451\\",\\r\\n    \\"build\\": \\"nuxt build\\",\\r\\n    \\"start\\": \\"nuxt start\\",\\r\\n    \\"generate\\": \\"nuxt generate\\",\\r\\n    \\"markdown\\": \\"npm run post && npm run page\\",\\r\\n    \\"page\\": \\"processmd contents/pages/**/*.md --stdout --outputDir contents/pages/json > contents/pages/summary.json --markdownOptions.linkify\\",\\r\\n    \\"post\\": \\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json --markdownOptions.linkify\\",\\r\\n    \\"pagewatch\\": \\"processmd contents/pages/**/*.md --outputDir contents/pages/json --markdownOptions.linkify --watch\\",\\r\\n    \\"postwatch\\": \\"processmd contents/posts/**/*.md --outputDir contents/posts/json --markdownOptions.linkify --watch\\",\\r\\n    \\"all\\": \\"npm-run-all markdown --parallel dev postwatch\\"\\r\\n  },\\r\\n}\\r\\n```\\r\\n\\r\\n`npm run all`を実行すると\\r\\n- markdownファイルがJSON形式に変換される\\r\\n- nuxt起動\\r\\n- nuxt起動と同時にprocessmdの監視を始める\\r\\n  - `--stdout`オプションは外してあるので、記事一覧は更新されない。\\r\\n\\r\\n`--parallel`のあとに指定したスクリプトが並列で実行され、その前に書いてあるスクリプトは直列で実行されます。\\r\\n\\r\\nちなみにprocessmdくんがJSONファイルを書き換えるとnuxtのファイル変更監視に引っかかるので自動で更新されるようになります。すげえ\\r\\n\\r\\n~~たまにundefinedになるけどしゃーない~~\\r\\n\\r\\n### マークダウンに書いたURLがリンクにならない\\r\\n\\r\\nprocessmdくんのオプションに`--markdownOptions.linkify`をくっつけて実行すればいいです。\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\"scripts\\": {\\r\\n    \\"post\\": \\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json > contents/posts/summary.json --markdownOptions.linkify\\"\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n### ~~しれっと~~Netlifyにお引越ししたりした。\\r\\n\\r\\nGitHubPagesより良いのかはしらんけどお試しで引っ越してみた。これ勝手にメアド公開したりしないよな？  \\r\\n[Netlify へデプロイするには？](https://ja.nuxtjs.org/faq/netlify-deployment/)ってのが有るのでそれに沿ってやればできると思います。\\r\\n\\r\\nじゃあなんで**大変だったこと**に書いてんだよって話ですが、っぱコケるんですね。\\r\\n\\r\\n<iframe src=\\"https://best-friends.chat/@takusan_23/104330325427830329/embed\\" class=\\"mastodon-embed\\" style=\\"max-width: 100%; border: 0; height:200px\\" width=\\"400\\" allowfullscreen=\\"allowfullscreen\\"></iframe><script src=\\"https://best-friends.chat/embed.js\\" async=\\"async\\"><\/script>\\r\\n\\r\\nあーJSだからしゃーないのかなーなんて思ってとりあえず検索すると、`Chromeのバージョン的に対応していない`とか出てきたのでワンちゃんNode.jsくんのバージョンがおかしいのではないかと考えました。  \\r\\n\\r\\nNetlifyにNode.jsのバージョンを指定する方法ですが、検索したらありました。 [参考元](https://qiita.com/n0bisuke/items/8bddad87610b01c90003)\\r\\n\\r\\n`.nvmrc`というファイルを置いて、中にNode.jsのバージョンを書くだけで解決しました。\\r\\n\\r\\n`v12.14.1`\\r\\n\\r\\nこれだけ。これで成功しました。\\r\\n\\r\\nちなみサイト作成時のステップ３で、ビルドコマンドに`npm run generate`、ディレクトリを`docs(GitHubPagesの名残)`すれば、コミット+プッシュ時に勝手に`npm run genreate`して公開してくれます。らく\\r\\n\\r\\n### 実は静的サイト書き出しできてなかった\\r\\nこれは別に記事に書いた→ [Nuxtの静的サイトジェネレートはモードをuniversalにしよう](/posts/nuxt_universal)\\r\\n\\r\\n読みたくない方向け→`nuxt.config.js`の`mode:`を`universal`にすればHTMLに書き出してくれます。  \\r\\n`spa`だとHTMLのbody見てもscriptタグが何個か有るだけで、内容はJS実行されるまで表示されませんでした。  \\r\\n`universal`ならHTMLに書き出してくれるのでJS切っても見れます。\\r\\n\\r\\n### (本当かわからんけど)開発時(localhost)の時は別のタブで開けない？\\r\\n\\r\\n記事を別のタブで開くと永遠に読み込んでたりするんだけどもしかして別のタブで開くことできない？\\r\\n\\r\\n## 特に大変じゃなかったこと\\r\\n\\r\\n### PWA\\r\\n\\r\\nPWAってめんどいんですよ。アイコン画像を用意するのがね！！！。  \\r\\n192x192だったり512x512だったりいっぱい要求してくるんですけど、  \\r\\n`@nuxt/pwa`は指定がない場合、`static/icon.png`を使ってくれるので、512x512のpngを置いておくだけで終わりました。PWA RTA行けそう（は？）  \\r\\n\\r\\n一応`nuxt.config.js`の`manifest`置いておきますね。\\r\\n\\r\\n```js\\r\\n/** \\r\\n * PWA manifest.json\\r\\n */\\r\\nmanifest: {\\r\\n  name: \'たくさんの自由帳\',\\r\\n  title: \'たくさんの自由帳\',\\r\\n  \'og:title\': \'たくさんの自由帳\',\\r\\n  lang: \'ja\',\\r\\n  theme_color: \'#8c9eff\',\\r\\n  background_color: \'#5870cb\',\\r\\n  display: \'standalone\',\\r\\n}\\r\\n```\\r\\n\\r\\n### ダークモード\\r\\n\\r\\nVuetifyなら  \\r\\n```js\\r\\n$vuetify.theme.dark = true\\r\\n```  \\r\\nで終わります。Vuetifyすげー\\r\\n\\r\\nダークモード切り替えスイッチの例置いときますね。\\r\\n\\r\\n```js\\r\\n\x3c!-- ダークモードスイッチ --\x3e\\r\\n<v-switch\\r\\n  class=\\"text-center ma-2\\"\\r\\n  :append-icon=\\"`${$vuetify.theme.dark ? \'mdi-weather-night\' : \'mdi-weather-sunny\'}`\\"\\r\\n  v-model=\\"$vuetify.theme.dark\\"\\r\\n  label=\\"テーマ切り替え\\"\\r\\n></v-switch>\\r\\n```\\r\\n\\r\\n三項演算子使うの初めてかもしれない（まずKotlinにはないし）  \\r\\n\\r\\nところで$←これなに？\\r\\n\\r\\n### 端末がダークモードかどうか\\r\\n\\r\\n以下のJSでダークモードかどうかを監視して、Vuetifyのモードを変更するようにできます。  \\r\\n[参考：StackOverflow](https://stackoverflow.com/questions/56393880/how-do-i-detect-dark-mode-using-javascript)\\r\\n\\r\\n```js\\r\\nwindow\\r\\n      .matchMedia(\\"(prefers-color-scheme: dark)\\")\\r\\n      .addEventListener(\\"change\\", e => {\\r\\n        const isDeviceDarkModeEnabled = e.matches;\\r\\n        // Vuetify切り替える\\r\\n        this.$vuetify.theme.dark = isDeviceDarkModeEnabled\\r\\n      });\\r\\n```\\r\\n\\r\\n**StackOverflow**先生の回答では`e.matches`に`darkかlight`が入ってるっぽいんですが、私のChromeくんでは`trueかfalse`でした。先生の回答ちょっと古かったのかな。\\r\\n\\r\\n~~まあダークモードなんてあんま使わないんですけどね（は？）~~\\r\\n\\r\\n## おわりに\\r\\n学校始まるわ。早起きつっら  \\r\\nあと画像貼る方法確立してない。imgur使うか？","bodyHtml":"<p>Hexoってすごいんだなって。<br>\\nなお完成はいつになるかわかりません。いつ出来上がるんだこれ？<br>\\n完成までに思ったことを書いていくと思う。</p>\\n<p><s>あとドメインが欲しい。買ったこと無いけどどうなんですかね？</s></p>\\n<p><a href=\\"/posts/domain_katta\\">取りました</a></p>\\n<h2>これ作るのに大変だったこと</h2>\\n<p>書く。</p>\\n<h3>Vuetifyが<code>&lt;code&gt;</code>に色つける。</h3>\\n<p>Vuetifyくんが勝手に色を付けてくれます。が、なんかいまいちなので頑張ってCSS書いて直したいんですが、<br>\\nVuetifyくんが許してくれません。？<br>\\nしかたないので<code>!important</code>で黙らせました。</p>\\n<p>assets/css/styles.css</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/* VuetifyのせいでCodeタグに勝手にCSS適用されるので強制上書き */</span>\\n\\n<span class=\\"hljs-selector-class\\">.v-application</span> <span class=\\"hljs-selector-tag\\">code</span> {\\n    <span class=\\"hljs-attribute\\">box-shadow</span>: initial <span class=\\"hljs-meta\\">!important</span>;\\n    <span class=\\"hljs-attribute\\">border</span>: <span class=\\"hljs-number\\">1px</span> solid gray;\\n    <span class=\\"hljs-attribute\\">border-radius</span>: <span class=\\"hljs-number\\">5px</span> <span class=\\"hljs-meta\\">!important</span>;\\n    <span class=\\"hljs-attribute\\">font-family</span>: <span class=\\"hljs-string\\">\'Koruri Regular\'</span>;\\n    <span class=\\"hljs-attribute\\">margin</span>: <span class=\\"hljs-number\\">10px</span>;\\n}\\n\\n<span class=\\"hljs-selector-class\\">.v-application</span> <span class=\\"hljs-selector-tag\\">code</span>, <span class=\\"hljs-selector-class\\">.v-application</span> <span class=\\"hljs-selector-tag\\">kbd</span> {\\n    <span class=\\"hljs-attribute\\">font-weight</span>: initial <span class=\\"hljs-meta\\">!important</span>;\\n}</code></pre><p>ついでに<code>highlight.js</code>のCSS、<code>vs2015.css</code>を入れてコードにシンタックスハイライトをつけようとしたんですけど、これもうまく動かなかったので<code>vs2015.css</code>に<code>!important</code>付けて対応しました。</p>\\n<h3>CSS</h3>\\n<p>CSSよくわがんね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/* ほばー */</span>\\n<span class=\\"hljs-selector-class\\">.titleHover</span><span class=\\"hljs-selector-pseudo\\">:hover</span> {\\n    <span class=\\"hljs-attribute\\">color</span>: <span class=\\"hljs-number\\">#5870cb</span>;\\n    <span class=\\"hljs-attribute\\">transition</span>: color <span class=\\"hljs-number\\">0.5s</span>;\\n}</code></pre><p>これは記事一覧のタイトルをマウスオーバーするとジワーッと色が変わるCSSです。</p>\\n<h3>Processmdくんが時系列順に並べてくれない</h3>\\n<p>これはおま環境かもしれないけど、時系列順に並んでくれません。<br>\\n流石に時系列順にならないのはきついので、JavaScriptで時系列に並び替えるコードを書きました。sort関数あったし。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// なんかしらんけど並び順が新しい順とは限らないらしい？</span>\\n<span class=\\"hljs-keyword\\">const</span> sortedKeyList = <span class=\\"hljs-built_in\\">Object</span>.keys(fileMap);\\nsortedKeyList.sort(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">a, b</span>) </span>{\\n  <span class=\\"hljs-keyword\\">const</span> aDate = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Date</span>(fileMap[a].created_at).getTime();\\n  <span class=\\"hljs-keyword\\">const</span> bDate = <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Date</span>(fileMap[b].created_at).getTime();\\n  <span class=\\"hljs-keyword\\">if</span> (aDate &gt; bDate) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">-1</span>;\\n  <span class=\\"hljs-keyword\\">if</span> (aDate &lt; bDate) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">1</span>;\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-number\\">0</span>;\\n});</code></pre><p>Kotlinの<code>sortBy{}</code>とは使い方が違っててちょっと迷った。</p>\\n<p>あとprocessmdくん、/posts/jsonに消した記事が残ってるんですがそれは、、</p>\\n<h3>ページネーション</h3>\\n<p>追記（2020/06/27）：もしかしたらこれ書く必要ないと思う（<code>_id.vue</code>ファイルは必要だと思う）<br>\\n詳細→ <a href=\\"/posts/nuxt_2_13_sugoi\\">Nuxt.jsを2.13に上げた時の話</a></p>\\n<p>次のページ、前のページを付けることを、ページネーションって言うそうですよ。<br>\\nこれ付けないと記事が増えたときのスクロールがとんでもないことになる。</p>\\n<p>記事一覧はこんな感じに静的に出してほしいので（postsに置くとタイトル被りそうなのでpageフォルダがある。）</p>\\n<pre><code class=\\"hljs\\">/posts/page/1</code></pre><p>特に需要はなさそうですが一応必要なページ数に合わせて<code>posts/page</code>の配列を返す関数置いときますね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/** 次のページ機能をつける。そうしないと記事一覧にどばーってなってスクロール大変になる */</span>\\n<span class=\\"hljs-keyword\\">const</span> generatePagenationRoutesList = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">()</span> =&gt;</span> {\\n  <span class=\\"hljs-comment\\">// 何ページ必要か計算する（10で割ればいいっしょ）。ただ1ページ目は最低限必要なので1足す</span>\\n  <span class=\\"hljs-keyword\\">const</span> calc = <span class=\\"hljs-built_in\\">Math</span>.floor(postsJSON.sourceFileArray.length / PAGE_LIMIT) + <span class=\\"hljs-number\\">1</span>\\n  <span class=\\"hljs-comment\\">// ページ分だけ動的ルーティングの配列出す？</span>\\n  <span class=\\"hljs-keyword\\">const</span> dynamicRouterPathList = []\\n  <span class=\\"hljs-comment\\">// console.log(`ページ数：${calc} / 記事数：${postsJSON.sourceFileArray.length}`)</span>\\n  <span class=\\"hljs-comment\\">// ページ生成。1ページ目から作るので1からスタート</span>\\n  <span class=\\"hljs-keyword\\">for</span> (<span class=\\"hljs-keyword\\">let</span> i = <span class=\\"hljs-number\\">1</span>; i &lt;= calc; i++) {\\n    dynamicRouterPathList.push(<span class=\\"hljs-string\\">`/posts/page/<span class=\\"hljs-subst\\">${i}</span>`</span>)\\n  }\\n  <span class=\\"hljs-keyword\\">return</span> dynamicRouterPathList\\n}\\n\\n<span class=\\"hljs-comment\\">// 省略</span>\\n\\n<span class=\\"hljs-comment\\">/** 静的サイトジェネレート関数。配列(pages/とposts/)くっつける */</span>\\n<span class=\\"hljs-keyword\\">const</span> generateRoutes = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">callback</span> =&gt;</span> {\\n  callback(<span class=\\"hljs-literal\\">null</span>, [generatePagenationRoutesList()].flat())\\n}</code></pre><p>これ動かすには<code>postsフォルダ</code>に<code>pageフォルダ</code>を作って中に、<code>_id.vue</code>を置いておく必要があります。</p>\\n<p>これで<code>posts/page/1</code>などが生成されるようになります（多分）</p>\\n<p><s>この記事書いてる途中でなんでこれ動いてんのかよくわからなくなったのは内緒</s>←やっぱり生成できてなかったので直しました。（2020/06/03）</p>\\n<h3><code>&lt;v-card&gt;</code>が遅い？→いつの間にか直った？</h3>\\n<p>何故か知りませんが、VuetiryのCardコンポーネントがおそい。というかページ遷移がこいつのせいで遅くなる。</p>\\n<p>せっかくの静的サイトで遅いのは辛いので直したい。（しかも記事一覧に戻った時にワンテンポ遅れるとか見てられない）</p>\\n<p>で、なぜか<code>&lt;v-card&gt;</code>を<code>&lt;v-sheet&gt;</code>に置き換えることで解決しました。</p>\\n<p>なんで？</p>\\n<h3>記事一覧を再読み込みした後記事を開くと404</h3>\\n<p>なんかしらんけどF5するとURLの後ろに<code>/</code>が入ります。<br>\\n最後に<code>/</code>が入っていないのが前提で作っているので、最後に入ると <strong><code>../</code>(一個前に戻る)</strong> がおかしな場所を指すようになります。</p>\\n<p>---追記---</p>\\n<p><strong>別に<code>../</code>使わなくても良いことに気付いたのでこの問題は解決しました。</strong><br>\\n<strong><code>to=\'/posts/first\'</code>みたいな感じで別に戻る必要ありませんでした。</strong></p>\\n<p>---追記おわり---</p>\\n<p>というかこれは私の作り方（ファイル構成）が悪いですね、なんで戻ったりしないといけないんだ。</p>\\n<ul>\\n<li>pages\\n<ul>\\n<li>pages（固定ページ。今回は省略）</li>\\n<li>posts（ブログ）\\n<ul>\\n<li>page\\n<ul>\\n<li>_id.vue（記事一覧）</li>\\n</ul>\\n</li>\\n<li>tag\\n<ul>\\n<li>_id.vue（タグ検索結果）</li>\\n</ul>\\n</li>\\n<li>index.vue（本来ここに記事一覧が有るべき？）</li>\\n<li>_slug.vue（記事。ここに居るので一覧から来たら戻らないといけない。）</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<p>今回は<code>nuxt.config.js</code>を開き、URLの最後に<code>/</code>を入れる設定を付けました。おかげて修正が必要になりましたが。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">export</span>.default {\\n  <span class=\\"hljs-comment\\">// 省略</span>\\n  <span class=\\"hljs-attr\\">router</span>: {\\n    <span class=\\"hljs-attr\\">base</span>: <span class=\\"hljs-string\\">\'/Ziyuutyou/\'</span>,\\n    <span class=\\"hljs-attr\\">trailingSlash</span>: <span class=\\"hljs-literal\\">true</span> <span class=\\"hljs-comment\\">// ←これ</span>\\n  }\\n}</code></pre><h3><code>sw.js</code>がよくわからんけどバージョン管理対象外になってて<strong>ホーム画面に追加</strong>が消えてた</h3>\\n<p>GitHubのリポジトリ開いて<code>/docs</code>開いたら見事にServiceWorkerだけ抜けてました。なんで？</p>\\n<h3>Hexoと違ってリアルタイムで記事の内容が反映されない</h3>\\n<p>Hexoって書いてる途中でも、リロードすれば記事の内容が更新されてどんな感じに見れてるか確認できるんですけど、processmdくんデフォルトだとできないっぽい？<br>\\n<code>processmd</code>見る感じ、ファイルの中身を監視する<code>--watch</code>オプションが存在するのでそれ使えばよさそうです、<br>\\nそれで適当に<code>package.json</code>の<code>scripts</code>の中に実行とprocessmdの監視オプション付きを同時に実行する様に書いたんですけど、<br>\\n<strong>nuxt起動から先に進みません！そりゃnuxtもファイルを監視してるからそこで止まりますよね。</strong></p>\\n<p>それでどうすれば同時に（並列に）起動できるかって話ですが、<code>npm-run-all</code>ってのを使えば並列実行ができそうです。<br>\\nただ、これ使っても更新できるのは記事の中身だけで記事一覧(summary.json)は更新できないっぽいです。(nuxt起動時にsummary.jsonが空っぽだぞって怒られる。どうやら一度消えるらしい？)</p>\\n<p>でも記事の中身がリアルタイムで反映されるようになったので満足です。VSCode半分にしなくて済むし。<br>\\n参考程度の<code>package.json</code>のscript</p>\\n<pre><code class=\\"hljs\\">{\\n  <span class=\\"hljs-attr\\">\\"scripts\\"</span>: {\\n    <span class=\\"hljs-attr\\">\\"dev\\"</span>: <span class=\\"hljs-string\\">\\"nuxt --port 11451\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"build\\"</span>: <span class=\\"hljs-string\\">\\"nuxt build\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"start\\"</span>: <span class=\\"hljs-string\\">\\"nuxt start\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"generate\\"</span>: <span class=\\"hljs-string\\">\\"nuxt generate\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"markdown\\"</span>: <span class=\\"hljs-string\\">\\"npm run post &amp;&amp; npm run page\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"page\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/pages/**/*.md --stdout --outputDir contents/pages/json &gt; contents/pages/summary.json --markdownOptions.linkify\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"post\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json &gt; contents/posts/summary.json --markdownOptions.linkify\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"pagewatch\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/pages/**/*.md --outputDir contents/pages/json --markdownOptions.linkify --watch\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"postwatch\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/posts/**/*.md --outputDir contents/posts/json --markdownOptions.linkify --watch\\"</span>,\\n    <span class=\\"hljs-attr\\">\\"all\\"</span>: <span class=\\"hljs-string\\">\\"npm-run-all markdown --parallel dev postwatch\\"</span>\\n  },\\n}</code></pre><p><code>npm run all</code>を実行すると</p>\\n<ul>\\n<li>markdownファイルがJSON形式に変換される</li>\\n<li>nuxt起動</li>\\n<li>nuxt起動と同時にprocessmdの監視を始める\\n<ul>\\n<li><code>--stdout</code>オプションは外してあるので、記事一覧は更新されない。</li>\\n</ul>\\n</li>\\n</ul>\\n<p><code>--parallel</code>のあとに指定したスクリプトが並列で実行され、その前に書いてあるスクリプトは直列で実行されます。</p>\\n<p>ちなみにprocessmdくんがJSONファイルを書き換えるとnuxtのファイル変更監視に引っかかるので自動で更新されるようになります。すげえ</p>\\n<p><s>たまにundefinedになるけどしゃーない</s></p>\\n<h3>マークダウンに書いたURLがリンクにならない</h3>\\n<p>processmdくんのオプションに<code>--markdownOptions.linkify</code>をくっつけて実行すればいいです。</p>\\n<pre><code class=\\"hljs\\">{\\n  <span class=\\"hljs-attr\\">\\"scripts\\"</span>: {\\n    <span class=\\"hljs-attr\\">\\"post\\"</span>: <span class=\\"hljs-string\\">\\"processmd contents/posts/**/*.md --stdout --outputDir contents/posts/json &gt; contents/posts/summary.json --markdownOptions.linkify\\"</span>\\n  }\\n}</code></pre><h3><s>しれっと</s>Netlifyにお引越ししたりした。</h3>\\n<p>GitHubPagesより良いのかはしらんけどお試しで引っ越してみた。これ勝手にメアド公開したりしないよな？<br>\\n<a href=\\"https://ja.nuxtjs.org/faq/netlify-deployment/\\">Netlify へデプロイするには？</a>ってのが有るのでそれに沿ってやればできると思います。</p>\\n<p>じゃあなんで<strong>大変だったこと</strong>に書いてんだよって話ですが、っぱコケるんですね。</p>\\n<p>&lt;iframe src=&quot;<a href=\\"https://best-friends.chat/@takusan_23/104330325427830329/embed\\">https://best-friends.chat/@takusan_23/104330325427830329/embed</a>&quot; class=&quot;mastodon-embed&quot; style=&quot;max-width: 100%; border: 0; height:200px&quot; width=&quot;400&quot; allowfullscreen=&quot;allowfullscreen&quot;&gt;&lt;/iframe&gt;&lt;script src=&quot;<a href=\\"https://best-friends.chat/embed.js\\">https://best-friends.chat/embed.js</a>&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</p>\\n<p>あーJSだからしゃーないのかなーなんて思ってとりあえず検索すると、<code>Chromeのバージョン的に対応していない</code>とか出てきたのでワンちゃんNode.jsくんのバージョンがおかしいのではないかと考えました。</p>\\n<p>NetlifyにNode.jsのバージョンを指定する方法ですが、検索したらありました。 <a href=\\"https://qiita.com/n0bisuke/items/8bddad87610b01c90003\\">参考元</a></p>\\n<p><code>.nvmrc</code>というファイルを置いて、中にNode.jsのバージョンを書くだけで解決しました。</p>\\n<p><code>v12.14.1</code></p>\\n<p>これだけ。これで成功しました。</p>\\n<p>ちなみサイト作成時のステップ３で、ビルドコマンドに<code>npm run generate</code>、ディレクトリを<code>docs(GitHubPagesの名残)</code>すれば、コミット+プッシュ時に勝手に<code>npm run genreate</code>して公開してくれます。らく</p>\\n<h3>実は静的サイト書き出しできてなかった</h3>\\n<p>これは別に記事に書いた→ <a href=\\"/posts/nuxt_universal\\">Nuxtの静的サイトジェネレートはモードをuniversalにしよう</a></p>\\n<p>読みたくない方向け→<code>nuxt.config.js</code>の<code>mode:</code>を<code>universal</code>にすればHTMLに書き出してくれます。<br>\\n<code>spa</code>だとHTMLのbody見てもscriptタグが何個か有るだけで、内容はJS実行されるまで表示されませんでした。<br>\\n<code>universal</code>ならHTMLに書き出してくれるのでJS切っても見れます。</p>\\n<h3>(本当かわからんけど)開発時(localhost)の時は別のタブで開けない？</h3>\\n<p>記事を別のタブで開くと永遠に読み込んでたりするんだけどもしかして別のタブで開くことできない？</p>\\n<h2>特に大変じゃなかったこと</h2>\\n<h3>PWA</h3>\\n<p>PWAってめんどいんですよ。アイコン画像を用意するのがね！！！。<br>\\n192x192だったり512x512だったりいっぱい要求してくるんですけど、<br>\\n<code>@nuxt/pwa</code>は指定がない場合、<code>static/icon.png</code>を使ってくれるので、512x512のpngを置いておくだけで終わりました。PWA RTA行けそう（は？）</p>\\n<p>一応<code>nuxt.config.js</code>の<code>manifest</code>置いておきますね。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/** \\n * PWA manifest.json\\n */</span>\\n<span class=\\"hljs-attr\\">manifest</span>: {\\n  <span class=\\"hljs-attr\\">name</span>: <span class=\\"hljs-string\\">\'たくさんの自由帳\'</span>,\\n  <span class=\\"hljs-attr\\">title</span>: <span class=\\"hljs-string\\">\'たくさんの自由帳\'</span>,\\n  <span class=\\"hljs-string\\">\'og:title\'</span>: <span class=\\"hljs-string\\">\'たくさんの自由帳\'</span>,\\n  <span class=\\"hljs-attr\\">lang</span>: <span class=\\"hljs-string\\">\'ja\'</span>,\\n  <span class=\\"hljs-attr\\">theme_color</span>: <span class=\\"hljs-string\\">\'#8c9eff\'</span>,\\n  <span class=\\"hljs-attr\\">background_color</span>: <span class=\\"hljs-string\\">\'#5870cb\'</span>,\\n  <span class=\\"hljs-attr\\">display</span>: <span class=\\"hljs-string\\">\'standalone\'</span>,\\n}</code></pre><h3>ダークモード</h3>\\n<p>Vuetifyなら</p>\\n<pre><code class=\\"hljs\\">$vuetify.theme.dark = <span class=\\"hljs-literal\\">true</span></code></pre><p>で終わります。Vuetifyすげー</p>\\n<p>ダークモード切り替えスイッチの例置いときますね。</p>\\n<pre><code class=\\"hljs\\">&lt;!-- ダークモードスイッチ --&gt;\\n<span class=\\"xml\\"><span class=\\"hljs-tag\\">&lt;<span class=\\"hljs-name\\">v-switch</span>\\n  <span class=\\"hljs-attr\\">class</span>=<span class=\\"hljs-string\\">\\"text-center ma-2\\"</span>\\n  <span class=\\"hljs-attr\\">:append-icon</span>=<span class=\\"hljs-string\\">\\"`${$vuetify.theme.dark ? \'mdi-weather-night\' : \'mdi-weather-sunny\'}`\\"</span>\\n  <span class=\\"hljs-attr\\">v-model</span>=<span class=\\"hljs-string\\">\\"$vuetify.theme.dark\\"</span>\\n  <span class=\\"hljs-attr\\">label</span>=<span class=\\"hljs-string\\">\\"テーマ切り替え\\"</span>\\n&gt;</span><span class=\\"hljs-tag\\">&lt;/<span class=\\"hljs-name\\">v-switch</span>&gt;</span></span></code></pre><p>三項演算子使うの初めてかもしれない（まずKotlinにはないし）</p>\\n<p>ところで$←これなに？</p>\\n<h3>端末がダークモードかどうか</h3>\\n<p>以下のJSでダークモードかどうかを監視して、Vuetifyのモードを変更するようにできます。<br>\\n<a href=\\"https://stackoverflow.com/questions/56393880/how-do-i-detect-dark-mode-using-javascript\\">参考：StackOverflow</a></p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-built_in\\">window</span>\\n      .matchMedia(<span class=\\"hljs-string\\">\\"(prefers-color-scheme: dark)\\"</span>)\\n      .addEventListener(<span class=\\"hljs-string\\">\\"change\\"</span>, e =&gt; {\\n        <span class=\\"hljs-keyword\\">const</span> isDeviceDarkModeEnabled = e.matches;\\n        <span class=\\"hljs-comment\\">// Vuetify切り替える</span>\\n        <span class=\\"hljs-keyword\\">this</span>.$vuetify.theme.dark = isDeviceDarkModeEnabled\\n      });</code></pre><p><strong>StackOverflow</strong>先生の回答では<code>e.matches</code>に<code>darkかlight</code>が入ってるっぽいんですが、私のChromeくんでは<code>trueかfalse</code>でした。先生の回答ちょっと古かったのかな。</p>\\n<p><s>まあダークモードなんてあんま使わないんですけどね（は？）</s></p>\\n<h2>おわりに</h2>\\n<p>学校始まるわ。早起きつっら<br>\\nあと画像貼る方法確立してない。imgur使うか？</p>\\n","dir":"contents/posts/json","base":"taihendattakoto.json","ext":".json","sourceBase":"taihendattakoto.md","sourceExt":".md"}')},618:function(n){n.exports=JSON.parse('{"title":"自作ブログ(Nuxt.js+processmd)の使い方","created_at":"2020-05-31 21:10:00","tags":["とりせつ","その他","Markdown","NuxtJS","自作ブログ","JavaScript"],"bodyContent":"# 自作ブログ(Nuxt.js+processmd)の使い方\\r\\nめも\\r\\n\\r\\n# 起動方法\\r\\n\\r\\n```console\\r\\nnpm run dev\\r\\n```\\r\\n\\r\\n# ファイル構成\\r\\n\\r\\n多分こうなってるはず\\r\\n\\r\\n- assets\\r\\n    - CSSファイル置いてある（フォント指定のために）\\r\\n- Components\\r\\n    - Vue.jsのやつと同じだと思う。\\r\\n    - UIの部品を分けて他で使い回す的な\\r\\n    - AndroidのFragmentに近いかな？\\r\\n- contents\\r\\n    - 重要フォルダ。\\r\\n    - 最重要なので後で詳しく。\\r\\n- dist\\r\\n    - `nuxt generate`で書き出したファイルの置き場所です。\\r\\n    - htmlがある。\\r\\n    - あとはこのフォルダでWebサーバー建てるなりすれば見れるはずです。\\r\\n- layouts\\r\\n    - （Viewの階層的に）一番下に居るやつ。\\r\\n    - AppBarとかNavigationDrawerはここに書いてある。\\r\\n    - Androidで言うとActivity？\\r\\n- middleware\\r\\n    - さあ？\\r\\n- node_modules\\r\\n    - 多分ライブラリが入ってる。基本いじらない。\\r\\n    - ~~Black holeよりも深い~~\\r\\n    - npmコマンドでコケた時はまず消して`npm install`する。\\r\\n- plugins\\r\\n    - GoogleAnalyticsのためのJSが一個だけ置いてある。\\r\\n- static\\r\\n    - 静的サイトジェネレートのときのfaviconとか？\\r\\n- store\\r\\n    - さあ？\\r\\n- .から始まるファイル\\r\\n    - 基本触らないと思う\\r\\n- nuxt.config.js\\r\\n    - 静的サイトジェネレートの時にどのファイルを作ればいいかとか書く。\\r\\n    - Vuetifyでなんかやるときも書く。\\r\\n    - cssとかも\\r\\n- package-look.json\\r\\n    - ？\\r\\n- package.json\\r\\n    - このプログラムについてなど。\\r\\n    - 作者とかライセンスとかが書いてある。\\r\\n    - 必要なライブラリも書いてある。\\r\\n- README.md\\r\\n    - GitHub以外で見ること有る？\\r\\n- tsconfig.json\\r\\n    - ？\\r\\n# contentsフォルダについて / 記事の書き方\\r\\n## 共通\\r\\n記事を書いたら以下のコマンドを入れてね。（JSONファイルを更新するため）  \\r\\n↓ブログ(posts)書いたとき\\r\\n```console\\r\\nnpm run post\\r\\n```\\r\\n↓固定ページ(markdown)書いたとき\\r\\n```console\\r\\nnpm run page\\r\\n```  \\r\\n↓同時に実行する\\r\\n```console\\r\\nnpm run markdown\\r\\n```\\r\\n## contents/pages/markdown\\r\\n固定ページを書く時に使います。  \\r\\nこのサイトでは`pages/about`(このサイトについて)を書く時に使いました。  \\r\\nNuxt Routerでは`pages/{ファイル名}`を指定する。\\r\\n## contents/posts/markdown\\r\\nブログ書く時に使う。  \\r\\n記事はここに入れる。  \\r\\nNuxt Routerでは`posts/{ファイル名}`を指定する。\\r\\n\\r\\nなおどちらも`contents/*/markdown`に入れてね。（他にもjsonとかsummary.jsonとか有るけど気にするな。）  \\r\\nそうしないとJSON生成（ブログ一覧生成など）でコケる気がします。\\r\\n\\r\\n## scripts\\r\\n起動：`npm run dev`  \\r\\n起動＋Markdownファイル監視（推奨）：`npm run all`  \\r\\nMarkdownファイルをJSON化：`npm run markdown`  \\r\\n/contents/pageだけJSON化：`npm run page`  \\r\\n/contents/postだけJSON化：`npm run post`  \\r\\n静的サイト書き出し：`npm run generate`\\r\\n\\r\\n## markdownひながた\\r\\n↓これをmarkdownの先頭に書いてください。  \\r\\nそれぞれ適切な値を入れてね。\\r\\n```markdown\\r\\n---\\r\\ntitle: タイトル\\r\\ncreated_at: 2020-05-31\\r\\ntags:\\r\\n- Android\\r\\n---\\r\\n```\\r\\n\\r\\nいじょう？","bodyHtml":"<h1>自作ブログ(Nuxt.js+processmd)の使い方</h1>\\n<p>めも</p>\\n<h1>起動方法</h1>\\n<pre><code class=\\"hljs\\">npm run dev</code></pre><h1>ファイル構成</h1>\\n<p>多分こうなってるはず</p>\\n<ul>\\n<li>assets\\n<ul>\\n<li>CSSファイル置いてある（フォント指定のために）</li>\\n</ul>\\n</li>\\n<li>Components\\n<ul>\\n<li>Vue.jsのやつと同じだと思う。</li>\\n<li>UIの部品を分けて他で使い回す的な</li>\\n<li>AndroidのFragmentに近いかな？</li>\\n</ul>\\n</li>\\n<li>contents\\n<ul>\\n<li>重要フォルダ。</li>\\n<li>最重要なので後で詳しく。</li>\\n</ul>\\n</li>\\n<li>dist\\n<ul>\\n<li><code>nuxt generate</code>で書き出したファイルの置き場所です。</li>\\n<li>htmlがある。</li>\\n<li>あとはこのフォルダでWebサーバー建てるなりすれば見れるはずです。</li>\\n</ul>\\n</li>\\n<li>layouts\\n<ul>\\n<li>（Viewの階層的に）一番下に居るやつ。</li>\\n<li>AppBarとかNavigationDrawerはここに書いてある。</li>\\n<li>Androidで言うとActivity？</li>\\n</ul>\\n</li>\\n<li>middleware\\n<ul>\\n<li>さあ？</li>\\n</ul>\\n</li>\\n<li>node_modules\\n<ul>\\n<li>多分ライブラリが入ってる。基本いじらない。</li>\\n<li><s>Black holeよりも深い</s></li>\\n<li>npmコマンドでコケた時はまず消して<code>npm install</code>する。</li>\\n</ul>\\n</li>\\n<li>plugins\\n<ul>\\n<li>GoogleAnalyticsのためのJSが一個だけ置いてある。</li>\\n</ul>\\n</li>\\n<li>static\\n<ul>\\n<li>静的サイトジェネレートのときのfaviconとか？</li>\\n</ul>\\n</li>\\n<li>store\\n<ul>\\n<li>さあ？</li>\\n</ul>\\n</li>\\n<li>.から始まるファイル\\n<ul>\\n<li>基本触らないと思う</li>\\n</ul>\\n</li>\\n<li>nuxt.config.js\\n<ul>\\n<li>静的サイトジェネレートの時にどのファイルを作ればいいかとか書く。</li>\\n<li>Vuetifyでなんかやるときも書く。</li>\\n<li>cssとかも</li>\\n</ul>\\n</li>\\n<li>package-look.json\\n<ul>\\n<li>？</li>\\n</ul>\\n</li>\\n<li>package.json\\n<ul>\\n<li>このプログラムについてなど。</li>\\n<li>作者とかライセンスとかが書いてある。</li>\\n<li>必要なライブラリも書いてある。</li>\\n</ul>\\n</li>\\n<li><a href=\\"http://README.md\\">README.md</a>\\n<ul>\\n<li>GitHub以外で見ること有る？</li>\\n</ul>\\n</li>\\n<li>tsconfig.json\\n<ul>\\n<li>？</li>\\n</ul>\\n</li>\\n</ul>\\n<h1>contentsフォルダについて / 記事の書き方</h1>\\n<h2>共通</h2>\\n<p>記事を書いたら以下のコマンドを入れてね。（JSONファイルを更新するため）<br>\\n↓ブログ(posts)書いたとき</p>\\n<pre><code class=\\"hljs\\">npm run post</code></pre><p>↓固定ページ(markdown)書いたとき</p>\\n<pre><code class=\\"hljs\\">npm run page</code></pre><p>↓同時に実行する</p>\\n<pre><code class=\\"hljs\\">npm run markdown</code></pre><h2>contents/pages/markdown</h2>\\n<p>固定ページを書く時に使います。<br>\\nこのサイトでは<code>pages/about</code>(このサイトについて)を書く時に使いました。<br>\\nNuxt Routerでは<code>pages/{ファイル名}</code>を指定する。</p>\\n<h2>contents/posts/markdown</h2>\\n<p>ブログ書く時に使う。<br>\\n記事はここに入れる。<br>\\nNuxt Routerでは<code>posts/{ファイル名}</code>を指定する。</p>\\n<p>なおどちらも<code>contents/*/markdown</code>に入れてね。（他にもjsonとかsummary.jsonとか有るけど気にするな。）<br>\\nそうしないとJSON生成（ブログ一覧生成など）でコケる気がします。</p>\\n<h2>scripts</h2>\\n<p>起動：<code>npm run dev</code><br>\\n起動＋Markdownファイル監視（推奨）：<code>npm run all</code><br>\\nMarkdownファイルをJSON化：<code>npm run markdown</code><br>\\n/contents/pageだけJSON化：<code>npm run page</code><br>\\n/contents/postだけJSON化：<code>npm run post</code><br>\\n静的サイト書き出し：<code>npm run generate</code></p>\\n<h2>markdownひながた</h2>\\n<p>↓これをmarkdownの先頭に書いてください。<br>\\nそれぞれ適切な値を入れてね。</p>\\n<pre><code class=\\"hljs\\">---\\ntitle: タイトル\\ncreated_at: 2020-05-31\\ntags:\\n<span class=\\"hljs-section\\">- Android\\n---</span></code></pre><p>いじょう？</p>\\n","dir":"contents/posts/json","base":"usersmanual.json","ext":".json","sourceBase":"usersmanual.md","sourceExt":".md"}')},626:function(n,t,r){"use strict";r.r(t);r(35),r(36);var summary=r(582),e=r(583),o={components:{},data:function(){return{sheet:!1,instanceInput:""}},methods:{openShare:function(){window.open("https://".concat(this.instanceInput,"/share?text=").concat(document.title,"\n").concat(location.href),"_blank"),localStorage.setItem("share_instance",this.instanceInput)}},mounted:function(){var n=localStorage.getItem("share_instance");void 0!==n&&(this.instanceInput=n)}},l=r(65),c=r(88),d=r.n(c),h=r(627),m=r(190),j=r(127),k=r(589),y=r(30),f=r(631),component=Object(l.a)(o,(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("div",[r("v-btn",{attrs:{color:"primary",text:""},on:{click:function(t){n.sheet=!n.sheet}}},[r("v-icon",[n._v("mdi-share-variant")]),n._v("Mastodon / Misskey で共有\n  ")],1),n._v(" "),r("v-bottom-sheet",{model:{value:n.sheet,callback:function(t){n.sheet=t},expression:"sheet"}},[r("v-sheet",{staticClass:"pa-5 text-center",attrs:{height:"200px"}},[r("h3",{staticClass:"ma-1"},[n._v("Mastodon / Misskey のインスタンス名を入れてね。")]),n._v(" "),r("v-text-field",{attrs:{label:"インスタンス名",outlined:""},model:{value:n.instanceInput,callback:function(t){n.instanceInput=t},expression:"instanceInput"}}),n._v(" "),r("v-row",{staticClass:"mr-2",attrs:{justify:"end"}},[r("v-btn",{attrs:{large:"",color:"primary"},on:{click:function(t){return n.openShare()}}},[r("v-icon",[n._v("mdi-send")]),n._v("共有\n        ")],1)],1)],1)],1)],1)}),[],!1,null,null,null),w=component.exports;d()(component,{VBottomSheet:h.a,VBtn:m.a,VIcon:j.a,VRow:k.a,VSheet:y.a,VTextField:f.a});var v={validate:function(n){var t=n.params;return summary.sourceFileArray.includes("contents/posts/markdown/".concat(t.slug,".md"))},asyncData:function(n){var t=n.params;return Object.assign({},r(604)("./".concat(t.slug,".json")),{params:t})},mounted:function(){document.getElementById("title").innerText=this.title},head:function(){var title="".concat(this.title),n="posts/".concat(this.params.slug,"/");return{title:title,meta:[{hid:"og:url",property:"og:url",content:n},{hid:"og:title",property:"og:title",content:title}],link:[{rel:"canonical",href:n}]}},data:function(){return{instans:["best-friends.chat","pawoo.net"]}},methods:{shareDon:function(n){open("https://".concat(n,"/share?text=").concat(this.title,"\n").concat(location.href),"_brank")}},components:{TagGroup:e.a,MastodonShare:w}},x=r(573),S=r(571),_=r(563),T=Object(l.a)(v,(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("v-card",{staticClass:"pa-5",staticStyle:{"margin-top":"-64px"},attrs:{elevation:"10"}},[r("div",{staticClass:"post-meta pa-2"},[r("v-icon",[n._v("mdi-file-upload-outline")]),n._v(" "),r("time",[n._v(n._s(new Date(this.created_at).toLocaleDateString())+" 投稿")])],1),n._v(" "),r("TagGroup",{attrs:{tags:this.tags}}),n._v(" "),r("v-divider"),n._v(" "),r("div",{attrs:{id:"content"},domProps:{innerHTML:n._s(n.$md.render(n.bodyContent))}}),n._v(" "),r("div",{attrs:{id:"count"}}),n._v(" "),r("v-divider"),n._v(" "),r("v-card-actions",[r("v-row",{attrs:{align:"center",justify:"end"}},[r("MastodonShare")],1)],1)],1)}),[],!1,null,null,null);t.default=T.exports;d()(T,{VCard:x.a,VCardActions:S.a,VDivider:_.a,VIcon:j.a,VRow:k.a})}}]);